// Generated from KotlinParser.g4 by ANTLR 4.8
#![allow(dead_code)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(nonstandard_style)]
#![allow(unused_imports)]
#![allow(unused_mut)]
use antlr_rust::PredictionContextCache;
use antlr_rust::parser::{Parser, BaseParser, ParserRecog, ParserNodeType};
use antlr_rust::token_stream::TokenStream;
use antlr_rust::TokenSource;
use antlr_rust::parser_atn_simulator::ParserATNSimulator;
use antlr_rust::errors::*;
use antlr_rust::rule_context::{BaseRuleContext, CustomRuleContext, RuleContext};
use antlr_rust::recognizer::{Recognizer,Actions};
use antlr_rust::atn_deserializer::ATNDeserializer;
use antlr_rust::dfa::DFA;
use antlr_rust::atn::{ATN, INVALID_ALT};
use antlr_rust::error_strategy::{ErrorStrategy, DefaultErrorStrategy};
use antlr_rust::parser_rule_context::{BaseParserRuleContext, ParserRuleContext,cast,cast_mut};
use antlr_rust::tree::*;
use antlr_rust::token::{TOKEN_EOF,OwningToken,Token};
use antlr_rust::int_stream::EOF;
use antlr_rust::vocabulary::{Vocabulary,VocabularyImpl};
use antlr_rust::token_factory::{CommonTokenFactory,TokenFactory, TokenAware};
use super::kotlinparserlistener::*;
use super::kotlinparservisitor::*;

use antlr_rust::lazy_static;
use antlr_rust::{TidAble,TidExt};

use std::marker::PhantomData;
use std::sync::Arc;
use std::rc::Rc;
use std::convert::TryFrom;
use std::cell::RefCell;
use std::ops::{DerefMut, Deref};
use std::borrow::{Borrow,BorrowMut};
use std::any::{Any,TypeId};

		pub const ShebangLine:isize=1; 
		pub const DelimitedComment:isize=2; 
		pub const LineComment:isize=3; 
		pub const WS:isize=4; 
		pub const NL:isize=5; 
		pub const RESERVED:isize=6; 
		pub const DOT:isize=7; 
		pub const COMMA:isize=8; 
		pub const LPAREN:isize=9; 
		pub const RPAREN:isize=10; 
		pub const LSQUARE:isize=11; 
		pub const RSQUARE:isize=12; 
		pub const LCURL:isize=13; 
		pub const RCURL:isize=14; 
		pub const MULT:isize=15; 
		pub const MOD:isize=16; 
		pub const DIV:isize=17; 
		pub const ADD:isize=18; 
		pub const SUB:isize=19; 
		pub const INCR:isize=20; 
		pub const DECR:isize=21; 
		pub const CONJ:isize=22; 
		pub const DISJ:isize=23; 
		pub const EXCL_WS:isize=24; 
		pub const EXCL_NO_WS:isize=25; 
		pub const COLON:isize=26; 
		pub const SEMICOLON:isize=27; 
		pub const ASSIGNMENT:isize=28; 
		pub const ADD_ASSIGNMENT:isize=29; 
		pub const SUB_ASSIGNMENT:isize=30; 
		pub const MULT_ASSIGNMENT:isize=31; 
		pub const DIV_ASSIGNMENT:isize=32; 
		pub const MOD_ASSIGNMENT:isize=33; 
		pub const ARROW:isize=34; 
		pub const DOUBLE_ARROW:isize=35; 
		pub const RANGE:isize=36; 
		pub const RANGE_UNTIL:isize=37; 
		pub const COLONCOLON:isize=38; 
		pub const DOUBLE_SEMICOLON:isize=39; 
		pub const HASH:isize=40; 
		pub const AT_NO_WS:isize=41; 
		pub const AT_POST_WS:isize=42; 
		pub const AT_PRE_WS:isize=43; 
		pub const AT_BOTH_WS:isize=44; 
		pub const QUEST_WS:isize=45; 
		pub const QUEST_NO_WS:isize=46; 
		pub const LANGLE:isize=47; 
		pub const RANGLE:isize=48; 
		pub const LE:isize=49; 
		pub const GE:isize=50; 
		pub const EXCL_EQ:isize=51; 
		pub const EXCL_EQEQ:isize=52; 
		pub const AS_SAFE:isize=53; 
		pub const EQEQ:isize=54; 
		pub const EQEQEQ:isize=55; 
		pub const SINGLE_QUOTE:isize=56; 
		pub const AMP:isize=57; 
		pub const RETURN_AT:isize=58; 
		pub const CONTINUE_AT:isize=59; 
		pub const BREAK_AT:isize=60; 
		pub const THIS_AT:isize=61; 
		pub const SUPER_AT:isize=62; 
		pub const FILE:isize=63; 
		pub const FIELD:isize=64; 
		pub const PROPERTY:isize=65; 
		pub const GET:isize=66; 
		pub const SET:isize=67; 
		pub const RECEIVER:isize=68; 
		pub const PARAM:isize=69; 
		pub const SETPARAM:isize=70; 
		pub const DELEGATE:isize=71; 
		pub const PACKAGE:isize=72; 
		pub const IMPORT:isize=73; 
		pub const CLASS:isize=74; 
		pub const INTERFACE:isize=75; 
		pub const FUN:isize=76; 
		pub const OBJECT:isize=77; 
		pub const VAL:isize=78; 
		pub const VAR:isize=79; 
		pub const TYPE_ALIAS:isize=80; 
		pub const CONSTRUCTOR:isize=81; 
		pub const BY:isize=82; 
		pub const COMPANION:isize=83; 
		pub const INIT:isize=84; 
		pub const THIS:isize=85; 
		pub const SUPER:isize=86; 
		pub const TYPEOF:isize=87; 
		pub const WHERE:isize=88; 
		pub const IF:isize=89; 
		pub const ELSE:isize=90; 
		pub const WHEN:isize=91; 
		pub const TRY:isize=92; 
		pub const CATCH:isize=93; 
		pub const FINALLY:isize=94; 
		pub const FOR:isize=95; 
		pub const DO:isize=96; 
		pub const WHILE:isize=97; 
		pub const THROW:isize=98; 
		pub const RETURN:isize=99; 
		pub const CONTINUE:isize=100; 
		pub const BREAK:isize=101; 
		pub const AS:isize=102; 
		pub const IS:isize=103; 
		pub const IN:isize=104; 
		pub const NOT_IS:isize=105; 
		pub const NOT_IN:isize=106; 
		pub const OUT:isize=107; 
		pub const DYNAMIC:isize=108; 
		pub const PUBLIC:isize=109; 
		pub const PRIVATE:isize=110; 
		pub const PROTECTED:isize=111; 
		pub const INTERNAL:isize=112; 
		pub const ENUM:isize=113; 
		pub const SEALED:isize=114; 
		pub const ANNOTATION:isize=115; 
		pub const DATA:isize=116; 
		pub const INNER:isize=117; 
		pub const VALUE:isize=118; 
		pub const TAILREC:isize=119; 
		pub const OPERATOR:isize=120; 
		pub const INLINE:isize=121; 
		pub const INFIX:isize=122; 
		pub const EXTERNAL:isize=123; 
		pub const SUSPEND:isize=124; 
		pub const OVERRIDE:isize=125; 
		pub const ABSTRACT:isize=126; 
		pub const FINAL:isize=127; 
		pub const OPEN:isize=128; 
		pub const CONST:isize=129; 
		pub const LATEINIT:isize=130; 
		pub const VARARG:isize=131; 
		pub const NOINLINE:isize=132; 
		pub const CROSSINLINE:isize=133; 
		pub const REIFIED:isize=134; 
		pub const EXPECT:isize=135; 
		pub const ACTUAL:isize=136; 
		pub const RealLiteral:isize=137; 
		pub const FloatLiteral:isize=138; 
		pub const DoubleLiteral:isize=139; 
		pub const IntegerLiteral:isize=140; 
		pub const HexLiteral:isize=141; 
		pub const BinLiteral:isize=142; 
		pub const UnsignedLiteral:isize=143; 
		pub const LongLiteral:isize=144; 
		pub const BooleanLiteral:isize=145; 
		pub const NullLiteral:isize=146; 
		pub const CharacterLiteral:isize=147; 
		pub const Identifier:isize=148; 
		pub const IdentifierOrSoftKey:isize=149; 
		pub const FieldIdentifier:isize=150; 
		pub const QUOTE_OPEN:isize=151; 
		pub const TRIPLE_QUOTE_OPEN:isize=152; 
		pub const UNICODE_CLASS_LL:isize=153; 
		pub const UNICODE_CLASS_LM:isize=154; 
		pub const UNICODE_CLASS_LO:isize=155; 
		pub const UNICODE_CLASS_LT:isize=156; 
		pub const UNICODE_CLASS_LU:isize=157; 
		pub const UNICODE_CLASS_ND:isize=158; 
		pub const UNICODE_CLASS_NL:isize=159; 
		pub const QUOTE_CLOSE:isize=160; 
		pub const LineStrRef:isize=161; 
		pub const LineStrText:isize=162; 
		pub const LineStrEscapedChar:isize=163; 
		pub const LineStrExprStart:isize=164; 
		pub const TRIPLE_QUOTE_CLOSE:isize=165; 
		pub const MultiLineStringQuote:isize=166; 
		pub const MultiLineStrRef:isize=167; 
		pub const MultiLineStrText:isize=168; 
		pub const MultiLineStrExprStart:isize=169; 
		pub const Inside_Comment:isize=170; 
		pub const Inside_WS:isize=171; 
		pub const Inside_NL:isize=172; 
		pub const ErrorCharacter:isize=173;
	pub const RULE_kotlinFile:usize = 0; 
	pub const RULE_script:usize = 1; 
	pub const RULE_shebangLine:usize = 2; 
	pub const RULE_fileAnnotation:usize = 3; 
	pub const RULE_packageHeader:usize = 4; 
	pub const RULE_importList:usize = 5; 
	pub const RULE_importHeader:usize = 6; 
	pub const RULE_importAlias:usize = 7; 
	pub const RULE_topLevelObject:usize = 8; 
	pub const RULE_typeAlias:usize = 9; 
	pub const RULE_declaration:usize = 10; 
	pub const RULE_classDeclaration:usize = 11; 
	pub const RULE_primaryConstructor:usize = 12; 
	pub const RULE_classBody:usize = 13; 
	pub const RULE_classParameters:usize = 14; 
	pub const RULE_classParameter:usize = 15; 
	pub const RULE_delegationSpecifiers:usize = 16; 
	pub const RULE_delegationSpecifier:usize = 17; 
	pub const RULE_constructorInvocation:usize = 18; 
	pub const RULE_annotatedDelegationSpecifier:usize = 19; 
	pub const RULE_explicitDelegation:usize = 20; 
	pub const RULE_typeParameters:usize = 21; 
	pub const RULE_typeParameter:usize = 22; 
	pub const RULE_typeConstraints:usize = 23; 
	pub const RULE_typeConstraint:usize = 24; 
	pub const RULE_classMemberDeclarations:usize = 25; 
	pub const RULE_classMemberDeclaration:usize = 26; 
	pub const RULE_anonymousInitializer:usize = 27; 
	pub const RULE_companionObject:usize = 28; 
	pub const RULE_functionValueParameters:usize = 29; 
	pub const RULE_functionValueParameter:usize = 30; 
	pub const RULE_functionDeclaration:usize = 31; 
	pub const RULE_functionBody:usize = 32; 
	pub const RULE_variableDeclaration:usize = 33; 
	pub const RULE_multiVariableDeclaration:usize = 34; 
	pub const RULE_propertyDeclaration:usize = 35; 
	pub const RULE_propertyDelegate:usize = 36; 
	pub const RULE_getter:usize = 37; 
	pub const RULE_setter:usize = 38; 
	pub const RULE_parametersWithOptionalType:usize = 39; 
	pub const RULE_functionValueParameterWithOptionalType:usize = 40; 
	pub const RULE_parameterWithOptionalType:usize = 41; 
	pub const RULE_parameter:usize = 42; 
	pub const RULE_objectDeclaration:usize = 43; 
	pub const RULE_secondaryConstructor:usize = 44; 
	pub const RULE_constructorDelegationCall:usize = 45; 
	pub const RULE_enumClassBody:usize = 46; 
	pub const RULE_enumEntries:usize = 47; 
	pub const RULE_enumEntry:usize = 48; 
	pub const RULE_type:usize = 49; 
	pub const RULE_typeReference:usize = 50; 
	pub const RULE_nullableType:usize = 51; 
	pub const RULE_quest:usize = 52; 
	pub const RULE_userType:usize = 53; 
	pub const RULE_simpleUserType:usize = 54; 
	pub const RULE_typeProjection:usize = 55; 
	pub const RULE_typeProjectionModifiers:usize = 56; 
	pub const RULE_typeProjectionModifier:usize = 57; 
	pub const RULE_functionType:usize = 58; 
	pub const RULE_functionTypeParameters:usize = 59; 
	pub const RULE_parenthesizedType:usize = 60; 
	pub const RULE_receiverType:usize = 61; 
	pub const RULE_parenthesizedUserType:usize = 62; 
	pub const RULE_definitelyNonNullableType:usize = 63; 
	pub const RULE_statements:usize = 64; 
	pub const RULE_statement:usize = 65; 
	pub const RULE_label:usize = 66; 
	pub const RULE_controlStructureBody:usize = 67; 
	pub const RULE_block:usize = 68; 
	pub const RULE_loopStatement:usize = 69; 
	pub const RULE_forStatement:usize = 70; 
	pub const RULE_whileStatement:usize = 71; 
	pub const RULE_doWhileStatement:usize = 72; 
	pub const RULE_assignment:usize = 73; 
	pub const RULE_semi:usize = 74; 
	pub const RULE_semis:usize = 75; 
	pub const RULE_expression:usize = 76; 
	pub const RULE_disjunction:usize = 77; 
	pub const RULE_conjunction:usize = 78; 
	pub const RULE_equality:usize = 79; 
	pub const RULE_comparison:usize = 80; 
	pub const RULE_genericCallLikeComparison:usize = 81; 
	pub const RULE_infixOperation:usize = 82; 
	pub const RULE_elvisExpression:usize = 83; 
	pub const RULE_elvis:usize = 84; 
	pub const RULE_infixFunctionCall:usize = 85; 
	pub const RULE_rangeExpression:usize = 86; 
	pub const RULE_additiveExpression:usize = 87; 
	pub const RULE_multiplicativeExpression:usize = 88; 
	pub const RULE_asExpression:usize = 89; 
	pub const RULE_prefixUnaryExpression:usize = 90; 
	pub const RULE_unaryPrefix:usize = 91; 
	pub const RULE_postfixUnaryExpression:usize = 92; 
	pub const RULE_postfixUnarySuffix:usize = 93; 
	pub const RULE_directlyAssignableExpression:usize = 94; 
	pub const RULE_parenthesizedDirectlyAssignableExpression:usize = 95; 
	pub const RULE_assignableExpression:usize = 96; 
	pub const RULE_parenthesizedAssignableExpression:usize = 97; 
	pub const RULE_assignableSuffix:usize = 98; 
	pub const RULE_indexingSuffix:usize = 99; 
	pub const RULE_navigationSuffix:usize = 100; 
	pub const RULE_callSuffix:usize = 101; 
	pub const RULE_annotatedLambda:usize = 102; 
	pub const RULE_typeArguments:usize = 103; 
	pub const RULE_valueArguments:usize = 104; 
	pub const RULE_valueArgument:usize = 105; 
	pub const RULE_primaryExpression:usize = 106; 
	pub const RULE_parenthesizedExpression:usize = 107; 
	pub const RULE_collectionLiteral:usize = 108; 
	pub const RULE_literalConstant:usize = 109; 
	pub const RULE_stringLiteral:usize = 110; 
	pub const RULE_lineStringLiteral:usize = 111; 
	pub const RULE_multiLineStringLiteral:usize = 112; 
	pub const RULE_lineStringContent:usize = 113; 
	pub const RULE_lineStringExpression:usize = 114; 
	pub const RULE_multiLineStringContent:usize = 115; 
	pub const RULE_multiLineStringExpression:usize = 116; 
	pub const RULE_lambdaLiteral:usize = 117; 
	pub const RULE_lambdaParameters:usize = 118; 
	pub const RULE_lambdaParameter:usize = 119; 
	pub const RULE_anonymousFunction:usize = 120; 
	pub const RULE_functionLiteral:usize = 121; 
	pub const RULE_objectLiteral:usize = 122; 
	pub const RULE_thisExpression:usize = 123; 
	pub const RULE_superExpression:usize = 124; 
	pub const RULE_ifExpression:usize = 125; 
	pub const RULE_whenSubject:usize = 126; 
	pub const RULE_whenExpression:usize = 127; 
	pub const RULE_whenEntry:usize = 128; 
	pub const RULE_whenCondition:usize = 129; 
	pub const RULE_rangeTest:usize = 130; 
	pub const RULE_typeTest:usize = 131; 
	pub const RULE_tryExpression:usize = 132; 
	pub const RULE_catchBlock:usize = 133; 
	pub const RULE_finallyBlock:usize = 134; 
	pub const RULE_jumpExpression:usize = 135; 
	pub const RULE_callableReference:usize = 136; 
	pub const RULE_assignmentAndOperator:usize = 137; 
	pub const RULE_equalityOperator:usize = 138; 
	pub const RULE_comparisonOperator:usize = 139; 
	pub const RULE_inOperator:usize = 140; 
	pub const RULE_isOperator:usize = 141; 
	pub const RULE_additiveOperator:usize = 142; 
	pub const RULE_multiplicativeOperator:usize = 143; 
	pub const RULE_asOperator:usize = 144; 
	pub const RULE_prefixUnaryOperator:usize = 145; 
	pub const RULE_postfixUnaryOperator:usize = 146; 
	pub const RULE_excl:usize = 147; 
	pub const RULE_memberAccessOperator:usize = 148; 
	pub const RULE_safeNav:usize = 149; 
	pub const RULE_modifiers:usize = 150; 
	pub const RULE_parameterModifiers:usize = 151; 
	pub const RULE_modifier:usize = 152; 
	pub const RULE_typeModifiers:usize = 153; 
	pub const RULE_typeModifier:usize = 154; 
	pub const RULE_classModifier:usize = 155; 
	pub const RULE_memberModifier:usize = 156; 
	pub const RULE_visibilityModifier:usize = 157; 
	pub const RULE_varianceModifier:usize = 158; 
	pub const RULE_typeParameterModifiers:usize = 159; 
	pub const RULE_typeParameterModifier:usize = 160; 
	pub const RULE_functionModifier:usize = 161; 
	pub const RULE_propertyModifier:usize = 162; 
	pub const RULE_inheritanceModifier:usize = 163; 
	pub const RULE_parameterModifier:usize = 164; 
	pub const RULE_reificationModifier:usize = 165; 
	pub const RULE_platformModifier:usize = 166; 
	pub const RULE_annotation:usize = 167; 
	pub const RULE_singleAnnotation:usize = 168; 
	pub const RULE_multiAnnotation:usize = 169; 
	pub const RULE_annotationUseSiteTarget:usize = 170; 
	pub const RULE_unescapedAnnotation:usize = 171; 
	pub const RULE_simpleIdentifier:usize = 172; 
	pub const RULE_identifier:usize = 173;
	pub const ruleNames: [&'static str; 174] =  [
		"kotlinFile", "script", "shebangLine", "fileAnnotation", "packageHeader", 
		"importList", "importHeader", "importAlias", "topLevelObject", "typeAlias", 
		"declaration", "classDeclaration", "primaryConstructor", "classBody", 
		"classParameters", "classParameter", "delegationSpecifiers", "delegationSpecifier", 
		"constructorInvocation", "annotatedDelegationSpecifier", "explicitDelegation", 
		"typeParameters", "typeParameter", "typeConstraints", "typeConstraint", 
		"classMemberDeclarations", "classMemberDeclaration", "anonymousInitializer", 
		"companionObject", "functionValueParameters", "functionValueParameter", 
		"functionDeclaration", "functionBody", "variableDeclaration", "multiVariableDeclaration", 
		"propertyDeclaration", "propertyDelegate", "getter", "setter", "parametersWithOptionalType", 
		"functionValueParameterWithOptionalType", "parameterWithOptionalType", 
		"parameter", "objectDeclaration", "secondaryConstructor", "constructorDelegationCall", 
		"enumClassBody", "enumEntries", "enumEntry", "type", "typeReference", 
		"nullableType", "quest", "userType", "simpleUserType", "typeProjection", 
		"typeProjectionModifiers", "typeProjectionModifier", "functionType", "functionTypeParameters", 
		"parenthesizedType", "receiverType", "parenthesizedUserType", "definitelyNonNullableType", 
		"statements", "statement", "label", "controlStructureBody", "block", "loopStatement", 
		"forStatement", "whileStatement", "doWhileStatement", "assignment", "semi", 
		"semis", "expression", "disjunction", "conjunction", "equality", "comparison", 
		"genericCallLikeComparison", "infixOperation", "elvisExpression", "elvis", 
		"infixFunctionCall", "rangeExpression", "additiveExpression", "multiplicativeExpression", 
		"asExpression", "prefixUnaryExpression", "unaryPrefix", "postfixUnaryExpression", 
		"postfixUnarySuffix", "directlyAssignableExpression", "parenthesizedDirectlyAssignableExpression", 
		"assignableExpression", "parenthesizedAssignableExpression", "assignableSuffix", 
		"indexingSuffix", "navigationSuffix", "callSuffix", "annotatedLambda", 
		"typeArguments", "valueArguments", "valueArgument", "primaryExpression", 
		"parenthesizedExpression", "collectionLiteral", "literalConstant", "stringLiteral", 
		"lineStringLiteral", "multiLineStringLiteral", "lineStringContent", "lineStringExpression", 
		"multiLineStringContent", "multiLineStringExpression", "lambdaLiteral", 
		"lambdaParameters", "lambdaParameter", "anonymousFunction", "functionLiteral", 
		"objectLiteral", "thisExpression", "superExpression", "ifExpression", 
		"whenSubject", "whenExpression", "whenEntry", "whenCondition", "rangeTest", 
		"typeTest", "tryExpression", "catchBlock", "finallyBlock", "jumpExpression", 
		"callableReference", "assignmentAndOperator", "equalityOperator", "comparisonOperator", 
		"inOperator", "isOperator", "additiveOperator", "multiplicativeOperator", 
		"asOperator", "prefixUnaryOperator", "postfixUnaryOperator", "excl", "memberAccessOperator", 
		"safeNav", "modifiers", "parameterModifiers", "modifier", "typeModifiers", 
		"typeModifier", "classModifier", "memberModifier", "visibilityModifier", 
		"varianceModifier", "typeParameterModifiers", "typeParameterModifier", 
		"functionModifier", "propertyModifier", "inheritanceModifier", "parameterModifier", 
		"reificationModifier", "platformModifier", "annotation", "singleAnnotation", 
		"multiAnnotation", "annotationUseSiteTarget", "unescapedAnnotation", "simpleIdentifier", 
		"identifier"
	];


	pub const _LITERAL_NAMES: [Option<&'static str>;153] = [
		None, None, None, None, None, None, Some("'...'"), Some("'.'"), Some("','"), 
		Some("'('"), Some("')'"), Some("'['"), Some("']'"), Some("'{'"), Some("'}'"), 
		Some("'*'"), Some("'%'"), Some("'/'"), Some("'+'"), Some("'-'"), Some("'++'"), 
		Some("'--'"), Some("'&&'"), Some("'||'"), None, Some("'!'"), Some("':'"), 
		Some("';'"), Some("'='"), Some("'+='"), Some("'-='"), Some("'*='"), Some("'/='"), 
		Some("'%='"), Some("'->'"), Some("'=>'"), Some("'..'"), Some("'..<'"), 
		Some("'::'"), Some("';;'"), Some("'#'"), Some("'@'"), None, None, None, 
		None, Some("'?'"), Some("'<'"), Some("'>'"), Some("'<='"), Some("'>='"), 
		Some("'!='"), Some("'!=='"), Some("'as?'"), Some("'=='"), Some("'==='"), 
		Some("'''"), Some("'&'"), None, None, None, None, None, Some("'file'"), 
		Some("'field'"), Some("'property'"), Some("'get'"), Some("'set'"), Some("'receiver'"), 
		Some("'param'"), Some("'setparam'"), Some("'delegate'"), Some("'package'"), 
		Some("'import'"), Some("'class'"), Some("'interface'"), Some("'fun'"), 
		Some("'object'"), Some("'val'"), Some("'var'"), Some("'typealias'"), Some("'constructor'"), 
		Some("'by'"), Some("'companion'"), Some("'init'"), Some("'this'"), Some("'super'"), 
		Some("'typeof'"), Some("'where'"), Some("'if'"), Some("'else'"), Some("'when'"), 
		Some("'try'"), Some("'catch'"), Some("'finally'"), Some("'for'"), Some("'do'"), 
		Some("'while'"), Some("'throw'"), Some("'return'"), Some("'continue'"), 
		Some("'break'"), Some("'as'"), Some("'is'"), Some("'in'"), None, None, 
		Some("'out'"), Some("'dynamic'"), Some("'public'"), Some("'private'"), 
		Some("'protected'"), Some("'internal'"), Some("'enum'"), Some("'sealed'"), 
		Some("'annotation'"), Some("'data'"), Some("'inner'"), Some("'value'"), 
		Some("'tailrec'"), Some("'operator'"), Some("'inline'"), Some("'infix'"), 
		Some("'external'"), Some("'suspend'"), Some("'override'"), Some("'abstract'"), 
		Some("'final'"), Some("'open'"), Some("'const'"), Some("'lateinit'"), 
		Some("'vararg'"), Some("'noinline'"), Some("'crossinline'"), Some("'reified'"), 
		Some("'expect'"), Some("'actual'"), None, None, None, None, None, None, 
		None, None, None, Some("'null'"), None, None, None, None, None, Some("'\"\"\"'")
	];
	pub const _SYMBOLIC_NAMES: [Option<&'static str>;174]  = [
		None, Some("ShebangLine"), Some("DelimitedComment"), Some("LineComment"), 
		Some("WS"), Some("NL"), Some("RESERVED"), Some("DOT"), Some("COMMA"), 
		Some("LPAREN"), Some("RPAREN"), Some("LSQUARE"), Some("RSQUARE"), Some("LCURL"), 
		Some("RCURL"), Some("MULT"), Some("MOD"), Some("DIV"), Some("ADD"), Some("SUB"), 
		Some("INCR"), Some("DECR"), Some("CONJ"), Some("DISJ"), Some("EXCL_WS"), 
		Some("EXCL_NO_WS"), Some("COLON"), Some("SEMICOLON"), Some("ASSIGNMENT"), 
		Some("ADD_ASSIGNMENT"), Some("SUB_ASSIGNMENT"), Some("MULT_ASSIGNMENT"), 
		Some("DIV_ASSIGNMENT"), Some("MOD_ASSIGNMENT"), Some("ARROW"), Some("DOUBLE_ARROW"), 
		Some("RANGE"), Some("RANGE_UNTIL"), Some("COLONCOLON"), Some("DOUBLE_SEMICOLON"), 
		Some("HASH"), Some("AT_NO_WS"), Some("AT_POST_WS"), Some("AT_PRE_WS"), 
		Some("AT_BOTH_WS"), Some("QUEST_WS"), Some("QUEST_NO_WS"), Some("LANGLE"), 
		Some("RANGLE"), Some("LE"), Some("GE"), Some("EXCL_EQ"), Some("EXCL_EQEQ"), 
		Some("AS_SAFE"), Some("EQEQ"), Some("EQEQEQ"), Some("SINGLE_QUOTE"), Some("AMP"), 
		Some("RETURN_AT"), Some("CONTINUE_AT"), Some("BREAK_AT"), Some("THIS_AT"), 
		Some("SUPER_AT"), Some("FILE"), Some("FIELD"), Some("PROPERTY"), Some("GET"), 
		Some("SET"), Some("RECEIVER"), Some("PARAM"), Some("SETPARAM"), Some("DELEGATE"), 
		Some("PACKAGE"), Some("IMPORT"), Some("CLASS"), Some("INTERFACE"), Some("FUN"), 
		Some("OBJECT"), Some("VAL"), Some("VAR"), Some("TYPE_ALIAS"), Some("CONSTRUCTOR"), 
		Some("BY"), Some("COMPANION"), Some("INIT"), Some("THIS"), Some("SUPER"), 
		Some("TYPEOF"), Some("WHERE"), Some("IF"), Some("ELSE"), Some("WHEN"), 
		Some("TRY"), Some("CATCH"), Some("FINALLY"), Some("FOR"), Some("DO"), 
		Some("WHILE"), Some("THROW"), Some("RETURN"), Some("CONTINUE"), Some("BREAK"), 
		Some("AS"), Some("IS"), Some("IN"), Some("NOT_IS"), Some("NOT_IN"), Some("OUT"), 
		Some("DYNAMIC"), Some("PUBLIC"), Some("PRIVATE"), Some("PROTECTED"), Some("INTERNAL"), 
		Some("ENUM"), Some("SEALED"), Some("ANNOTATION"), Some("DATA"), Some("INNER"), 
		Some("VALUE"), Some("TAILREC"), Some("OPERATOR"), Some("INLINE"), Some("INFIX"), 
		Some("EXTERNAL"), Some("SUSPEND"), Some("OVERRIDE"), Some("ABSTRACT"), 
		Some("FINAL"), Some("OPEN"), Some("CONST"), Some("LATEINIT"), Some("VARARG"), 
		Some("NOINLINE"), Some("CROSSINLINE"), Some("REIFIED"), Some("EXPECT"), 
		Some("ACTUAL"), Some("RealLiteral"), Some("FloatLiteral"), Some("DoubleLiteral"), 
		Some("IntegerLiteral"), Some("HexLiteral"), Some("BinLiteral"), Some("UnsignedLiteral"), 
		Some("LongLiteral"), Some("BooleanLiteral"), Some("NullLiteral"), Some("CharacterLiteral"), 
		Some("Identifier"), Some("IdentifierOrSoftKey"), Some("FieldIdentifier"), 
		Some("QUOTE_OPEN"), Some("TRIPLE_QUOTE_OPEN"), Some("UNICODE_CLASS_LL"), 
		Some("UNICODE_CLASS_LM"), Some("UNICODE_CLASS_LO"), Some("UNICODE_CLASS_LT"), 
		Some("UNICODE_CLASS_LU"), Some("UNICODE_CLASS_ND"), Some("UNICODE_CLASS_NL"), 
		Some("QUOTE_CLOSE"), Some("LineStrRef"), Some("LineStrText"), Some("LineStrEscapedChar"), 
		Some("LineStrExprStart"), Some("TRIPLE_QUOTE_CLOSE"), Some("MultiLineStringQuote"), 
		Some("MultiLineStrRef"), Some("MultiLineStrText"), Some("MultiLineStrExprStart"), 
		Some("Inside_Comment"), Some("Inside_WS"), Some("Inside_NL"), Some("ErrorCharacter")
	];
	lazy_static!{
	    static ref _shared_context_cache: Arc<PredictionContextCache> = Arc::new(PredictionContextCache::new());
		static ref VOCABULARY: Box<dyn Vocabulary> = Box::new(VocabularyImpl::new(_LITERAL_NAMES.iter(), _SYMBOLIC_NAMES.iter(), None));
	}


type BaseParserType<'input, I> =
	BaseParser<'input,KotlinParserExt, I, KotlinParserContextType , dyn KotlinParserListener<'input> + 'input >;

type TokenType<'input> = <LocalTokenFactory<'input> as TokenFactory<'input>>::Tok;
pub type LocalTokenFactory<'input> = CommonTokenFactory;

pub type KotlinParserTreeWalker<'input,'a> =
	ParseTreeWalker<'input, 'a, KotlinParserContextType , dyn KotlinParserListener<'input> + 'a>;

/// Parser for KotlinParser grammar
pub struct KotlinParser<'input,I,H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	base:BaseParserType<'input,I>,
	interpreter:Arc<ParserATNSimulator>,
	_shared_context_cache: Box<PredictionContextCache>,
    pub err_handler: H,
}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn get_serialized_atn() -> &'static str { _serializedATN }

    pub fn set_error_strategy(&mut self, strategy: H) {
        self.err_handler = strategy
    }

    pub fn with_strategy(input: I, strategy: H) -> Self {
		antlr_rust::recognizer::check_version("0","2");
		let interpreter = Arc::new(ParserATNSimulator::new(
			_ATN.clone(),
			_decision_to_DFA.clone(),
			_shared_context_cache.clone(),
		));
		Self {
			base: BaseParser::new_base_parser(
				input,
				Arc::clone(&interpreter),
				KotlinParserExt{
				}
			),
			interpreter,
            _shared_context_cache: Box::new(PredictionContextCache::new()),
            err_handler: strategy,
        }
    }

}

type DynStrategy<'input,I> = Box<dyn ErrorStrategy<'input,BaseParserType<'input,I>> + 'input>;

impl<'input, I> KotlinParser<'input, I, DynStrategy<'input,I>>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
{
    pub fn with_dyn_strategy(input: I) -> Self{
    	Self::with_strategy(input,Box::new(DefaultErrorStrategy::new()))
    }
}

impl<'input, I> KotlinParser<'input, I, DefaultErrorStrategy<'input,KotlinParserContextType>>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
{
    pub fn new(input: I) -> Self{
    	Self::with_strategy(input,DefaultErrorStrategy::new())
    }
}

/// Trait for monomorphized trait object that corresponds to the nodes of parse tree generated for KotlinParser
pub trait KotlinParserContext<'input>:
	for<'x> Listenable<dyn KotlinParserListener<'input> + 'x > + 
	for<'x> Visitable<dyn KotlinParserVisitor<'input> + 'x > + 
	ParserRuleContext<'input, TF=LocalTokenFactory<'input>, Ctx=KotlinParserContextType>
{}

impl<'input, 'x, T> VisitableDyn<T> for dyn KotlinParserContext<'input> + 'input
where
    T: KotlinParserVisitor<'input> + 'x,
{
    fn accept_dyn(&self, visitor: &mut T) {
        self.accept(visitor as &mut (dyn KotlinParserVisitor<'input> + 'x))
    }
}

impl<'input> KotlinParserContext<'input> for TerminalNode<'input,KotlinParserContextType> {}
impl<'input> KotlinParserContext<'input> for ErrorNode<'input,KotlinParserContextType> {}

#[antlr_rust::impl_tid]
impl<'input> antlr_rust::TidAble<'input> for dyn KotlinParserContext<'input> + 'input{}

#[antlr_rust::impl_tid]
impl<'input> antlr_rust::TidAble<'input> for dyn KotlinParserListener<'input> + 'input{}

pub struct KotlinParserContextType;
antlr_rust::type_id!{KotlinParserContextType}

impl<'input> ParserNodeType<'input> for KotlinParserContextType{
	type TF = LocalTokenFactory<'input>;
	type Type = dyn KotlinParserContext<'input> + 'input;
}

impl<'input, I, H> Deref for KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
    type Target = BaseParserType<'input,I>;

    fn deref(&self) -> &Self::Target {
        &self.base
    }
}

impl<'input, I, H> DerefMut for KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.base
    }
}

pub struct KotlinParserExt{
}

impl KotlinParserExt{
}


impl<'input> TokenAware<'input> for KotlinParserExt{
	type TF = LocalTokenFactory<'input>;
}

impl<'input,I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>> ParserRecog<'input, BaseParserType<'input,I>> for KotlinParserExt{}

impl<'input,I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>> Actions<'input, BaseParserType<'input,I>> for KotlinParserExt{
	fn get_grammar_file_name(&self) -> & str{ "KotlinParser.g4"}

   	fn get_rule_names(&self) -> &[& str] {&ruleNames}

   	fn get_vocabulary(&self) -> &dyn Vocabulary { &**VOCABULARY }
}
//------------------- kotlinFile ----------------
pub type KotlinFileContextAll<'input> = KotlinFileContext<'input>;


pub type KotlinFileContext<'input> = BaseParserRuleContext<'input,KotlinFileContextExt<'input>>;

#[derive(Clone)]
pub struct KotlinFileContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for KotlinFileContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for KotlinFileContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_kotlinFile(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_kotlinFile(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for KotlinFileContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_kotlinFile(self);
	}
}

impl<'input> CustomRuleContext<'input> for KotlinFileContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_kotlinFile }
	//fn type_rule_index() -> usize where Self: Sized { RULE_kotlinFile }
}
antlr_rust::type_id!{KotlinFileContextExt<'a>}

impl<'input> KotlinFileContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<KotlinFileContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,KotlinFileContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait KotlinFileContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<KotlinFileContextExt<'input>>{

fn packageHeader(&self) -> Option<Rc<PackageHeaderContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn importList(&self) -> Option<Rc<ImportListContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token EOF
/// Returns `None` if there is no child corresponding to token EOF
fn EOF(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(EOF, 0)
}
fn shebangLine(&self) -> Option<Rc<ShebangLineContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}
fn fileAnnotation_all(&self) ->  Vec<Rc<FileAnnotationContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn fileAnnotation(&self, i: usize) -> Option<Rc<FileAnnotationContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn topLevelObject_all(&self) ->  Vec<Rc<TopLevelObjectContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn topLevelObject(&self, i: usize) -> Option<Rc<TopLevelObjectContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> KotlinFileContextAttrs<'input> for KotlinFileContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn kotlinFile(&mut self,)
	-> Result<Rc<KotlinFileContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = KotlinFileContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 0, RULE_kotlinFile);
        let mut _localctx: Rc<KotlinFileContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(349);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==ShebangLine {
				{
				/*InvokeRule shebangLine*/
				recog.base.set_state(348);
				recog.shebangLine()?;

				}
			}

			recog.base.set_state(354);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(351);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(356);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(360);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(2,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					/*InvokeRule fileAnnotation*/
					recog.base.set_state(357);
					recog.fileAnnotation()?;

					}
					} 
				}
				recog.base.set_state(362);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(2,&mut recog.base)?;
			}
			/*InvokeRule packageHeader*/
			recog.base.set_state(363);
			recog.packageHeader()?;

			/*InvokeRule importList*/
			recog.base.set_state(364);
			recog.importList()?;

			recog.base.set_state(368);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==AT_NO_WS || _la==AT_PRE_WS || ((((_la - 74)) & !0x3f) == 0 && ((1usize << (_la - 74)) & ((1usize << (CLASS - 74)) | (1usize << (INTERFACE - 74)) | (1usize << (FUN - 74)) | (1usize << (OBJECT - 74)) | (1usize << (VAL - 74)) | (1usize << (VAR - 74)) | (1usize << (TYPE_ALIAS - 74)) | (1usize << (PUBLIC - 74)) | (1usize << (PRIVATE - 74)) | (1usize << (PROTECTED - 74)) | (1usize << (INTERNAL - 74)) | (1usize << (ENUM - 74)) | (1usize << (SEALED - 74)) | (1usize << (ANNOTATION - 74)) | (1usize << (DATA - 74)) | (1usize << (INNER - 74)) | (1usize << (VALUE - 74)) | (1usize << (TAILREC - 74)) | (1usize << (OPERATOR - 74)) | (1usize << (INLINE - 74)) | (1usize << (INFIX - 74)) | (1usize << (EXTERNAL - 74)) | (1usize << (SUSPEND - 74)) | (1usize << (OVERRIDE - 74)) | (1usize << (ABSTRACT - 74)) | (1usize << (FINAL - 74)) | (1usize << (OPEN - 74)) | (1usize << (CONST - 74)) | (1usize << (LATEINIT - 74)) | (1usize << (VARARG - 74)) | (1usize << (NOINLINE - 74)) | (1usize << (CROSSINLINE - 74)) | (1usize << (EXPECT - 74)) | (1usize << (ACTUAL - 74)))) != 0) {
				{
				{
				/*InvokeRule topLevelObject*/
				recog.base.set_state(365);
				recog.topLevelObject()?;

				}
				}
				recog.base.set_state(370);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(371);
			recog.base.match_token(EOF,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- script ----------------
pub type ScriptContextAll<'input> = ScriptContext<'input>;


pub type ScriptContext<'input> = BaseParserRuleContext<'input,ScriptContextExt<'input>>;

#[derive(Clone)]
pub struct ScriptContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for ScriptContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for ScriptContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_script(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_script(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for ScriptContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_script(self);
	}
}

impl<'input> CustomRuleContext<'input> for ScriptContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_script }
	//fn type_rule_index() -> usize where Self: Sized { RULE_script }
}
antlr_rust::type_id!{ScriptContextExt<'a>}

impl<'input> ScriptContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ScriptContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ScriptContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ScriptContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<ScriptContextExt<'input>>{

fn packageHeader(&self) -> Option<Rc<PackageHeaderContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn importList(&self) -> Option<Rc<ImportListContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token EOF
/// Returns `None` if there is no child corresponding to token EOF
fn EOF(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(EOF, 0)
}
fn shebangLine(&self) -> Option<Rc<ShebangLineContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}
fn fileAnnotation_all(&self) ->  Vec<Rc<FileAnnotationContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn fileAnnotation(&self, i: usize) -> Option<Rc<FileAnnotationContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn statement_all(&self) ->  Vec<Rc<StatementContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn statement(&self, i: usize) -> Option<Rc<StatementContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn semi_all(&self) ->  Vec<Rc<SemiContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn semi(&self, i: usize) -> Option<Rc<SemiContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> ScriptContextAttrs<'input> for ScriptContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn script(&mut self,)
	-> Result<Rc<ScriptContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ScriptContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 2, RULE_script);
        let mut _localctx: Rc<ScriptContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(374);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==ShebangLine {
				{
				/*InvokeRule shebangLine*/
				recog.base.set_state(373);
				recog.shebangLine()?;

				}
			}

			recog.base.set_state(379);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(5,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					recog.base.set_state(376);
					recog.base.match_token(NL,&mut recog.err_handler)?;

					}
					} 
				}
				recog.base.set_state(381);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(5,&mut recog.base)?;
			}
			recog.base.set_state(385);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(6,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					/*InvokeRule fileAnnotation*/
					recog.base.set_state(382);
					recog.fileAnnotation()?;

					}
					} 
				}
				recog.base.set_state(387);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(6,&mut recog.base)?;
			}
			/*InvokeRule packageHeader*/
			recog.base.set_state(388);
			recog.packageHeader()?;

			/*InvokeRule importList*/
			recog.base.set_state(389);
			recog.importList()?;

			recog.base.set_state(395);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << NL) | (1usize << LPAREN) | (1usize << LSQUARE) | (1usize << LCURL) | (1usize << ADD) | (1usize << SUB) | (1usize << INCR) | (1usize << DECR) | (1usize << EXCL_WS) | (1usize << EXCL_NO_WS) | (1usize << COLONCOLON) | (1usize << AT_NO_WS) | (1usize << AT_PRE_WS) | (1usize << RETURN_AT) | (1usize << CONTINUE_AT) | (1usize << BREAK_AT) | (1usize << THIS_AT) | (1usize << SUPER_AT) | (1usize << FILE))) != 0) || ((((_la - 64)) & !0x3f) == 0 && ((1usize << (_la - 64)) & ((1usize << (FIELD - 64)) | (1usize << (PROPERTY - 64)) | (1usize << (GET - 64)) | (1usize << (SET - 64)) | (1usize << (RECEIVER - 64)) | (1usize << (PARAM - 64)) | (1usize << (SETPARAM - 64)) | (1usize << (DELEGATE - 64)) | (1usize << (IMPORT - 64)) | (1usize << (CLASS - 64)) | (1usize << (INTERFACE - 64)) | (1usize << (FUN - 64)) | (1usize << (OBJECT - 64)) | (1usize << (VAL - 64)) | (1usize << (VAR - 64)) | (1usize << (TYPE_ALIAS - 64)) | (1usize << (CONSTRUCTOR - 64)) | (1usize << (BY - 64)) | (1usize << (COMPANION - 64)) | (1usize << (INIT - 64)) | (1usize << (THIS - 64)) | (1usize << (SUPER - 64)) | (1usize << (WHERE - 64)) | (1usize << (IF - 64)) | (1usize << (WHEN - 64)) | (1usize << (TRY - 64)) | (1usize << (CATCH - 64)) | (1usize << (FINALLY - 64)) | (1usize << (FOR - 64)) | (1usize << (DO - 64)) | (1usize << (WHILE - 64)) | (1usize << (THROW - 64)) | (1usize << (RETURN - 64)) | (1usize << (CONTINUE - 64)) | (1usize << (BREAK - 64)) | (1usize << (OUT - 64)) | (1usize << (DYNAMIC - 64)) | (1usize << (PUBLIC - 64)) | (1usize << (PRIVATE - 64)) | (1usize << (PROTECTED - 64)) | (1usize << (INTERNAL - 64)) | (1usize << (ENUM - 64)) | (1usize << (SEALED - 64)) | (1usize << (ANNOTATION - 64)) | (1usize << (DATA - 64)) | (1usize << (INNER - 64)) | (1usize << (VALUE - 64)) | (1usize << (TAILREC - 64)) | (1usize << (OPERATOR - 64)) | (1usize << (INLINE - 64)) | (1usize << (INFIX - 64)) | (1usize << (EXTERNAL - 64)) | (1usize << (SUSPEND - 64)) | (1usize << (OVERRIDE - 64)) | (1usize << (ABSTRACT - 64)) | (1usize << (FINAL - 64)))) != 0) || ((((_la - 128)) & !0x3f) == 0 && ((1usize << (_la - 128)) & ((1usize << (OPEN - 128)) | (1usize << (CONST - 128)) | (1usize << (LATEINIT - 128)) | (1usize << (VARARG - 128)) | (1usize << (NOINLINE - 128)) | (1usize << (CROSSINLINE - 128)) | (1usize << (REIFIED - 128)) | (1usize << (EXPECT - 128)) | (1usize << (ACTUAL - 128)) | (1usize << (RealLiteral - 128)) | (1usize << (IntegerLiteral - 128)) | (1usize << (HexLiteral - 128)) | (1usize << (BinLiteral - 128)) | (1usize << (UnsignedLiteral - 128)) | (1usize << (LongLiteral - 128)) | (1usize << (BooleanLiteral - 128)) | (1usize << (NullLiteral - 128)) | (1usize << (CharacterLiteral - 128)) | (1usize << (Identifier - 128)) | (1usize << (QUOTE_OPEN - 128)) | (1usize << (TRIPLE_QUOTE_OPEN - 128)))) != 0) {
				{
				{
				/*InvokeRule statement*/
				recog.base.set_state(390);
				recog.statement()?;

				/*InvokeRule semi*/
				recog.base.set_state(391);
				recog.semi()?;

				}
				}
				recog.base.set_state(397);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(398);
			recog.base.match_token(EOF,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- shebangLine ----------------
pub type ShebangLineContextAll<'input> = ShebangLineContext<'input>;


pub type ShebangLineContext<'input> = BaseParserRuleContext<'input,ShebangLineContextExt<'input>>;

#[derive(Clone)]
pub struct ShebangLineContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for ShebangLineContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for ShebangLineContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_shebangLine(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_shebangLine(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for ShebangLineContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_shebangLine(self);
	}
}

impl<'input> CustomRuleContext<'input> for ShebangLineContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_shebangLine }
	//fn type_rule_index() -> usize where Self: Sized { RULE_shebangLine }
}
antlr_rust::type_id!{ShebangLineContextExt<'a>}

impl<'input> ShebangLineContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ShebangLineContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ShebangLineContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ShebangLineContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<ShebangLineContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token ShebangLine
/// Returns `None` if there is no child corresponding to token ShebangLine
fn ShebangLine(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(ShebangLine, 0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}

}

impl<'input> ShebangLineContextAttrs<'input> for ShebangLineContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn shebangLine(&mut self,)
	-> Result<Rc<ShebangLineContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ShebangLineContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 4, RULE_shebangLine);
        let mut _localctx: Rc<ShebangLineContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(400);
			recog.base.match_token(ShebangLine,&mut recog.err_handler)?;

			recog.base.set_state(402); 
			recog.err_handler.sync(&mut recog.base)?;
			_alt = 1;
			loop {
				match _alt {
				    x if x == 1=>
					{
					{
					recog.base.set_state(401);
					recog.base.match_token(NL,&mut recog.err_handler)?;

					}
					}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
				}
				recog.base.set_state(404); 
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(8,&mut recog.base)?;
				if _alt==2 || _alt==INVALID_ALT { break }
			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- fileAnnotation ----------------
pub type FileAnnotationContextAll<'input> = FileAnnotationContext<'input>;


pub type FileAnnotationContext<'input> = BaseParserRuleContext<'input,FileAnnotationContextExt<'input>>;

#[derive(Clone)]
pub struct FileAnnotationContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for FileAnnotationContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for FileAnnotationContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_fileAnnotation(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_fileAnnotation(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for FileAnnotationContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_fileAnnotation(self);
	}
}

impl<'input> CustomRuleContext<'input> for FileAnnotationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_fileAnnotation }
	//fn type_rule_index() -> usize where Self: Sized { RULE_fileAnnotation }
}
antlr_rust::type_id!{FileAnnotationContextExt<'a>}

impl<'input> FileAnnotationContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<FileAnnotationContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,FileAnnotationContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait FileAnnotationContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<FileAnnotationContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token FILE
/// Returns `None` if there is no child corresponding to token FILE
fn FILE(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(FILE, 0)
}
/// Retrieves first TerminalNode corresponding to token COLON
/// Returns `None` if there is no child corresponding to token COLON
fn COLON(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(COLON, 0)
}
/// Retrieves first TerminalNode corresponding to token AT_NO_WS
/// Returns `None` if there is no child corresponding to token AT_NO_WS
fn AT_NO_WS(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(AT_NO_WS, 0)
}
/// Retrieves first TerminalNode corresponding to token AT_PRE_WS
/// Returns `None` if there is no child corresponding to token AT_PRE_WS
fn AT_PRE_WS(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(AT_PRE_WS, 0)
}
/// Retrieves first TerminalNode corresponding to token LSQUARE
/// Returns `None` if there is no child corresponding to token LSQUARE
fn LSQUARE(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(LSQUARE, 0)
}
/// Retrieves first TerminalNode corresponding to token RSQUARE
/// Returns `None` if there is no child corresponding to token RSQUARE
fn RSQUARE(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(RSQUARE, 0)
}
fn unescapedAnnotation_all(&self) ->  Vec<Rc<UnescapedAnnotationContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn unescapedAnnotation(&self, i: usize) -> Option<Rc<UnescapedAnnotationContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}

}

impl<'input> FileAnnotationContextAttrs<'input> for FileAnnotationContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn fileAnnotation(&mut self,)
	-> Result<Rc<FileAnnotationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = FileAnnotationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 6, RULE_fileAnnotation);
        let mut _localctx: Rc<FileAnnotationContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(406);
			_la = recog.base.input.la(1);
			if { !(_la==AT_NO_WS || _la==AT_PRE_WS) } {
				recog.err_handler.recover_inline(&mut recog.base)?;

			}
			else {
				if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
				recog.err_handler.report_match(&mut recog.base);
				recog.base.consume(&mut recog.err_handler);
			}
			recog.base.set_state(407);
			recog.base.match_token(FILE,&mut recog.err_handler)?;

			recog.base.set_state(411);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(408);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(413);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(414);
			recog.base.match_token(COLON,&mut recog.err_handler)?;

			recog.base.set_state(418);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(415);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(420);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(430);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 LSQUARE 
				=> {
					{
					recog.base.set_state(421);
					recog.base.match_token(LSQUARE,&mut recog.err_handler)?;

					recog.base.set_state(423); 
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					loop {
						{
						{
						/*InvokeRule unescapedAnnotation*/
						recog.base.set_state(422);
						recog.unescapedAnnotation()?;

						}
						}
						recog.base.set_state(425); 
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
						if !(((((_la - 63)) & !0x3f) == 0 && ((1usize << (_la - 63)) & ((1usize << (FILE - 63)) | (1usize << (FIELD - 63)) | (1usize << (PROPERTY - 63)) | (1usize << (GET - 63)) | (1usize << (SET - 63)) | (1usize << (RECEIVER - 63)) | (1usize << (PARAM - 63)) | (1usize << (SETPARAM - 63)) | (1usize << (DELEGATE - 63)) | (1usize << (IMPORT - 63)) | (1usize << (CONSTRUCTOR - 63)) | (1usize << (BY - 63)) | (1usize << (COMPANION - 63)) | (1usize << (INIT - 63)) | (1usize << (WHERE - 63)) | (1usize << (CATCH - 63)) | (1usize << (FINALLY - 63)) | (1usize << (OUT - 63)) | (1usize << (DYNAMIC - 63)) | (1usize << (PUBLIC - 63)) | (1usize << (PRIVATE - 63)) | (1usize << (PROTECTED - 63)) | (1usize << (INTERNAL - 63)) | (1usize << (ENUM - 63)) | (1usize << (SEALED - 63)) | (1usize << (ANNOTATION - 63)) | (1usize << (DATA - 63)) | (1usize << (INNER - 63)) | (1usize << (VALUE - 63)) | (1usize << (TAILREC - 63)) | (1usize << (OPERATOR - 63)) | (1usize << (INLINE - 63)) | (1usize << (INFIX - 63)) | (1usize << (EXTERNAL - 63)) | (1usize << (SUSPEND - 63)) | (1usize << (OVERRIDE - 63)) | (1usize << (ABSTRACT - 63)))) != 0) || ((((_la - 127)) & !0x3f) == 0 && ((1usize << (_la - 127)) & ((1usize << (FINAL - 127)) | (1usize << (OPEN - 127)) | (1usize << (CONST - 127)) | (1usize << (LATEINIT - 127)) | (1usize << (VARARG - 127)) | (1usize << (NOINLINE - 127)) | (1usize << (CROSSINLINE - 127)) | (1usize << (REIFIED - 127)) | (1usize << (EXPECT - 127)) | (1usize << (ACTUAL - 127)) | (1usize << (Identifier - 127)))) != 0)) {break}
					}
					recog.base.set_state(427);
					recog.base.match_token(RSQUARE,&mut recog.err_handler)?;

					}
				}

			 FILE | FIELD | PROPERTY | GET | SET | RECEIVER | PARAM | SETPARAM | DELEGATE |
			 IMPORT | CONSTRUCTOR | BY | COMPANION | INIT | WHERE | CATCH | FINALLY |
			 OUT | DYNAMIC | PUBLIC | PRIVATE | PROTECTED | INTERNAL | ENUM | SEALED |
			 ANNOTATION | DATA | INNER | VALUE | TAILREC | OPERATOR | INLINE | INFIX |
			 EXTERNAL | SUSPEND | OVERRIDE | ABSTRACT | FINAL | OPEN | CONST | LATEINIT |
			 VARARG | NOINLINE | CROSSINLINE | REIFIED | EXPECT | ACTUAL | Identifier 
				=> {
					{
					/*InvokeRule unescapedAnnotation*/
					recog.base.set_state(429);
					recog.unescapedAnnotation()?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			recog.base.set_state(435);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(13,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					recog.base.set_state(432);
					recog.base.match_token(NL,&mut recog.err_handler)?;

					}
					} 
				}
				recog.base.set_state(437);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(13,&mut recog.base)?;
			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- packageHeader ----------------
pub type PackageHeaderContextAll<'input> = PackageHeaderContext<'input>;


pub type PackageHeaderContext<'input> = BaseParserRuleContext<'input,PackageHeaderContextExt<'input>>;

#[derive(Clone)]
pub struct PackageHeaderContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for PackageHeaderContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for PackageHeaderContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_packageHeader(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_packageHeader(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for PackageHeaderContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_packageHeader(self);
	}
}

impl<'input> CustomRuleContext<'input> for PackageHeaderContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_packageHeader }
	//fn type_rule_index() -> usize where Self: Sized { RULE_packageHeader }
}
antlr_rust::type_id!{PackageHeaderContextExt<'a>}

impl<'input> PackageHeaderContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<PackageHeaderContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,PackageHeaderContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait PackageHeaderContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<PackageHeaderContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token PACKAGE
/// Returns `None` if there is no child corresponding to token PACKAGE
fn PACKAGE(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(PACKAGE, 0)
}
fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn semi(&self) -> Option<Rc<SemiContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> PackageHeaderContextAttrs<'input> for PackageHeaderContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn packageHeader(&mut self,)
	-> Result<Rc<PackageHeaderContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = PackageHeaderContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 8, RULE_packageHeader);
        let mut _localctx: Rc<PackageHeaderContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(443);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==PACKAGE {
				{
				recog.base.set_state(438);
				recog.base.match_token(PACKAGE,&mut recog.err_handler)?;

				/*InvokeRule identifier*/
				recog.base.set_state(439);
				recog.identifier()?;

				recog.base.set_state(441);
				recog.err_handler.sync(&mut recog.base)?;
				match  recog.interpreter.adaptive_predict(14,&mut recog.base)? {
					x if x == 1=>{
						{
						/*InvokeRule semi*/
						recog.base.set_state(440);
						recog.semi()?;

						}
					}

					_ => {}
				}
				}
			}

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- importList ----------------
pub type ImportListContextAll<'input> = ImportListContext<'input>;


pub type ImportListContext<'input> = BaseParserRuleContext<'input,ImportListContextExt<'input>>;

#[derive(Clone)]
pub struct ImportListContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for ImportListContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for ImportListContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_importList(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_importList(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for ImportListContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_importList(self);
	}
}

impl<'input> CustomRuleContext<'input> for ImportListContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_importList }
	//fn type_rule_index() -> usize where Self: Sized { RULE_importList }
}
antlr_rust::type_id!{ImportListContextExt<'a>}

impl<'input> ImportListContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ImportListContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ImportListContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ImportListContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<ImportListContextExt<'input>>{

fn importHeader_all(&self) ->  Vec<Rc<ImportHeaderContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn importHeader(&self, i: usize) -> Option<Rc<ImportHeaderContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> ImportListContextAttrs<'input> for ImportListContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn importList(&mut self,)
	-> Result<Rc<ImportListContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ImportListContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 10, RULE_importList);
        let mut _localctx: Rc<ImportListContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(448);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(16,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					/*InvokeRule importHeader*/
					recog.base.set_state(445);
					recog.importHeader()?;

					}
					} 
				}
				recog.base.set_state(450);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(16,&mut recog.base)?;
			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- importHeader ----------------
pub type ImportHeaderContextAll<'input> = ImportHeaderContext<'input>;


pub type ImportHeaderContext<'input> = BaseParserRuleContext<'input,ImportHeaderContextExt<'input>>;

#[derive(Clone)]
pub struct ImportHeaderContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for ImportHeaderContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for ImportHeaderContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_importHeader(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_importHeader(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for ImportHeaderContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_importHeader(self);
	}
}

impl<'input> CustomRuleContext<'input> for ImportHeaderContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_importHeader }
	//fn type_rule_index() -> usize where Self: Sized { RULE_importHeader }
}
antlr_rust::type_id!{ImportHeaderContextExt<'a>}

impl<'input> ImportHeaderContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ImportHeaderContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ImportHeaderContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ImportHeaderContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<ImportHeaderContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token IMPORT
/// Returns `None` if there is no child corresponding to token IMPORT
fn IMPORT(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(IMPORT, 0)
}
fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token DOT
/// Returns `None` if there is no child corresponding to token DOT
fn DOT(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(DOT, 0)
}
/// Retrieves first TerminalNode corresponding to token MULT
/// Returns `None` if there is no child corresponding to token MULT
fn MULT(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(MULT, 0)
}
fn importAlias(&self) -> Option<Rc<ImportAliasContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn semi(&self) -> Option<Rc<SemiContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ImportHeaderContextAttrs<'input> for ImportHeaderContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn importHeader(&mut self,)
	-> Result<Rc<ImportHeaderContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ImportHeaderContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 12, RULE_importHeader);
        let mut _localctx: Rc<ImportHeaderContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(451);
			recog.base.match_token(IMPORT,&mut recog.err_handler)?;

			/*InvokeRule identifier*/
			recog.base.set_state(452);
			recog.identifier()?;

			recog.base.set_state(456);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 DOT 
				=> {
			    	{
			    	recog.base.set_state(453);
			    	recog.base.match_token(DOT,&mut recog.err_handler)?;

			    	recog.base.set_state(454);
			    	recog.base.match_token(MULT,&mut recog.err_handler)?;

			    	}
			    }

			 AS 
				=> {
			    	{
			    	/*InvokeRule importAlias*/
			    	recog.base.set_state(455);
			    	recog.importAlias()?;

			    	}
			    }

			 EOF | NL | LPAREN | LSQUARE | LCURL | ADD | SUB | INCR | DECR | EXCL_WS |
			 EXCL_NO_WS | SEMICOLON | COLONCOLON | AT_NO_WS | AT_PRE_WS | RETURN_AT |
			 CONTINUE_AT | BREAK_AT | THIS_AT | SUPER_AT | FILE | FIELD | PROPERTY |
			 GET | SET | RECEIVER | PARAM | SETPARAM | DELEGATE | IMPORT | CLASS |
			 INTERFACE | FUN | OBJECT | VAL | VAR | TYPE_ALIAS | CONSTRUCTOR | BY |
			 COMPANION | INIT | THIS | SUPER | WHERE | IF | WHEN | TRY | CATCH | FINALLY |
			 FOR | DO | WHILE | THROW | RETURN | CONTINUE | BREAK | OUT | DYNAMIC |
			 PUBLIC | PRIVATE | PROTECTED | INTERNAL | ENUM | SEALED | ANNOTATION |
			 DATA | INNER | VALUE | TAILREC | OPERATOR | INLINE | INFIX | EXTERNAL |
			 SUSPEND | OVERRIDE | ABSTRACT | FINAL | OPEN | CONST | LATEINIT | VARARG |
			 NOINLINE | CROSSINLINE | REIFIED | EXPECT | ACTUAL | RealLiteral | IntegerLiteral |
			 HexLiteral | BinLiteral | UnsignedLiteral | LongLiteral | BooleanLiteral |
			 NullLiteral | CharacterLiteral | Identifier | QUOTE_OPEN | TRIPLE_QUOTE_OPEN 
				=> {
			    }

				_ => {}
			}
			recog.base.set_state(459);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(18,&mut recog.base)? {
				x if x == 1=>{
					{
					/*InvokeRule semi*/
					recog.base.set_state(458);
					recog.semi()?;

					}
				}

				_ => {}
			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- importAlias ----------------
pub type ImportAliasContextAll<'input> = ImportAliasContext<'input>;


pub type ImportAliasContext<'input> = BaseParserRuleContext<'input,ImportAliasContextExt<'input>>;

#[derive(Clone)]
pub struct ImportAliasContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for ImportAliasContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for ImportAliasContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_importAlias(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_importAlias(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for ImportAliasContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_importAlias(self);
	}
}

impl<'input> CustomRuleContext<'input> for ImportAliasContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_importAlias }
	//fn type_rule_index() -> usize where Self: Sized { RULE_importAlias }
}
antlr_rust::type_id!{ImportAliasContextExt<'a>}

impl<'input> ImportAliasContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ImportAliasContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ImportAliasContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ImportAliasContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<ImportAliasContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token AS
/// Returns `None` if there is no child corresponding to token AS
fn AS(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(AS, 0)
}
fn simpleIdentifier(&self) -> Option<Rc<SimpleIdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ImportAliasContextAttrs<'input> for ImportAliasContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn importAlias(&mut self,)
	-> Result<Rc<ImportAliasContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ImportAliasContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 14, RULE_importAlias);
        let mut _localctx: Rc<ImportAliasContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(461);
			recog.base.match_token(AS,&mut recog.err_handler)?;

			/*InvokeRule simpleIdentifier*/
			recog.base.set_state(462);
			recog.simpleIdentifier()?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- topLevelObject ----------------
pub type TopLevelObjectContextAll<'input> = TopLevelObjectContext<'input>;


pub type TopLevelObjectContext<'input> = BaseParserRuleContext<'input,TopLevelObjectContextExt<'input>>;

#[derive(Clone)]
pub struct TopLevelObjectContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for TopLevelObjectContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for TopLevelObjectContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_topLevelObject(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_topLevelObject(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for TopLevelObjectContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_topLevelObject(self);
	}
}

impl<'input> CustomRuleContext<'input> for TopLevelObjectContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_topLevelObject }
	//fn type_rule_index() -> usize where Self: Sized { RULE_topLevelObject }
}
antlr_rust::type_id!{TopLevelObjectContextExt<'a>}

impl<'input> TopLevelObjectContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<TopLevelObjectContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,TopLevelObjectContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait TopLevelObjectContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<TopLevelObjectContextExt<'input>>{

fn declaration(&self) -> Option<Rc<DeclarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn semis(&self) -> Option<Rc<SemisContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> TopLevelObjectContextAttrs<'input> for TopLevelObjectContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn topLevelObject(&mut self,)
	-> Result<Rc<TopLevelObjectContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = TopLevelObjectContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 16, RULE_topLevelObject);
        let mut _localctx: Rc<TopLevelObjectContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule declaration*/
			recog.base.set_state(464);
			recog.declaration()?;

			recog.base.set_state(466);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==NL || _la==SEMICOLON {
				{
				/*InvokeRule semis*/
				recog.base.set_state(465);
				recog.semis()?;

				}
			}

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- typeAlias ----------------
pub type TypeAliasContextAll<'input> = TypeAliasContext<'input>;


pub type TypeAliasContext<'input> = BaseParserRuleContext<'input,TypeAliasContextExt<'input>>;

#[derive(Clone)]
pub struct TypeAliasContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for TypeAliasContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for TypeAliasContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_typeAlias(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_typeAlias(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for TypeAliasContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_typeAlias(self);
	}
}

impl<'input> CustomRuleContext<'input> for TypeAliasContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_typeAlias }
	//fn type_rule_index() -> usize where Self: Sized { RULE_typeAlias }
}
antlr_rust::type_id!{TypeAliasContextExt<'a>}

impl<'input> TypeAliasContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<TypeAliasContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,TypeAliasContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait TypeAliasContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<TypeAliasContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token TYPE_ALIAS
/// Returns `None` if there is no child corresponding to token TYPE_ALIAS
fn TYPE_ALIAS(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(TYPE_ALIAS, 0)
}
fn simpleIdentifier(&self) -> Option<Rc<SimpleIdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token ASSIGNMENT
/// Returns `None` if there is no child corresponding to token ASSIGNMENT
fn ASSIGNMENT(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(ASSIGNMENT, 0)
}
fn type(&self) -> Option<Rc<TypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn modifiers(&self) -> Option<Rc<ModifiersContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}
fn typeParameters(&self) -> Option<Rc<TypeParametersContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> TypeAliasContextAttrs<'input> for TypeAliasContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn typeAlias(&mut self,)
	-> Result<Rc<TypeAliasContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = TypeAliasContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 18, RULE_typeAlias);
        let mut _localctx: Rc<TypeAliasContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(469);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==AT_NO_WS || _la==AT_PRE_WS || ((((_la - 109)) & !0x3f) == 0 && ((1usize << (_la - 109)) & ((1usize << (PUBLIC - 109)) | (1usize << (PRIVATE - 109)) | (1usize << (PROTECTED - 109)) | (1usize << (INTERNAL - 109)) | (1usize << (ENUM - 109)) | (1usize << (SEALED - 109)) | (1usize << (ANNOTATION - 109)) | (1usize << (DATA - 109)) | (1usize << (INNER - 109)) | (1usize << (VALUE - 109)) | (1usize << (TAILREC - 109)) | (1usize << (OPERATOR - 109)) | (1usize << (INLINE - 109)) | (1usize << (INFIX - 109)) | (1usize << (EXTERNAL - 109)) | (1usize << (SUSPEND - 109)) | (1usize << (OVERRIDE - 109)) | (1usize << (ABSTRACT - 109)) | (1usize << (FINAL - 109)) | (1usize << (OPEN - 109)) | (1usize << (CONST - 109)) | (1usize << (LATEINIT - 109)) | (1usize << (VARARG - 109)) | (1usize << (NOINLINE - 109)) | (1usize << (CROSSINLINE - 109)) | (1usize << (EXPECT - 109)) | (1usize << (ACTUAL - 109)))) != 0) {
				{
				/*InvokeRule modifiers*/
				recog.base.set_state(468);
				recog.modifiers()?;

				}
			}

			recog.base.set_state(471);
			recog.base.match_token(TYPE_ALIAS,&mut recog.err_handler)?;

			recog.base.set_state(475);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(472);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(477);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			/*InvokeRule simpleIdentifier*/
			recog.base.set_state(478);
			recog.simpleIdentifier()?;

			recog.base.set_state(486);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(23,&mut recog.base)? {
				x if x == 1=>{
					{
					recog.base.set_state(482);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(479);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(484);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					/*InvokeRule typeParameters*/
					recog.base.set_state(485);
					recog.typeParameters()?;

					}
				}

				_ => {}
			}
			recog.base.set_state(491);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(488);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(493);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(494);
			recog.base.match_token(ASSIGNMENT,&mut recog.err_handler)?;

			recog.base.set_state(498);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(495);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(500);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			/*InvokeRule type*/
			recog.base.set_state(501);
			recog.type()?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- declaration ----------------
pub type DeclarationContextAll<'input> = DeclarationContext<'input>;


pub type DeclarationContext<'input> = BaseParserRuleContext<'input,DeclarationContextExt<'input>>;

#[derive(Clone)]
pub struct DeclarationContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for DeclarationContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for DeclarationContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_declaration(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_declaration(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for DeclarationContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_declaration(self);
	}
}

impl<'input> CustomRuleContext<'input> for DeclarationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_declaration }
	//fn type_rule_index() -> usize where Self: Sized { RULE_declaration }
}
antlr_rust::type_id!{DeclarationContextExt<'a>}

impl<'input> DeclarationContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<DeclarationContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,DeclarationContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait DeclarationContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<DeclarationContextExt<'input>>{

fn classDeclaration(&self) -> Option<Rc<ClassDeclarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn objectDeclaration(&self) -> Option<Rc<ObjectDeclarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn functionDeclaration(&self) -> Option<Rc<FunctionDeclarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn propertyDeclaration(&self) -> Option<Rc<PropertyDeclarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn typeAlias(&self) -> Option<Rc<TypeAliasContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> DeclarationContextAttrs<'input> for DeclarationContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn declaration(&mut self,)
	-> Result<Rc<DeclarationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = DeclarationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 20, RULE_declaration);
        let mut _localctx: Rc<DeclarationContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			recog.base.set_state(508);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(26,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule classDeclaration*/
					recog.base.set_state(503);
					recog.classDeclaration()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule objectDeclaration*/
					recog.base.set_state(504);
					recog.objectDeclaration()?;

					}
				}
			,
				3 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					/*InvokeRule functionDeclaration*/
					recog.base.set_state(505);
					recog.functionDeclaration()?;

					}
				}
			,
				4 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 4);
					recog.base.enter_outer_alt(None, 4);
					{
					/*InvokeRule propertyDeclaration*/
					recog.base.set_state(506);
					recog.propertyDeclaration()?;

					}
				}
			,
				5 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 5);
					recog.base.enter_outer_alt(None, 5);
					{
					/*InvokeRule typeAlias*/
					recog.base.set_state(507);
					recog.typeAlias()?;

					}
				}

				_ => {}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- classDeclaration ----------------
pub type ClassDeclarationContextAll<'input> = ClassDeclarationContext<'input>;


pub type ClassDeclarationContext<'input> = BaseParserRuleContext<'input,ClassDeclarationContextExt<'input>>;

#[derive(Clone)]
pub struct ClassDeclarationContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for ClassDeclarationContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for ClassDeclarationContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_classDeclaration(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_classDeclaration(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for ClassDeclarationContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_classDeclaration(self);
	}
}

impl<'input> CustomRuleContext<'input> for ClassDeclarationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_classDeclaration }
	//fn type_rule_index() -> usize where Self: Sized { RULE_classDeclaration }
}
antlr_rust::type_id!{ClassDeclarationContextExt<'a>}

impl<'input> ClassDeclarationContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ClassDeclarationContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ClassDeclarationContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ClassDeclarationContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<ClassDeclarationContextExt<'input>>{

fn simpleIdentifier(&self) -> Option<Rc<SimpleIdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token CLASS
/// Returns `None` if there is no child corresponding to token CLASS
fn CLASS(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(CLASS, 0)
}
/// Retrieves first TerminalNode corresponding to token INTERFACE
/// Returns `None` if there is no child corresponding to token INTERFACE
fn INTERFACE(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(INTERFACE, 0)
}
fn modifiers(&self) -> Option<Rc<ModifiersContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}
fn typeParameters(&self) -> Option<Rc<TypeParametersContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn primaryConstructor(&self) -> Option<Rc<PrimaryConstructorContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COLON
/// Returns `None` if there is no child corresponding to token COLON
fn COLON(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(COLON, 0)
}
fn delegationSpecifiers(&self) -> Option<Rc<DelegationSpecifiersContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn typeConstraints(&self) -> Option<Rc<TypeConstraintsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn classBody(&self) -> Option<Rc<ClassBodyContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn enumClassBody(&self) -> Option<Rc<EnumClassBodyContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token FUN
/// Returns `None` if there is no child corresponding to token FUN
fn FUN(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(FUN, 0)
}

}

impl<'input> ClassDeclarationContextAttrs<'input> for ClassDeclarationContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn classDeclaration(&mut self,)
	-> Result<Rc<ClassDeclarationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ClassDeclarationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 22, RULE_classDeclaration);
        let mut _localctx: Rc<ClassDeclarationContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(511);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==AT_NO_WS || _la==AT_PRE_WS || ((((_la - 109)) & !0x3f) == 0 && ((1usize << (_la - 109)) & ((1usize << (PUBLIC - 109)) | (1usize << (PRIVATE - 109)) | (1usize << (PROTECTED - 109)) | (1usize << (INTERNAL - 109)) | (1usize << (ENUM - 109)) | (1usize << (SEALED - 109)) | (1usize << (ANNOTATION - 109)) | (1usize << (DATA - 109)) | (1usize << (INNER - 109)) | (1usize << (VALUE - 109)) | (1usize << (TAILREC - 109)) | (1usize << (OPERATOR - 109)) | (1usize << (INLINE - 109)) | (1usize << (INFIX - 109)) | (1usize << (EXTERNAL - 109)) | (1usize << (SUSPEND - 109)) | (1usize << (OVERRIDE - 109)) | (1usize << (ABSTRACT - 109)) | (1usize << (FINAL - 109)) | (1usize << (OPEN - 109)) | (1usize << (CONST - 109)) | (1usize << (LATEINIT - 109)) | (1usize << (VARARG - 109)) | (1usize << (NOINLINE - 109)) | (1usize << (CROSSINLINE - 109)) | (1usize << (EXPECT - 109)) | (1usize << (ACTUAL - 109)))) != 0) {
				{
				/*InvokeRule modifiers*/
				recog.base.set_state(510);
				recog.modifiers()?;

				}
			}

			recog.base.set_state(524);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 CLASS 
				=> {
					{
					recog.base.set_state(513);
					recog.base.match_token(CLASS,&mut recog.err_handler)?;

					}
				}

			 INTERFACE | FUN 
				=> {
					{
					recog.base.set_state(521);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==FUN {
						{
						recog.base.set_state(514);
						recog.base.match_token(FUN,&mut recog.err_handler)?;

						recog.base.set_state(518);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
						while _la==NL {
							{
							{
							recog.base.set_state(515);
							recog.base.match_token(NL,&mut recog.err_handler)?;

							}
							}
							recog.base.set_state(520);
							recog.err_handler.sync(&mut recog.base)?;
							_la = recog.base.input.la(1);
						}
						}
					}

					recog.base.set_state(523);
					recog.base.match_token(INTERFACE,&mut recog.err_handler)?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			recog.base.set_state(529);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(526);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(531);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			/*InvokeRule simpleIdentifier*/
			recog.base.set_state(532);
			recog.simpleIdentifier()?;

			recog.base.set_state(540);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(33,&mut recog.base)? {
				x if x == 1=>{
					{
					recog.base.set_state(536);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(533);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(538);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					/*InvokeRule typeParameters*/
					recog.base.set_state(539);
					recog.typeParameters()?;

					}
				}

				_ => {}
			}
			recog.base.set_state(549);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(35,&mut recog.base)? {
				x if x == 1=>{
					{
					recog.base.set_state(545);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(542);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(547);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					/*InvokeRule primaryConstructor*/
					recog.base.set_state(548);
					recog.primaryConstructor()?;

					}
				}

				_ => {}
			}
			recog.base.set_state(565);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(38,&mut recog.base)? {
				x if x == 1=>{
					{
					recog.base.set_state(554);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(551);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(556);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(557);
					recog.base.match_token(COLON,&mut recog.err_handler)?;

					recog.base.set_state(561);
					recog.err_handler.sync(&mut recog.base)?;
					_alt = recog.interpreter.adaptive_predict(37,&mut recog.base)?;
					while { _alt!=2 && _alt!=INVALID_ALT } {
						if _alt==1 {
							{
							{
							recog.base.set_state(558);
							recog.base.match_token(NL,&mut recog.err_handler)?;

							}
							} 
						}
						recog.base.set_state(563);
						recog.err_handler.sync(&mut recog.base)?;
						_alt = recog.interpreter.adaptive_predict(37,&mut recog.base)?;
					}
					/*InvokeRule delegationSpecifiers*/
					recog.base.set_state(564);
					recog.delegationSpecifiers()?;

					}
				}

				_ => {}
			}
			recog.base.set_state(574);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(40,&mut recog.base)? {
				x if x == 1=>{
					{
					recog.base.set_state(570);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(567);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(572);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					/*InvokeRule typeConstraints*/
					recog.base.set_state(573);
					recog.typeConstraints()?;

					}
				}

				_ => {}
			}
			recog.base.set_state(590);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(43,&mut recog.base)? {
				x if x == 1=>{
					{
					recog.base.set_state(579);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(576);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(581);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					/*InvokeRule classBody*/
					recog.base.set_state(582);
					recog.classBody()?;

					}
				}

				x if x == 2=>{
					{
					recog.base.set_state(586);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(583);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(588);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					/*InvokeRule enumClassBody*/
					recog.base.set_state(589);
					recog.enumClassBody()?;

					}
				}

				_ => {}
			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- primaryConstructor ----------------
pub type PrimaryConstructorContextAll<'input> = PrimaryConstructorContext<'input>;


pub type PrimaryConstructorContext<'input> = BaseParserRuleContext<'input,PrimaryConstructorContextExt<'input>>;

#[derive(Clone)]
pub struct PrimaryConstructorContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for PrimaryConstructorContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for PrimaryConstructorContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_primaryConstructor(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_primaryConstructor(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for PrimaryConstructorContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_primaryConstructor(self);
	}
}

impl<'input> CustomRuleContext<'input> for PrimaryConstructorContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_primaryConstructor }
	//fn type_rule_index() -> usize where Self: Sized { RULE_primaryConstructor }
}
antlr_rust::type_id!{PrimaryConstructorContextExt<'a>}

impl<'input> PrimaryConstructorContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<PrimaryConstructorContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,PrimaryConstructorContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait PrimaryConstructorContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<PrimaryConstructorContextExt<'input>>{

fn classParameters(&self) -> Option<Rc<ClassParametersContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token CONSTRUCTOR
/// Returns `None` if there is no child corresponding to token CONSTRUCTOR
fn CONSTRUCTOR(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(CONSTRUCTOR, 0)
}
fn modifiers(&self) -> Option<Rc<ModifiersContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}

}

impl<'input> PrimaryConstructorContextAttrs<'input> for PrimaryConstructorContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn primaryConstructor(&mut self,)
	-> Result<Rc<PrimaryConstructorContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = PrimaryConstructorContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 24, RULE_primaryConstructor);
        let mut _localctx: Rc<PrimaryConstructorContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(602);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==AT_NO_WS || _la==AT_PRE_WS || ((((_la - 81)) & !0x3f) == 0 && ((1usize << (_la - 81)) & ((1usize << (CONSTRUCTOR - 81)) | (1usize << (PUBLIC - 81)) | (1usize << (PRIVATE - 81)) | (1usize << (PROTECTED - 81)) | (1usize << (INTERNAL - 81)) | (1usize << (ENUM - 81)) | (1usize << (SEALED - 81)) | (1usize << (ANNOTATION - 81)) | (1usize << (DATA - 81)) | (1usize << (INNER - 81)) | (1usize << (VALUE - 81)) | (1usize << (TAILREC - 81)) | (1usize << (OPERATOR - 81)) | (1usize << (INLINE - 81)) | (1usize << (INFIX - 81)) | (1usize << (EXTERNAL - 81)) | (1usize << (SUSPEND - 81)) | (1usize << (OVERRIDE - 81)) | (1usize << (ABSTRACT - 81)) | (1usize << (FINAL - 81)) | (1usize << (OPEN - 81)) | (1usize << (CONST - 81)) | (1usize << (LATEINIT - 81)) | (1usize << (VARARG - 81)) | (1usize << (NOINLINE - 81)) | (1usize << (CROSSINLINE - 81)) | (1usize << (EXPECT - 81)) | (1usize << (ACTUAL - 81)))) != 0) {
				{
				recog.base.set_state(593);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
				if _la==AT_NO_WS || _la==AT_PRE_WS || ((((_la - 109)) & !0x3f) == 0 && ((1usize << (_la - 109)) & ((1usize << (PUBLIC - 109)) | (1usize << (PRIVATE - 109)) | (1usize << (PROTECTED - 109)) | (1usize << (INTERNAL - 109)) | (1usize << (ENUM - 109)) | (1usize << (SEALED - 109)) | (1usize << (ANNOTATION - 109)) | (1usize << (DATA - 109)) | (1usize << (INNER - 109)) | (1usize << (VALUE - 109)) | (1usize << (TAILREC - 109)) | (1usize << (OPERATOR - 109)) | (1usize << (INLINE - 109)) | (1usize << (INFIX - 109)) | (1usize << (EXTERNAL - 109)) | (1usize << (SUSPEND - 109)) | (1usize << (OVERRIDE - 109)) | (1usize << (ABSTRACT - 109)) | (1usize << (FINAL - 109)) | (1usize << (OPEN - 109)) | (1usize << (CONST - 109)) | (1usize << (LATEINIT - 109)) | (1usize << (VARARG - 109)) | (1usize << (NOINLINE - 109)) | (1usize << (CROSSINLINE - 109)) | (1usize << (EXPECT - 109)) | (1usize << (ACTUAL - 109)))) != 0) {
					{
					/*InvokeRule modifiers*/
					recog.base.set_state(592);
					recog.modifiers()?;

					}
				}

				recog.base.set_state(595);
				recog.base.match_token(CONSTRUCTOR,&mut recog.err_handler)?;

				recog.base.set_state(599);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
				while _la==NL {
					{
					{
					recog.base.set_state(596);
					recog.base.match_token(NL,&mut recog.err_handler)?;

					}
					}
					recog.base.set_state(601);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
				}
				}
			}

			/*InvokeRule classParameters*/
			recog.base.set_state(604);
			recog.classParameters()?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- classBody ----------------
pub type ClassBodyContextAll<'input> = ClassBodyContext<'input>;


pub type ClassBodyContext<'input> = BaseParserRuleContext<'input,ClassBodyContextExt<'input>>;

#[derive(Clone)]
pub struct ClassBodyContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for ClassBodyContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for ClassBodyContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_classBody(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_classBody(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for ClassBodyContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_classBody(self);
	}
}

impl<'input> CustomRuleContext<'input> for ClassBodyContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_classBody }
	//fn type_rule_index() -> usize where Self: Sized { RULE_classBody }
}
antlr_rust::type_id!{ClassBodyContextExt<'a>}

impl<'input> ClassBodyContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ClassBodyContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ClassBodyContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ClassBodyContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<ClassBodyContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token LCURL
/// Returns `None` if there is no child corresponding to token LCURL
fn LCURL(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(LCURL, 0)
}
fn classMemberDeclarations(&self) -> Option<Rc<ClassMemberDeclarationsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token RCURL
/// Returns `None` if there is no child corresponding to token RCURL
fn RCURL(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(RCURL, 0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}

}

impl<'input> ClassBodyContextAttrs<'input> for ClassBodyContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn classBody(&mut self,)
	-> Result<Rc<ClassBodyContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ClassBodyContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 26, RULE_classBody);
        let mut _localctx: Rc<ClassBodyContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(606);
			recog.base.match_token(LCURL,&mut recog.err_handler)?;

			recog.base.set_state(610);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(47,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					recog.base.set_state(607);
					recog.base.match_token(NL,&mut recog.err_handler)?;

					}
					} 
				}
				recog.base.set_state(612);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(47,&mut recog.base)?;
			}
			/*InvokeRule classMemberDeclarations*/
			recog.base.set_state(613);
			recog.classMemberDeclarations()?;

			recog.base.set_state(617);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(614);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(619);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(620);
			recog.base.match_token(RCURL,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- classParameters ----------------
pub type ClassParametersContextAll<'input> = ClassParametersContext<'input>;


pub type ClassParametersContext<'input> = BaseParserRuleContext<'input,ClassParametersContextExt<'input>>;

#[derive(Clone)]
pub struct ClassParametersContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for ClassParametersContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for ClassParametersContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_classParameters(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_classParameters(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for ClassParametersContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_classParameters(self);
	}
}

impl<'input> CustomRuleContext<'input> for ClassParametersContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_classParameters }
	//fn type_rule_index() -> usize where Self: Sized { RULE_classParameters }
}
antlr_rust::type_id!{ClassParametersContextExt<'a>}

impl<'input> ClassParametersContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ClassParametersContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ClassParametersContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ClassParametersContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<ClassParametersContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token LPAREN
/// Returns `None` if there is no child corresponding to token LPAREN
fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(LPAREN, 0)
}
/// Retrieves first TerminalNode corresponding to token RPAREN
/// Returns `None` if there is no child corresponding to token RPAREN
fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(RPAREN, 0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}
fn classParameter_all(&self) ->  Vec<Rc<ClassParameterContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn classParameter(&self, i: usize) -> Option<Rc<ClassParameterContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}

}

impl<'input> ClassParametersContextAttrs<'input> for ClassParametersContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn classParameters(&mut self,)
	-> Result<Rc<ClassParametersContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ClassParametersContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 28, RULE_classParameters);
        let mut _localctx: Rc<ClassParametersContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(622);
			recog.base.match_token(LPAREN,&mut recog.err_handler)?;

			recog.base.set_state(626);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(49,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					recog.base.set_state(623);
					recog.base.match_token(NL,&mut recog.err_handler)?;

					}
					} 
				}
				recog.base.set_state(628);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(49,&mut recog.base)?;
			}
			recog.base.set_state(658);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(55,&mut recog.base)? {
				x if x == 1=>{
					{
					/*InvokeRule classParameter*/
					recog.base.set_state(629);
					recog.classParameter()?;

					recog.base.set_state(646);
					recog.err_handler.sync(&mut recog.base)?;
					_alt = recog.interpreter.adaptive_predict(52,&mut recog.base)?;
					while { _alt!=2 && _alt!=INVALID_ALT } {
						if _alt==1 {
							{
							{
							recog.base.set_state(633);
							recog.err_handler.sync(&mut recog.base)?;
							_la = recog.base.input.la(1);
							while _la==NL {
								{
								{
								recog.base.set_state(630);
								recog.base.match_token(NL,&mut recog.err_handler)?;

								}
								}
								recog.base.set_state(635);
								recog.err_handler.sync(&mut recog.base)?;
								_la = recog.base.input.la(1);
							}
							recog.base.set_state(636);
							recog.base.match_token(COMMA,&mut recog.err_handler)?;

							recog.base.set_state(640);
							recog.err_handler.sync(&mut recog.base)?;
							_alt = recog.interpreter.adaptive_predict(51,&mut recog.base)?;
							while { _alt!=2 && _alt!=INVALID_ALT } {
								if _alt==1 {
									{
									{
									recog.base.set_state(637);
									recog.base.match_token(NL,&mut recog.err_handler)?;

									}
									} 
								}
								recog.base.set_state(642);
								recog.err_handler.sync(&mut recog.base)?;
								_alt = recog.interpreter.adaptive_predict(51,&mut recog.base)?;
							}
							/*InvokeRule classParameter*/
							recog.base.set_state(643);
							recog.classParameter()?;

							}
							} 
						}
						recog.base.set_state(648);
						recog.err_handler.sync(&mut recog.base)?;
						_alt = recog.interpreter.adaptive_predict(52,&mut recog.base)?;
					}
					recog.base.set_state(656);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(54,&mut recog.base)? {
						x if x == 1=>{
							{
							recog.base.set_state(652);
							recog.err_handler.sync(&mut recog.base)?;
							_la = recog.base.input.la(1);
							while _la==NL {
								{
								{
								recog.base.set_state(649);
								recog.base.match_token(NL,&mut recog.err_handler)?;

								}
								}
								recog.base.set_state(654);
								recog.err_handler.sync(&mut recog.base)?;
								_la = recog.base.input.la(1);
							}
							recog.base.set_state(655);
							recog.base.match_token(COMMA,&mut recog.err_handler)?;

							}
						}

						_ => {}
					}
					}
				}

				_ => {}
			}
			recog.base.set_state(663);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(660);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(665);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(666);
			recog.base.match_token(RPAREN,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- classParameter ----------------
pub type ClassParameterContextAll<'input> = ClassParameterContext<'input>;


pub type ClassParameterContext<'input> = BaseParserRuleContext<'input,ClassParameterContextExt<'input>>;

#[derive(Clone)]
pub struct ClassParameterContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for ClassParameterContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for ClassParameterContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_classParameter(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_classParameter(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for ClassParameterContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_classParameter(self);
	}
}

impl<'input> CustomRuleContext<'input> for ClassParameterContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_classParameter }
	//fn type_rule_index() -> usize where Self: Sized { RULE_classParameter }
}
antlr_rust::type_id!{ClassParameterContextExt<'a>}

impl<'input> ClassParameterContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ClassParameterContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ClassParameterContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ClassParameterContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<ClassParameterContextExt<'input>>{

fn simpleIdentifier(&self) -> Option<Rc<SimpleIdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COLON
/// Returns `None` if there is no child corresponding to token COLON
fn COLON(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(COLON, 0)
}
fn type(&self) -> Option<Rc<TypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn modifiers(&self) -> Option<Rc<ModifiersContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}
/// Retrieves first TerminalNode corresponding to token ASSIGNMENT
/// Returns `None` if there is no child corresponding to token ASSIGNMENT
fn ASSIGNMENT(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(ASSIGNMENT, 0)
}
fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token VAL
/// Returns `None` if there is no child corresponding to token VAL
fn VAL(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(VAL, 0)
}
/// Retrieves first TerminalNode corresponding to token VAR
/// Returns `None` if there is no child corresponding to token VAR
fn VAR(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(VAR, 0)
}

}

impl<'input> ClassParameterContextAttrs<'input> for ClassParameterContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn classParameter(&mut self,)
	-> Result<Rc<ClassParameterContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ClassParameterContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 30, RULE_classParameter);
        let mut _localctx: Rc<ClassParameterContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(669);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(57,&mut recog.base)? {
				x if x == 1=>{
					{
					/*InvokeRule modifiers*/
					recog.base.set_state(668);
					recog.modifiers()?;

					}
				}

				_ => {}
			}
			recog.base.set_state(672);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==VAL || _la==VAR {
				{
				recog.base.set_state(671);
				_la = recog.base.input.la(1);
				if { !(_la==VAL || _la==VAR) } {
					recog.err_handler.recover_inline(&mut recog.base)?;

				}
				else {
					if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
					recog.err_handler.report_match(&mut recog.base);
					recog.base.consume(&mut recog.err_handler);
				}
				}
			}

			recog.base.set_state(677);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(674);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(679);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			/*InvokeRule simpleIdentifier*/
			recog.base.set_state(680);
			recog.simpleIdentifier()?;

			recog.base.set_state(681);
			recog.base.match_token(COLON,&mut recog.err_handler)?;

			recog.base.set_state(685);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(682);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(687);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			/*InvokeRule type*/
			recog.base.set_state(688);
			recog.type()?;

			recog.base.set_state(703);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(63,&mut recog.base)? {
				x if x == 1=>{
					{
					recog.base.set_state(692);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(689);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(694);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(695);
					recog.base.match_token(ASSIGNMENT,&mut recog.err_handler)?;

					recog.base.set_state(699);
					recog.err_handler.sync(&mut recog.base)?;
					_alt = recog.interpreter.adaptive_predict(62,&mut recog.base)?;
					while { _alt!=2 && _alt!=INVALID_ALT } {
						if _alt==1 {
							{
							{
							recog.base.set_state(696);
							recog.base.match_token(NL,&mut recog.err_handler)?;

							}
							} 
						}
						recog.base.set_state(701);
						recog.err_handler.sync(&mut recog.base)?;
						_alt = recog.interpreter.adaptive_predict(62,&mut recog.base)?;
					}
					/*InvokeRule expression*/
					recog.base.set_state(702);
					recog.expression()?;

					}
				}

				_ => {}
			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- delegationSpecifiers ----------------
pub type DelegationSpecifiersContextAll<'input> = DelegationSpecifiersContext<'input>;


pub type DelegationSpecifiersContext<'input> = BaseParserRuleContext<'input,DelegationSpecifiersContextExt<'input>>;

#[derive(Clone)]
pub struct DelegationSpecifiersContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for DelegationSpecifiersContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for DelegationSpecifiersContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_delegationSpecifiers(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_delegationSpecifiers(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for DelegationSpecifiersContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_delegationSpecifiers(self);
	}
}

impl<'input> CustomRuleContext<'input> for DelegationSpecifiersContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_delegationSpecifiers }
	//fn type_rule_index() -> usize where Self: Sized { RULE_delegationSpecifiers }
}
antlr_rust::type_id!{DelegationSpecifiersContextExt<'a>}

impl<'input> DelegationSpecifiersContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<DelegationSpecifiersContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,DelegationSpecifiersContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait DelegationSpecifiersContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<DelegationSpecifiersContextExt<'input>>{

fn annotatedDelegationSpecifier_all(&self) ->  Vec<Rc<AnnotatedDelegationSpecifierContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn annotatedDelegationSpecifier(&self, i: usize) -> Option<Rc<AnnotatedDelegationSpecifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}

}

impl<'input> DelegationSpecifiersContextAttrs<'input> for DelegationSpecifiersContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn delegationSpecifiers(&mut self,)
	-> Result<Rc<DelegationSpecifiersContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = DelegationSpecifiersContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 32, RULE_delegationSpecifiers);
        let mut _localctx: Rc<DelegationSpecifiersContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule annotatedDelegationSpecifier*/
			recog.base.set_state(705);
			recog.annotatedDelegationSpecifier()?;

			recog.base.set_state(722);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(66,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					recog.base.set_state(709);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(706);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(711);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(712);
					recog.base.match_token(COMMA,&mut recog.err_handler)?;

					recog.base.set_state(716);
					recog.err_handler.sync(&mut recog.base)?;
					_alt = recog.interpreter.adaptive_predict(65,&mut recog.base)?;
					while { _alt!=2 && _alt!=INVALID_ALT } {
						if _alt==1 {
							{
							{
							recog.base.set_state(713);
							recog.base.match_token(NL,&mut recog.err_handler)?;

							}
							} 
						}
						recog.base.set_state(718);
						recog.err_handler.sync(&mut recog.base)?;
						_alt = recog.interpreter.adaptive_predict(65,&mut recog.base)?;
					}
					/*InvokeRule annotatedDelegationSpecifier*/
					recog.base.set_state(719);
					recog.annotatedDelegationSpecifier()?;

					}
					} 
				}
				recog.base.set_state(724);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(66,&mut recog.base)?;
			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- delegationSpecifier ----------------
pub type DelegationSpecifierContextAll<'input> = DelegationSpecifierContext<'input>;


pub type DelegationSpecifierContext<'input> = BaseParserRuleContext<'input,DelegationSpecifierContextExt<'input>>;

#[derive(Clone)]
pub struct DelegationSpecifierContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for DelegationSpecifierContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for DelegationSpecifierContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_delegationSpecifier(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_delegationSpecifier(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for DelegationSpecifierContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_delegationSpecifier(self);
	}
}

impl<'input> CustomRuleContext<'input> for DelegationSpecifierContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_delegationSpecifier }
	//fn type_rule_index() -> usize where Self: Sized { RULE_delegationSpecifier }
}
antlr_rust::type_id!{DelegationSpecifierContextExt<'a>}

impl<'input> DelegationSpecifierContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<DelegationSpecifierContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,DelegationSpecifierContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait DelegationSpecifierContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<DelegationSpecifierContextExt<'input>>{

fn constructorInvocation(&self) -> Option<Rc<ConstructorInvocationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn explicitDelegation(&self) -> Option<Rc<ExplicitDelegationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn userType(&self) -> Option<Rc<UserTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn functionType(&self) -> Option<Rc<FunctionTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token SUSPEND
/// Returns `None` if there is no child corresponding to token SUSPEND
fn SUSPEND(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(SUSPEND, 0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}

}

impl<'input> DelegationSpecifierContextAttrs<'input> for DelegationSpecifierContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn delegationSpecifier(&mut self,)
	-> Result<Rc<DelegationSpecifierContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = DelegationSpecifierContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 34, RULE_delegationSpecifier);
        let mut _localctx: Rc<DelegationSpecifierContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			recog.base.set_state(737);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(68,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule constructorInvocation*/
					recog.base.set_state(725);
					recog.constructorInvocation()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule explicitDelegation*/
					recog.base.set_state(726);
					recog.explicitDelegation()?;

					}
				}
			,
				3 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					/*InvokeRule userType*/
					recog.base.set_state(727);
					recog.userType()?;

					}
				}
			,
				4 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 4);
					recog.base.enter_outer_alt(None, 4);
					{
					/*InvokeRule functionType*/
					recog.base.set_state(728);
					recog.functionType()?;

					}
				}
			,
				5 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 5);
					recog.base.enter_outer_alt(None, 5);
					{
					recog.base.set_state(729);
					recog.base.match_token(SUSPEND,&mut recog.err_handler)?;

					recog.base.set_state(733);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(730);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(735);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					/*InvokeRule functionType*/
					recog.base.set_state(736);
					recog.functionType()?;

					}
				}

				_ => {}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- constructorInvocation ----------------
pub type ConstructorInvocationContextAll<'input> = ConstructorInvocationContext<'input>;


pub type ConstructorInvocationContext<'input> = BaseParserRuleContext<'input,ConstructorInvocationContextExt<'input>>;

#[derive(Clone)]
pub struct ConstructorInvocationContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for ConstructorInvocationContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for ConstructorInvocationContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_constructorInvocation(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_constructorInvocation(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for ConstructorInvocationContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_constructorInvocation(self);
	}
}

impl<'input> CustomRuleContext<'input> for ConstructorInvocationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_constructorInvocation }
	//fn type_rule_index() -> usize where Self: Sized { RULE_constructorInvocation }
}
antlr_rust::type_id!{ConstructorInvocationContextExt<'a>}

impl<'input> ConstructorInvocationContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ConstructorInvocationContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ConstructorInvocationContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ConstructorInvocationContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<ConstructorInvocationContextExt<'input>>{

fn userType(&self) -> Option<Rc<UserTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn valueArguments(&self) -> Option<Rc<ValueArgumentsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}

}

impl<'input> ConstructorInvocationContextAttrs<'input> for ConstructorInvocationContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn constructorInvocation(&mut self,)
	-> Result<Rc<ConstructorInvocationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ConstructorInvocationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 36, RULE_constructorInvocation);
        let mut _localctx: Rc<ConstructorInvocationContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule userType*/
			recog.base.set_state(739);
			recog.userType()?;

			recog.base.set_state(743);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(740);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(745);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			/*InvokeRule valueArguments*/
			recog.base.set_state(746);
			recog.valueArguments()?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- annotatedDelegationSpecifier ----------------
pub type AnnotatedDelegationSpecifierContextAll<'input> = AnnotatedDelegationSpecifierContext<'input>;


pub type AnnotatedDelegationSpecifierContext<'input> = BaseParserRuleContext<'input,AnnotatedDelegationSpecifierContextExt<'input>>;

#[derive(Clone)]
pub struct AnnotatedDelegationSpecifierContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for AnnotatedDelegationSpecifierContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for AnnotatedDelegationSpecifierContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_annotatedDelegationSpecifier(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_annotatedDelegationSpecifier(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for AnnotatedDelegationSpecifierContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_annotatedDelegationSpecifier(self);
	}
}

impl<'input> CustomRuleContext<'input> for AnnotatedDelegationSpecifierContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_annotatedDelegationSpecifier }
	//fn type_rule_index() -> usize where Self: Sized { RULE_annotatedDelegationSpecifier }
}
antlr_rust::type_id!{AnnotatedDelegationSpecifierContextExt<'a>}

impl<'input> AnnotatedDelegationSpecifierContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AnnotatedDelegationSpecifierContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AnnotatedDelegationSpecifierContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AnnotatedDelegationSpecifierContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<AnnotatedDelegationSpecifierContextExt<'input>>{

fn delegationSpecifier(&self) -> Option<Rc<DelegationSpecifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn annotation_all(&self) ->  Vec<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}

}

impl<'input> AnnotatedDelegationSpecifierContextAttrs<'input> for AnnotatedDelegationSpecifierContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn annotatedDelegationSpecifier(&mut self,)
	-> Result<Rc<AnnotatedDelegationSpecifierContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AnnotatedDelegationSpecifierContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 38, RULE_annotatedDelegationSpecifier);
        let mut _localctx: Rc<AnnotatedDelegationSpecifierContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(751);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(70,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					/*InvokeRule annotation*/
					recog.base.set_state(748);
					recog.annotation()?;

					}
					} 
				}
				recog.base.set_state(753);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(70,&mut recog.base)?;
			}
			recog.base.set_state(757);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(754);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(759);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			/*InvokeRule delegationSpecifier*/
			recog.base.set_state(760);
			recog.delegationSpecifier()?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- explicitDelegation ----------------
pub type ExplicitDelegationContextAll<'input> = ExplicitDelegationContext<'input>;


pub type ExplicitDelegationContext<'input> = BaseParserRuleContext<'input,ExplicitDelegationContextExt<'input>>;

#[derive(Clone)]
pub struct ExplicitDelegationContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for ExplicitDelegationContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for ExplicitDelegationContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_explicitDelegation(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_explicitDelegation(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for ExplicitDelegationContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_explicitDelegation(self);
	}
}

impl<'input> CustomRuleContext<'input> for ExplicitDelegationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_explicitDelegation }
	//fn type_rule_index() -> usize where Self: Sized { RULE_explicitDelegation }
}
antlr_rust::type_id!{ExplicitDelegationContextExt<'a>}

impl<'input> ExplicitDelegationContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ExplicitDelegationContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ExplicitDelegationContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ExplicitDelegationContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<ExplicitDelegationContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token BY
/// Returns `None` if there is no child corresponding to token BY
fn BY(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(BY, 0)
}
fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn userType(&self) -> Option<Rc<UserTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn functionType(&self) -> Option<Rc<FunctionTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}

}

impl<'input> ExplicitDelegationContextAttrs<'input> for ExplicitDelegationContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn explicitDelegation(&mut self,)
	-> Result<Rc<ExplicitDelegationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ExplicitDelegationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 40, RULE_explicitDelegation);
        let mut _localctx: Rc<ExplicitDelegationContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(764);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(72,&mut recog.base)? {
				1 =>{
					{
					/*InvokeRule userType*/
					recog.base.set_state(762);
					recog.userType()?;

					}
				}
			,
				2 =>{
					{
					/*InvokeRule functionType*/
					recog.base.set_state(763);
					recog.functionType()?;

					}
				}

				_ => {}
			}
			recog.base.set_state(769);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(766);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(771);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(772);
			recog.base.match_token(BY,&mut recog.err_handler)?;

			recog.base.set_state(776);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(74,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					recog.base.set_state(773);
					recog.base.match_token(NL,&mut recog.err_handler)?;

					}
					} 
				}
				recog.base.set_state(778);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(74,&mut recog.base)?;
			}
			/*InvokeRule expression*/
			recog.base.set_state(779);
			recog.expression()?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- typeParameters ----------------
pub type TypeParametersContextAll<'input> = TypeParametersContext<'input>;


pub type TypeParametersContext<'input> = BaseParserRuleContext<'input,TypeParametersContextExt<'input>>;

#[derive(Clone)]
pub struct TypeParametersContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for TypeParametersContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for TypeParametersContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_typeParameters(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_typeParameters(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for TypeParametersContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_typeParameters(self);
	}
}

impl<'input> CustomRuleContext<'input> for TypeParametersContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_typeParameters }
	//fn type_rule_index() -> usize where Self: Sized { RULE_typeParameters }
}
antlr_rust::type_id!{TypeParametersContextExt<'a>}

impl<'input> TypeParametersContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<TypeParametersContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,TypeParametersContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait TypeParametersContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<TypeParametersContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token LANGLE
/// Returns `None` if there is no child corresponding to token LANGLE
fn LANGLE(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(LANGLE, 0)
}
fn typeParameter_all(&self) ->  Vec<Rc<TypeParameterContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn typeParameter(&self, i: usize) -> Option<Rc<TypeParameterContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves first TerminalNode corresponding to token RANGLE
/// Returns `None` if there is no child corresponding to token RANGLE
fn RANGLE(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(RANGLE, 0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}

}

impl<'input> TypeParametersContextAttrs<'input> for TypeParametersContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn typeParameters(&mut self,)
	-> Result<Rc<TypeParametersContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = TypeParametersContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 42, RULE_typeParameters);
        let mut _localctx: Rc<TypeParametersContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(781);
			recog.base.match_token(LANGLE,&mut recog.err_handler)?;

			recog.base.set_state(785);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(75,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					recog.base.set_state(782);
					recog.base.match_token(NL,&mut recog.err_handler)?;

					}
					} 
				}
				recog.base.set_state(787);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(75,&mut recog.base)?;
			}
			/*InvokeRule typeParameter*/
			recog.base.set_state(788);
			recog.typeParameter()?;

			recog.base.set_state(805);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(78,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					recog.base.set_state(792);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(789);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(794);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(795);
					recog.base.match_token(COMMA,&mut recog.err_handler)?;

					recog.base.set_state(799);
					recog.err_handler.sync(&mut recog.base)?;
					_alt = recog.interpreter.adaptive_predict(77,&mut recog.base)?;
					while { _alt!=2 && _alt!=INVALID_ALT } {
						if _alt==1 {
							{
							{
							recog.base.set_state(796);
							recog.base.match_token(NL,&mut recog.err_handler)?;

							}
							} 
						}
						recog.base.set_state(801);
						recog.err_handler.sync(&mut recog.base)?;
						_alt = recog.interpreter.adaptive_predict(77,&mut recog.base)?;
					}
					/*InvokeRule typeParameter*/
					recog.base.set_state(802);
					recog.typeParameter()?;

					}
					} 
				}
				recog.base.set_state(807);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(78,&mut recog.base)?;
			}
			recog.base.set_state(815);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(80,&mut recog.base)? {
				x if x == 1=>{
					{
					recog.base.set_state(811);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(808);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(813);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(814);
					recog.base.match_token(COMMA,&mut recog.err_handler)?;

					}
				}

				_ => {}
			}
			recog.base.set_state(820);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(817);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(822);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(823);
			recog.base.match_token(RANGLE,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- typeParameter ----------------
pub type TypeParameterContextAll<'input> = TypeParameterContext<'input>;


pub type TypeParameterContext<'input> = BaseParserRuleContext<'input,TypeParameterContextExt<'input>>;

#[derive(Clone)]
pub struct TypeParameterContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for TypeParameterContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for TypeParameterContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_typeParameter(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_typeParameter(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for TypeParameterContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_typeParameter(self);
	}
}

impl<'input> CustomRuleContext<'input> for TypeParameterContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_typeParameter }
	//fn type_rule_index() -> usize where Self: Sized { RULE_typeParameter }
}
antlr_rust::type_id!{TypeParameterContextExt<'a>}

impl<'input> TypeParameterContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<TypeParameterContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,TypeParameterContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait TypeParameterContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<TypeParameterContextExt<'input>>{

fn simpleIdentifier(&self) -> Option<Rc<SimpleIdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn typeParameterModifiers(&self) -> Option<Rc<TypeParameterModifiersContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}
/// Retrieves first TerminalNode corresponding to token COLON
/// Returns `None` if there is no child corresponding to token COLON
fn COLON(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(COLON, 0)
}
fn type(&self) -> Option<Rc<TypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> TypeParameterContextAttrs<'input> for TypeParameterContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn typeParameter(&mut self,)
	-> Result<Rc<TypeParameterContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = TypeParameterContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 44, RULE_typeParameter);
        let mut _localctx: Rc<TypeParameterContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(826);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(82,&mut recog.base)? {
				x if x == 1=>{
					{
					/*InvokeRule typeParameterModifiers*/
					recog.base.set_state(825);
					recog.typeParameterModifiers()?;

					}
				}

				_ => {}
			}
			recog.base.set_state(831);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(828);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(833);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			/*InvokeRule simpleIdentifier*/
			recog.base.set_state(834);
			recog.simpleIdentifier()?;

			recog.base.set_state(849);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(86,&mut recog.base)? {
				x if x == 1=>{
					{
					recog.base.set_state(838);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(835);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(840);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(841);
					recog.base.match_token(COLON,&mut recog.err_handler)?;

					recog.base.set_state(845);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(842);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(847);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					/*InvokeRule type*/
					recog.base.set_state(848);
					recog.type()?;

					}
				}

				_ => {}
			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- typeConstraints ----------------
pub type TypeConstraintsContextAll<'input> = TypeConstraintsContext<'input>;


pub type TypeConstraintsContext<'input> = BaseParserRuleContext<'input,TypeConstraintsContextExt<'input>>;

#[derive(Clone)]
pub struct TypeConstraintsContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for TypeConstraintsContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for TypeConstraintsContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_typeConstraints(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_typeConstraints(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for TypeConstraintsContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_typeConstraints(self);
	}
}

impl<'input> CustomRuleContext<'input> for TypeConstraintsContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_typeConstraints }
	//fn type_rule_index() -> usize where Self: Sized { RULE_typeConstraints }
}
antlr_rust::type_id!{TypeConstraintsContextExt<'a>}

impl<'input> TypeConstraintsContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<TypeConstraintsContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,TypeConstraintsContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait TypeConstraintsContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<TypeConstraintsContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token WHERE
/// Returns `None` if there is no child corresponding to token WHERE
fn WHERE(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(WHERE, 0)
}
fn typeConstraint_all(&self) ->  Vec<Rc<TypeConstraintContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn typeConstraint(&self, i: usize) -> Option<Rc<TypeConstraintContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}

}

impl<'input> TypeConstraintsContextAttrs<'input> for TypeConstraintsContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn typeConstraints(&mut self,)
	-> Result<Rc<TypeConstraintsContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = TypeConstraintsContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 46, RULE_typeConstraints);
        let mut _localctx: Rc<TypeConstraintsContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(851);
			recog.base.match_token(WHERE,&mut recog.err_handler)?;

			recog.base.set_state(855);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(852);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(857);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			/*InvokeRule typeConstraint*/
			recog.base.set_state(858);
			recog.typeConstraint()?;

			recog.base.set_state(875);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(90,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					recog.base.set_state(862);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(859);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(864);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(865);
					recog.base.match_token(COMMA,&mut recog.err_handler)?;

					recog.base.set_state(869);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(866);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(871);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					/*InvokeRule typeConstraint*/
					recog.base.set_state(872);
					recog.typeConstraint()?;

					}
					} 
				}
				recog.base.set_state(877);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(90,&mut recog.base)?;
			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- typeConstraint ----------------
pub type TypeConstraintContextAll<'input> = TypeConstraintContext<'input>;


pub type TypeConstraintContext<'input> = BaseParserRuleContext<'input,TypeConstraintContextExt<'input>>;

#[derive(Clone)]
pub struct TypeConstraintContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for TypeConstraintContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for TypeConstraintContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_typeConstraint(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_typeConstraint(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for TypeConstraintContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_typeConstraint(self);
	}
}

impl<'input> CustomRuleContext<'input> for TypeConstraintContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_typeConstraint }
	//fn type_rule_index() -> usize where Self: Sized { RULE_typeConstraint }
}
antlr_rust::type_id!{TypeConstraintContextExt<'a>}

impl<'input> TypeConstraintContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<TypeConstraintContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,TypeConstraintContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait TypeConstraintContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<TypeConstraintContextExt<'input>>{

fn simpleIdentifier(&self) -> Option<Rc<SimpleIdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COLON
/// Returns `None` if there is no child corresponding to token COLON
fn COLON(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(COLON, 0)
}
fn type(&self) -> Option<Rc<TypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn annotation_all(&self) ->  Vec<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}

}

impl<'input> TypeConstraintContextAttrs<'input> for TypeConstraintContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn typeConstraint(&mut self,)
	-> Result<Rc<TypeConstraintContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = TypeConstraintContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 48, RULE_typeConstraint);
        let mut _localctx: Rc<TypeConstraintContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(881);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==AT_NO_WS || _la==AT_PRE_WS {
				{
				{
				/*InvokeRule annotation*/
				recog.base.set_state(878);
				recog.annotation()?;

				}
				}
				recog.base.set_state(883);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			/*InvokeRule simpleIdentifier*/
			recog.base.set_state(884);
			recog.simpleIdentifier()?;

			recog.base.set_state(888);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(885);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(890);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(891);
			recog.base.match_token(COLON,&mut recog.err_handler)?;

			recog.base.set_state(895);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(892);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(897);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			/*InvokeRule type*/
			recog.base.set_state(898);
			recog.type()?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- classMemberDeclarations ----------------
pub type ClassMemberDeclarationsContextAll<'input> = ClassMemberDeclarationsContext<'input>;


pub type ClassMemberDeclarationsContext<'input> = BaseParserRuleContext<'input,ClassMemberDeclarationsContextExt<'input>>;

#[derive(Clone)]
pub struct ClassMemberDeclarationsContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for ClassMemberDeclarationsContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for ClassMemberDeclarationsContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_classMemberDeclarations(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_classMemberDeclarations(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for ClassMemberDeclarationsContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_classMemberDeclarations(self);
	}
}

impl<'input> CustomRuleContext<'input> for ClassMemberDeclarationsContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_classMemberDeclarations }
	//fn type_rule_index() -> usize where Self: Sized { RULE_classMemberDeclarations }
}
antlr_rust::type_id!{ClassMemberDeclarationsContextExt<'a>}

impl<'input> ClassMemberDeclarationsContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ClassMemberDeclarationsContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ClassMemberDeclarationsContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ClassMemberDeclarationsContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<ClassMemberDeclarationsContextExt<'input>>{

fn classMemberDeclaration_all(&self) ->  Vec<Rc<ClassMemberDeclarationContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn classMemberDeclaration(&self, i: usize) -> Option<Rc<ClassMemberDeclarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn semis_all(&self) ->  Vec<Rc<SemisContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn semis(&self, i: usize) -> Option<Rc<SemisContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> ClassMemberDeclarationsContextAttrs<'input> for ClassMemberDeclarationsContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn classMemberDeclarations(&mut self,)
	-> Result<Rc<ClassMemberDeclarationsContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ClassMemberDeclarationsContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 50, RULE_classMemberDeclarations);
        let mut _localctx: Rc<ClassMemberDeclarationsContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(906);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==AT_NO_WS || _la==AT_PRE_WS || ((((_la - 74)) & !0x3f) == 0 && ((1usize << (_la - 74)) & ((1usize << (CLASS - 74)) | (1usize << (INTERFACE - 74)) | (1usize << (FUN - 74)) | (1usize << (OBJECT - 74)) | (1usize << (VAL - 74)) | (1usize << (VAR - 74)) | (1usize << (TYPE_ALIAS - 74)) | (1usize << (CONSTRUCTOR - 74)) | (1usize << (COMPANION - 74)) | (1usize << (INIT - 74)) | (1usize << (PUBLIC - 74)) | (1usize << (PRIVATE - 74)) | (1usize << (PROTECTED - 74)) | (1usize << (INTERNAL - 74)) | (1usize << (ENUM - 74)) | (1usize << (SEALED - 74)) | (1usize << (ANNOTATION - 74)) | (1usize << (DATA - 74)) | (1usize << (INNER - 74)) | (1usize << (VALUE - 74)) | (1usize << (TAILREC - 74)) | (1usize << (OPERATOR - 74)) | (1usize << (INLINE - 74)) | (1usize << (INFIX - 74)) | (1usize << (EXTERNAL - 74)) | (1usize << (SUSPEND - 74)) | (1usize << (OVERRIDE - 74)) | (1usize << (ABSTRACT - 74)) | (1usize << (FINAL - 74)) | (1usize << (OPEN - 74)) | (1usize << (CONST - 74)) | (1usize << (LATEINIT - 74)) | (1usize << (VARARG - 74)) | (1usize << (NOINLINE - 74)) | (1usize << (CROSSINLINE - 74)) | (1usize << (EXPECT - 74)) | (1usize << (ACTUAL - 74)))) != 0) {
				{
				{
				/*InvokeRule classMemberDeclaration*/
				recog.base.set_state(900);
				recog.classMemberDeclaration()?;

				recog.base.set_state(902);
				recog.err_handler.sync(&mut recog.base)?;
				match  recog.interpreter.adaptive_predict(94,&mut recog.base)? {
					x if x == 1=>{
						{
						/*InvokeRule semis*/
						recog.base.set_state(901);
						recog.semis()?;

						}
					}

					_ => {}
				}
				}
				}
				recog.base.set_state(908);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- classMemberDeclaration ----------------
pub type ClassMemberDeclarationContextAll<'input> = ClassMemberDeclarationContext<'input>;


pub type ClassMemberDeclarationContext<'input> = BaseParserRuleContext<'input,ClassMemberDeclarationContextExt<'input>>;

#[derive(Clone)]
pub struct ClassMemberDeclarationContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for ClassMemberDeclarationContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for ClassMemberDeclarationContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_classMemberDeclaration(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_classMemberDeclaration(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for ClassMemberDeclarationContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_classMemberDeclaration(self);
	}
}

impl<'input> CustomRuleContext<'input> for ClassMemberDeclarationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_classMemberDeclaration }
	//fn type_rule_index() -> usize where Self: Sized { RULE_classMemberDeclaration }
}
antlr_rust::type_id!{ClassMemberDeclarationContextExt<'a>}

impl<'input> ClassMemberDeclarationContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ClassMemberDeclarationContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ClassMemberDeclarationContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ClassMemberDeclarationContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<ClassMemberDeclarationContextExt<'input>>{

fn declaration(&self) -> Option<Rc<DeclarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn companionObject(&self) -> Option<Rc<CompanionObjectContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn anonymousInitializer(&self) -> Option<Rc<AnonymousInitializerContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn secondaryConstructor(&self) -> Option<Rc<SecondaryConstructorContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ClassMemberDeclarationContextAttrs<'input> for ClassMemberDeclarationContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn classMemberDeclaration(&mut self,)
	-> Result<Rc<ClassMemberDeclarationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ClassMemberDeclarationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 52, RULE_classMemberDeclaration);
        let mut _localctx: Rc<ClassMemberDeclarationContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			recog.base.set_state(913);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(96,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule declaration*/
					recog.base.set_state(909);
					recog.declaration()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule companionObject*/
					recog.base.set_state(910);
					recog.companionObject()?;

					}
				}
			,
				3 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					/*InvokeRule anonymousInitializer*/
					recog.base.set_state(911);
					recog.anonymousInitializer()?;

					}
				}
			,
				4 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 4);
					recog.base.enter_outer_alt(None, 4);
					{
					/*InvokeRule secondaryConstructor*/
					recog.base.set_state(912);
					recog.secondaryConstructor()?;

					}
				}

				_ => {}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- anonymousInitializer ----------------
pub type AnonymousInitializerContextAll<'input> = AnonymousInitializerContext<'input>;


pub type AnonymousInitializerContext<'input> = BaseParserRuleContext<'input,AnonymousInitializerContextExt<'input>>;

#[derive(Clone)]
pub struct AnonymousInitializerContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for AnonymousInitializerContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for AnonymousInitializerContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_anonymousInitializer(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_anonymousInitializer(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for AnonymousInitializerContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_anonymousInitializer(self);
	}
}

impl<'input> CustomRuleContext<'input> for AnonymousInitializerContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_anonymousInitializer }
	//fn type_rule_index() -> usize where Self: Sized { RULE_anonymousInitializer }
}
antlr_rust::type_id!{AnonymousInitializerContextExt<'a>}

impl<'input> AnonymousInitializerContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AnonymousInitializerContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AnonymousInitializerContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AnonymousInitializerContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<AnonymousInitializerContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token INIT
/// Returns `None` if there is no child corresponding to token INIT
fn INIT(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(INIT, 0)
}
fn block(&self) -> Option<Rc<BlockContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}

}

impl<'input> AnonymousInitializerContextAttrs<'input> for AnonymousInitializerContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn anonymousInitializer(&mut self,)
	-> Result<Rc<AnonymousInitializerContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AnonymousInitializerContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 54, RULE_anonymousInitializer);
        let mut _localctx: Rc<AnonymousInitializerContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(915);
			recog.base.match_token(INIT,&mut recog.err_handler)?;

			recog.base.set_state(919);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(916);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(921);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			/*InvokeRule block*/
			recog.base.set_state(922);
			recog.block()?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- companionObject ----------------
pub type CompanionObjectContextAll<'input> = CompanionObjectContext<'input>;


pub type CompanionObjectContext<'input> = BaseParserRuleContext<'input,CompanionObjectContextExt<'input>>;

#[derive(Clone)]
pub struct CompanionObjectContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for CompanionObjectContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for CompanionObjectContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_companionObject(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_companionObject(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for CompanionObjectContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_companionObject(self);
	}
}

impl<'input> CustomRuleContext<'input> for CompanionObjectContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_companionObject }
	//fn type_rule_index() -> usize where Self: Sized { RULE_companionObject }
}
antlr_rust::type_id!{CompanionObjectContextExt<'a>}

impl<'input> CompanionObjectContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<CompanionObjectContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,CompanionObjectContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait CompanionObjectContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<CompanionObjectContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token COMPANION
/// Returns `None` if there is no child corresponding to token COMPANION
fn COMPANION(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(COMPANION, 0)
}
/// Retrieves first TerminalNode corresponding to token OBJECT
/// Returns `None` if there is no child corresponding to token OBJECT
fn OBJECT(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(OBJECT, 0)
}
fn modifiers(&self) -> Option<Rc<ModifiersContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}
/// Retrieves first TerminalNode corresponding to token DATA
/// Returns `None` if there is no child corresponding to token DATA
fn DATA(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(DATA, 0)
}
fn simpleIdentifier(&self) -> Option<Rc<SimpleIdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COLON
/// Returns `None` if there is no child corresponding to token COLON
fn COLON(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(COLON, 0)
}
fn delegationSpecifiers(&self) -> Option<Rc<DelegationSpecifiersContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn classBody(&self) -> Option<Rc<ClassBodyContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> CompanionObjectContextAttrs<'input> for CompanionObjectContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn companionObject(&mut self,)
	-> Result<Rc<CompanionObjectContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = CompanionObjectContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 56, RULE_companionObject);
        let mut _localctx: Rc<CompanionObjectContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(925);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==AT_NO_WS || _la==AT_PRE_WS || ((((_la - 109)) & !0x3f) == 0 && ((1usize << (_la - 109)) & ((1usize << (PUBLIC - 109)) | (1usize << (PRIVATE - 109)) | (1usize << (PROTECTED - 109)) | (1usize << (INTERNAL - 109)) | (1usize << (ENUM - 109)) | (1usize << (SEALED - 109)) | (1usize << (ANNOTATION - 109)) | (1usize << (DATA - 109)) | (1usize << (INNER - 109)) | (1usize << (VALUE - 109)) | (1usize << (TAILREC - 109)) | (1usize << (OPERATOR - 109)) | (1usize << (INLINE - 109)) | (1usize << (INFIX - 109)) | (1usize << (EXTERNAL - 109)) | (1usize << (SUSPEND - 109)) | (1usize << (OVERRIDE - 109)) | (1usize << (ABSTRACT - 109)) | (1usize << (FINAL - 109)) | (1usize << (OPEN - 109)) | (1usize << (CONST - 109)) | (1usize << (LATEINIT - 109)) | (1usize << (VARARG - 109)) | (1usize << (NOINLINE - 109)) | (1usize << (CROSSINLINE - 109)) | (1usize << (EXPECT - 109)) | (1usize << (ACTUAL - 109)))) != 0) {
				{
				/*InvokeRule modifiers*/
				recog.base.set_state(924);
				recog.modifiers()?;

				}
			}

			recog.base.set_state(927);
			recog.base.match_token(COMPANION,&mut recog.err_handler)?;

			recog.base.set_state(931);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(99,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					recog.base.set_state(928);
					recog.base.match_token(NL,&mut recog.err_handler)?;

					}
					} 
				}
				recog.base.set_state(933);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(99,&mut recog.base)?;
			}
			recog.base.set_state(935);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==DATA {
				{
				recog.base.set_state(934);
				recog.base.match_token(DATA,&mut recog.err_handler)?;

				}
			}

			recog.base.set_state(940);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(937);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(942);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(943);
			recog.base.match_token(OBJECT,&mut recog.err_handler)?;

			recog.base.set_state(951);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(103,&mut recog.base)? {
				x if x == 1=>{
					{
					recog.base.set_state(947);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(944);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(949);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					/*InvokeRule simpleIdentifier*/
					recog.base.set_state(950);
					recog.simpleIdentifier()?;

					}
				}

				_ => {}
			}
			recog.base.set_state(967);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(106,&mut recog.base)? {
				x if x == 1=>{
					{
					recog.base.set_state(956);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(953);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(958);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(959);
					recog.base.match_token(COLON,&mut recog.err_handler)?;

					recog.base.set_state(963);
					recog.err_handler.sync(&mut recog.base)?;
					_alt = recog.interpreter.adaptive_predict(105,&mut recog.base)?;
					while { _alt!=2 && _alt!=INVALID_ALT } {
						if _alt==1 {
							{
							{
							recog.base.set_state(960);
							recog.base.match_token(NL,&mut recog.err_handler)?;

							}
							} 
						}
						recog.base.set_state(965);
						recog.err_handler.sync(&mut recog.base)?;
						_alt = recog.interpreter.adaptive_predict(105,&mut recog.base)?;
					}
					/*InvokeRule delegationSpecifiers*/
					recog.base.set_state(966);
					recog.delegationSpecifiers()?;

					}
				}

				_ => {}
			}
			recog.base.set_state(976);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(108,&mut recog.base)? {
				x if x == 1=>{
					{
					recog.base.set_state(972);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(969);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(974);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					/*InvokeRule classBody*/
					recog.base.set_state(975);
					recog.classBody()?;

					}
				}

				_ => {}
			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- functionValueParameters ----------------
pub type FunctionValueParametersContextAll<'input> = FunctionValueParametersContext<'input>;


pub type FunctionValueParametersContext<'input> = BaseParserRuleContext<'input,FunctionValueParametersContextExt<'input>>;

#[derive(Clone)]
pub struct FunctionValueParametersContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for FunctionValueParametersContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for FunctionValueParametersContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_functionValueParameters(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_functionValueParameters(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for FunctionValueParametersContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_functionValueParameters(self);
	}
}

impl<'input> CustomRuleContext<'input> for FunctionValueParametersContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_functionValueParameters }
	//fn type_rule_index() -> usize where Self: Sized { RULE_functionValueParameters }
}
antlr_rust::type_id!{FunctionValueParametersContextExt<'a>}

impl<'input> FunctionValueParametersContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<FunctionValueParametersContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,FunctionValueParametersContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait FunctionValueParametersContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<FunctionValueParametersContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token LPAREN
/// Returns `None` if there is no child corresponding to token LPAREN
fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(LPAREN, 0)
}
/// Retrieves first TerminalNode corresponding to token RPAREN
/// Returns `None` if there is no child corresponding to token RPAREN
fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(RPAREN, 0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}
fn functionValueParameter_all(&self) ->  Vec<Rc<FunctionValueParameterContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn functionValueParameter(&self, i: usize) -> Option<Rc<FunctionValueParameterContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}

}

impl<'input> FunctionValueParametersContextAttrs<'input> for FunctionValueParametersContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn functionValueParameters(&mut self,)
	-> Result<Rc<FunctionValueParametersContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = FunctionValueParametersContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 58, RULE_functionValueParameters);
        let mut _localctx: Rc<FunctionValueParametersContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(978);
			recog.base.match_token(LPAREN,&mut recog.err_handler)?;

			recog.base.set_state(982);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(109,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					recog.base.set_state(979);
					recog.base.match_token(NL,&mut recog.err_handler)?;

					}
					} 
				}
				recog.base.set_state(984);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(109,&mut recog.base)?;
			}
			recog.base.set_state(1014);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if ((((_la - 41)) & !0x3f) == 0 && ((1usize << (_la - 41)) & ((1usize << (AT_NO_WS - 41)) | (1usize << (AT_PRE_WS - 41)) | (1usize << (FILE - 41)) | (1usize << (FIELD - 41)) | (1usize << (PROPERTY - 41)) | (1usize << (GET - 41)) | (1usize << (SET - 41)) | (1usize << (RECEIVER - 41)) | (1usize << (PARAM - 41)) | (1usize << (SETPARAM - 41)) | (1usize << (DELEGATE - 41)) | (1usize << (IMPORT - 41)) | (1usize << (CONSTRUCTOR - 41)) | (1usize << (BY - 41)) | (1usize << (COMPANION - 41)) | (1usize << (INIT - 41)) | (1usize << (WHERE - 41)) | (1usize << (CATCH - 41)) | (1usize << (FINALLY - 41)))) != 0) || ((((_la - 107)) & !0x3f) == 0 && ((1usize << (_la - 107)) & ((1usize << (OUT - 107)) | (1usize << (DYNAMIC - 107)) | (1usize << (PUBLIC - 107)) | (1usize << (PRIVATE - 107)) | (1usize << (PROTECTED - 107)) | (1usize << (INTERNAL - 107)) | (1usize << (ENUM - 107)) | (1usize << (SEALED - 107)) | (1usize << (ANNOTATION - 107)) | (1usize << (DATA - 107)) | (1usize << (INNER - 107)) | (1usize << (VALUE - 107)) | (1usize << (TAILREC - 107)) | (1usize << (OPERATOR - 107)) | (1usize << (INLINE - 107)) | (1usize << (INFIX - 107)) | (1usize << (EXTERNAL - 107)) | (1usize << (SUSPEND - 107)) | (1usize << (OVERRIDE - 107)) | (1usize << (ABSTRACT - 107)) | (1usize << (FINAL - 107)) | (1usize << (OPEN - 107)) | (1usize << (CONST - 107)) | (1usize << (LATEINIT - 107)) | (1usize << (VARARG - 107)) | (1usize << (NOINLINE - 107)) | (1usize << (CROSSINLINE - 107)) | (1usize << (REIFIED - 107)) | (1usize << (EXPECT - 107)) | (1usize << (ACTUAL - 107)) | (1usize << (Identifier - 107)))) != 0) {
				{
				/*InvokeRule functionValueParameter*/
				recog.base.set_state(985);
				recog.functionValueParameter()?;

				recog.base.set_state(1002);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(112,&mut recog.base)?;
				while { _alt!=2 && _alt!=INVALID_ALT } {
					if _alt==1 {
						{
						{
						recog.base.set_state(989);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
						while _la==NL {
							{
							{
							recog.base.set_state(986);
							recog.base.match_token(NL,&mut recog.err_handler)?;

							}
							}
							recog.base.set_state(991);
							recog.err_handler.sync(&mut recog.base)?;
							_la = recog.base.input.la(1);
						}
						recog.base.set_state(992);
						recog.base.match_token(COMMA,&mut recog.err_handler)?;

						recog.base.set_state(996);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
						while _la==NL {
							{
							{
							recog.base.set_state(993);
							recog.base.match_token(NL,&mut recog.err_handler)?;

							}
							}
							recog.base.set_state(998);
							recog.err_handler.sync(&mut recog.base)?;
							_la = recog.base.input.la(1);
						}
						/*InvokeRule functionValueParameter*/
						recog.base.set_state(999);
						recog.functionValueParameter()?;

						}
						} 
					}
					recog.base.set_state(1004);
					recog.err_handler.sync(&mut recog.base)?;
					_alt = recog.interpreter.adaptive_predict(112,&mut recog.base)?;
				}
				recog.base.set_state(1012);
				recog.err_handler.sync(&mut recog.base)?;
				match  recog.interpreter.adaptive_predict(114,&mut recog.base)? {
					x if x == 1=>{
						{
						recog.base.set_state(1008);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
						while _la==NL {
							{
							{
							recog.base.set_state(1005);
							recog.base.match_token(NL,&mut recog.err_handler)?;

							}
							}
							recog.base.set_state(1010);
							recog.err_handler.sync(&mut recog.base)?;
							_la = recog.base.input.la(1);
						}
						recog.base.set_state(1011);
						recog.base.match_token(COMMA,&mut recog.err_handler)?;

						}
					}

					_ => {}
				}
				}
			}

			recog.base.set_state(1019);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(1016);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(1021);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(1022);
			recog.base.match_token(RPAREN,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- functionValueParameter ----------------
pub type FunctionValueParameterContextAll<'input> = FunctionValueParameterContext<'input>;


pub type FunctionValueParameterContext<'input> = BaseParserRuleContext<'input,FunctionValueParameterContextExt<'input>>;

#[derive(Clone)]
pub struct FunctionValueParameterContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for FunctionValueParameterContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for FunctionValueParameterContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_functionValueParameter(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_functionValueParameter(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for FunctionValueParameterContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_functionValueParameter(self);
	}
}

impl<'input> CustomRuleContext<'input> for FunctionValueParameterContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_functionValueParameter }
	//fn type_rule_index() -> usize where Self: Sized { RULE_functionValueParameter }
}
antlr_rust::type_id!{FunctionValueParameterContextExt<'a>}

impl<'input> FunctionValueParameterContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<FunctionValueParameterContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,FunctionValueParameterContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait FunctionValueParameterContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<FunctionValueParameterContextExt<'input>>{

fn parameter(&self) -> Option<Rc<ParameterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn parameterModifiers(&self) -> Option<Rc<ParameterModifiersContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token ASSIGNMENT
/// Returns `None` if there is no child corresponding to token ASSIGNMENT
fn ASSIGNMENT(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(ASSIGNMENT, 0)
}
fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}

}

impl<'input> FunctionValueParameterContextAttrs<'input> for FunctionValueParameterContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn functionValueParameter(&mut self,)
	-> Result<Rc<FunctionValueParameterContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = FunctionValueParameterContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 60, RULE_functionValueParameter);
        let mut _localctx: Rc<FunctionValueParameterContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1025);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(117,&mut recog.base)? {
				x if x == 1=>{
					{
					/*InvokeRule parameterModifiers*/
					recog.base.set_state(1024);
					recog.parameterModifiers()?;

					}
				}

				_ => {}
			}
			/*InvokeRule parameter*/
			recog.base.set_state(1027);
			recog.parameter()?;

			recog.base.set_state(1042);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(120,&mut recog.base)? {
				x if x == 1=>{
					{
					recog.base.set_state(1031);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(1028);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(1033);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(1034);
					recog.base.match_token(ASSIGNMENT,&mut recog.err_handler)?;

					recog.base.set_state(1038);
					recog.err_handler.sync(&mut recog.base)?;
					_alt = recog.interpreter.adaptive_predict(119,&mut recog.base)?;
					while { _alt!=2 && _alt!=INVALID_ALT } {
						if _alt==1 {
							{
							{
							recog.base.set_state(1035);
							recog.base.match_token(NL,&mut recog.err_handler)?;

							}
							} 
						}
						recog.base.set_state(1040);
						recog.err_handler.sync(&mut recog.base)?;
						_alt = recog.interpreter.adaptive_predict(119,&mut recog.base)?;
					}
					/*InvokeRule expression*/
					recog.base.set_state(1041);
					recog.expression()?;

					}
				}

				_ => {}
			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- functionDeclaration ----------------
pub type FunctionDeclarationContextAll<'input> = FunctionDeclarationContext<'input>;


pub type FunctionDeclarationContext<'input> = BaseParserRuleContext<'input,FunctionDeclarationContextExt<'input>>;

#[derive(Clone)]
pub struct FunctionDeclarationContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for FunctionDeclarationContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for FunctionDeclarationContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_functionDeclaration(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_functionDeclaration(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for FunctionDeclarationContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_functionDeclaration(self);
	}
}

impl<'input> CustomRuleContext<'input> for FunctionDeclarationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_functionDeclaration }
	//fn type_rule_index() -> usize where Self: Sized { RULE_functionDeclaration }
}
antlr_rust::type_id!{FunctionDeclarationContextExt<'a>}

impl<'input> FunctionDeclarationContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<FunctionDeclarationContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,FunctionDeclarationContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait FunctionDeclarationContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<FunctionDeclarationContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token FUN
/// Returns `None` if there is no child corresponding to token FUN
fn FUN(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(FUN, 0)
}
fn simpleIdentifier(&self) -> Option<Rc<SimpleIdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn functionValueParameters(&self) -> Option<Rc<FunctionValueParametersContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn modifiers(&self) -> Option<Rc<ModifiersContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn typeParameters(&self) -> Option<Rc<TypeParametersContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn receiverType(&self) -> Option<Rc<ReceiverTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token DOT
/// Returns `None` if there is no child corresponding to token DOT
fn DOT(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(DOT, 0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}
/// Retrieves first TerminalNode corresponding to token COLON
/// Returns `None` if there is no child corresponding to token COLON
fn COLON(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(COLON, 0)
}
fn type(&self) -> Option<Rc<TypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn typeConstraints(&self) -> Option<Rc<TypeConstraintsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn functionBody(&self) -> Option<Rc<FunctionBodyContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> FunctionDeclarationContextAttrs<'input> for FunctionDeclarationContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn functionDeclaration(&mut self,)
	-> Result<Rc<FunctionDeclarationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = FunctionDeclarationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 62, RULE_functionDeclaration);
        let mut _localctx: Rc<FunctionDeclarationContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1045);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==AT_NO_WS || _la==AT_PRE_WS || ((((_la - 109)) & !0x3f) == 0 && ((1usize << (_la - 109)) & ((1usize << (PUBLIC - 109)) | (1usize << (PRIVATE - 109)) | (1usize << (PROTECTED - 109)) | (1usize << (INTERNAL - 109)) | (1usize << (ENUM - 109)) | (1usize << (SEALED - 109)) | (1usize << (ANNOTATION - 109)) | (1usize << (DATA - 109)) | (1usize << (INNER - 109)) | (1usize << (VALUE - 109)) | (1usize << (TAILREC - 109)) | (1usize << (OPERATOR - 109)) | (1usize << (INLINE - 109)) | (1usize << (INFIX - 109)) | (1usize << (EXTERNAL - 109)) | (1usize << (SUSPEND - 109)) | (1usize << (OVERRIDE - 109)) | (1usize << (ABSTRACT - 109)) | (1usize << (FINAL - 109)) | (1usize << (OPEN - 109)) | (1usize << (CONST - 109)) | (1usize << (LATEINIT - 109)) | (1usize << (VARARG - 109)) | (1usize << (NOINLINE - 109)) | (1usize << (CROSSINLINE - 109)) | (1usize << (EXPECT - 109)) | (1usize << (ACTUAL - 109)))) != 0) {
				{
				/*InvokeRule modifiers*/
				recog.base.set_state(1044);
				recog.modifiers()?;

				}
			}

			recog.base.set_state(1047);
			recog.base.match_token(FUN,&mut recog.err_handler)?;

			recog.base.set_state(1055);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(123,&mut recog.base)? {
				x if x == 1=>{
					{
					recog.base.set_state(1051);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(1048);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(1053);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					/*InvokeRule typeParameters*/
					recog.base.set_state(1054);
					recog.typeParameters()?;

					}
				}

				_ => {}
			}
			recog.base.set_state(1072);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(126,&mut recog.base)? {
				x if x == 1=>{
					{
					recog.base.set_state(1060);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(1057);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(1062);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					/*InvokeRule receiverType*/
					recog.base.set_state(1063);
					recog.receiverType()?;

					recog.base.set_state(1067);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(1064);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(1069);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(1070);
					recog.base.match_token(DOT,&mut recog.err_handler)?;

					}
				}

				_ => {}
			}
			recog.base.set_state(1077);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(1074);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(1079);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			/*InvokeRule simpleIdentifier*/
			recog.base.set_state(1080);
			recog.simpleIdentifier()?;

			recog.base.set_state(1084);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(1081);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(1086);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			/*InvokeRule functionValueParameters*/
			recog.base.set_state(1087);
			recog.functionValueParameters()?;

			recog.base.set_state(1102);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(131,&mut recog.base)? {
				x if x == 1=>{
					{
					recog.base.set_state(1091);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(1088);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(1093);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(1094);
					recog.base.match_token(COLON,&mut recog.err_handler)?;

					recog.base.set_state(1098);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(1095);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(1100);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					/*InvokeRule type*/
					recog.base.set_state(1101);
					recog.type()?;

					}
				}

				_ => {}
			}
			recog.base.set_state(1111);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(133,&mut recog.base)? {
				x if x == 1=>{
					{
					recog.base.set_state(1107);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(1104);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(1109);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					/*InvokeRule typeConstraints*/
					recog.base.set_state(1110);
					recog.typeConstraints()?;

					}
				}

				_ => {}
			}
			recog.base.set_state(1120);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(135,&mut recog.base)? {
				x if x == 1=>{
					{
					recog.base.set_state(1116);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(1113);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(1118);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					/*InvokeRule functionBody*/
					recog.base.set_state(1119);
					recog.functionBody()?;

					}
				}

				_ => {}
			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- functionBody ----------------
pub type FunctionBodyContextAll<'input> = FunctionBodyContext<'input>;


pub type FunctionBodyContext<'input> = BaseParserRuleContext<'input,FunctionBodyContextExt<'input>>;

#[derive(Clone)]
pub struct FunctionBodyContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for FunctionBodyContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for FunctionBodyContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_functionBody(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_functionBody(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for FunctionBodyContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_functionBody(self);
	}
}

impl<'input> CustomRuleContext<'input> for FunctionBodyContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_functionBody }
	//fn type_rule_index() -> usize where Self: Sized { RULE_functionBody }
}
antlr_rust::type_id!{FunctionBodyContextExt<'a>}

impl<'input> FunctionBodyContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<FunctionBodyContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,FunctionBodyContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait FunctionBodyContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<FunctionBodyContextExt<'input>>{

fn block(&self) -> Option<Rc<BlockContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token ASSIGNMENT
/// Returns `None` if there is no child corresponding to token ASSIGNMENT
fn ASSIGNMENT(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(ASSIGNMENT, 0)
}
fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}

}

impl<'input> FunctionBodyContextAttrs<'input> for FunctionBodyContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn functionBody(&mut self,)
	-> Result<Rc<FunctionBodyContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = FunctionBodyContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 64, RULE_functionBody);
        let mut _localctx: Rc<FunctionBodyContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			let mut _alt: isize;
			recog.base.set_state(1131);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 LCURL 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule block*/
					recog.base.set_state(1122);
					recog.block()?;

					}
				}

			 ASSIGNMENT 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(1123);
					recog.base.match_token(ASSIGNMENT,&mut recog.err_handler)?;

					recog.base.set_state(1127);
					recog.err_handler.sync(&mut recog.base)?;
					_alt = recog.interpreter.adaptive_predict(136,&mut recog.base)?;
					while { _alt!=2 && _alt!=INVALID_ALT } {
						if _alt==1 {
							{
							{
							recog.base.set_state(1124);
							recog.base.match_token(NL,&mut recog.err_handler)?;

							}
							} 
						}
						recog.base.set_state(1129);
						recog.err_handler.sync(&mut recog.base)?;
						_alt = recog.interpreter.adaptive_predict(136,&mut recog.base)?;
					}
					/*InvokeRule expression*/
					recog.base.set_state(1130);
					recog.expression()?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- variableDeclaration ----------------
pub type VariableDeclarationContextAll<'input> = VariableDeclarationContext<'input>;


pub type VariableDeclarationContext<'input> = BaseParserRuleContext<'input,VariableDeclarationContextExt<'input>>;

#[derive(Clone)]
pub struct VariableDeclarationContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for VariableDeclarationContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for VariableDeclarationContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_variableDeclaration(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_variableDeclaration(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for VariableDeclarationContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_variableDeclaration(self);
	}
}

impl<'input> CustomRuleContext<'input> for VariableDeclarationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_variableDeclaration }
	//fn type_rule_index() -> usize where Self: Sized { RULE_variableDeclaration }
}
antlr_rust::type_id!{VariableDeclarationContextExt<'a>}

impl<'input> VariableDeclarationContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<VariableDeclarationContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,VariableDeclarationContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait VariableDeclarationContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<VariableDeclarationContextExt<'input>>{

fn simpleIdentifier(&self) -> Option<Rc<SimpleIdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn annotation_all(&self) ->  Vec<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}
/// Retrieves first TerminalNode corresponding to token COLON
/// Returns `None` if there is no child corresponding to token COLON
fn COLON(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(COLON, 0)
}
fn type(&self) -> Option<Rc<TypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> VariableDeclarationContextAttrs<'input> for VariableDeclarationContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn variableDeclaration(&mut self,)
	-> Result<Rc<VariableDeclarationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = VariableDeclarationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 66, RULE_variableDeclaration);
        let mut _localctx: Rc<VariableDeclarationContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1136);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==AT_NO_WS || _la==AT_PRE_WS {
				{
				{
				/*InvokeRule annotation*/
				recog.base.set_state(1133);
				recog.annotation()?;

				}
				}
				recog.base.set_state(1138);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(1142);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(1139);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(1144);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			/*InvokeRule simpleIdentifier*/
			recog.base.set_state(1145);
			recog.simpleIdentifier()?;

			recog.base.set_state(1160);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(142,&mut recog.base)? {
				x if x == 1=>{
					{
					recog.base.set_state(1149);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(1146);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(1151);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(1152);
					recog.base.match_token(COLON,&mut recog.err_handler)?;

					recog.base.set_state(1156);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(1153);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(1158);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					/*InvokeRule type*/
					recog.base.set_state(1159);
					recog.type()?;

					}
				}

				_ => {}
			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- multiVariableDeclaration ----------------
pub type MultiVariableDeclarationContextAll<'input> = MultiVariableDeclarationContext<'input>;


pub type MultiVariableDeclarationContext<'input> = BaseParserRuleContext<'input,MultiVariableDeclarationContextExt<'input>>;

#[derive(Clone)]
pub struct MultiVariableDeclarationContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for MultiVariableDeclarationContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for MultiVariableDeclarationContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_multiVariableDeclaration(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_multiVariableDeclaration(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for MultiVariableDeclarationContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_multiVariableDeclaration(self);
	}
}

impl<'input> CustomRuleContext<'input> for MultiVariableDeclarationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_multiVariableDeclaration }
	//fn type_rule_index() -> usize where Self: Sized { RULE_multiVariableDeclaration }
}
antlr_rust::type_id!{MultiVariableDeclarationContextExt<'a>}

impl<'input> MultiVariableDeclarationContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<MultiVariableDeclarationContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,MultiVariableDeclarationContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait MultiVariableDeclarationContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<MultiVariableDeclarationContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token LPAREN
/// Returns `None` if there is no child corresponding to token LPAREN
fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(LPAREN, 0)
}
fn variableDeclaration_all(&self) ->  Vec<Rc<VariableDeclarationContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn variableDeclaration(&self, i: usize) -> Option<Rc<VariableDeclarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves first TerminalNode corresponding to token RPAREN
/// Returns `None` if there is no child corresponding to token RPAREN
fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(RPAREN, 0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}

}

impl<'input> MultiVariableDeclarationContextAttrs<'input> for MultiVariableDeclarationContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn multiVariableDeclaration(&mut self,)
	-> Result<Rc<MultiVariableDeclarationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = MultiVariableDeclarationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 68, RULE_multiVariableDeclaration);
        let mut _localctx: Rc<MultiVariableDeclarationContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1162);
			recog.base.match_token(LPAREN,&mut recog.err_handler)?;

			recog.base.set_state(1166);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(143,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					recog.base.set_state(1163);
					recog.base.match_token(NL,&mut recog.err_handler)?;

					}
					} 
				}
				recog.base.set_state(1168);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(143,&mut recog.base)?;
			}
			/*InvokeRule variableDeclaration*/
			recog.base.set_state(1169);
			recog.variableDeclaration()?;

			recog.base.set_state(1186);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(146,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					recog.base.set_state(1173);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(1170);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(1175);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(1176);
					recog.base.match_token(COMMA,&mut recog.err_handler)?;

					recog.base.set_state(1180);
					recog.err_handler.sync(&mut recog.base)?;
					_alt = recog.interpreter.adaptive_predict(145,&mut recog.base)?;
					while { _alt!=2 && _alt!=INVALID_ALT } {
						if _alt==1 {
							{
							{
							recog.base.set_state(1177);
							recog.base.match_token(NL,&mut recog.err_handler)?;

							}
							} 
						}
						recog.base.set_state(1182);
						recog.err_handler.sync(&mut recog.base)?;
						_alt = recog.interpreter.adaptive_predict(145,&mut recog.base)?;
					}
					/*InvokeRule variableDeclaration*/
					recog.base.set_state(1183);
					recog.variableDeclaration()?;

					}
					} 
				}
				recog.base.set_state(1188);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(146,&mut recog.base)?;
			}
			recog.base.set_state(1196);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(148,&mut recog.base)? {
				x if x == 1=>{
					{
					recog.base.set_state(1192);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(1189);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(1194);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(1195);
					recog.base.match_token(COMMA,&mut recog.err_handler)?;

					}
				}

				_ => {}
			}
			recog.base.set_state(1201);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(1198);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(1203);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(1204);
			recog.base.match_token(RPAREN,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- propertyDeclaration ----------------
pub type PropertyDeclarationContextAll<'input> = PropertyDeclarationContext<'input>;


pub type PropertyDeclarationContext<'input> = BaseParserRuleContext<'input,PropertyDeclarationContextExt<'input>>;

#[derive(Clone)]
pub struct PropertyDeclarationContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for PropertyDeclarationContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for PropertyDeclarationContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_propertyDeclaration(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_propertyDeclaration(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for PropertyDeclarationContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_propertyDeclaration(self);
	}
}

impl<'input> CustomRuleContext<'input> for PropertyDeclarationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_propertyDeclaration }
	//fn type_rule_index() -> usize where Self: Sized { RULE_propertyDeclaration }
}
antlr_rust::type_id!{PropertyDeclarationContextExt<'a>}

impl<'input> PropertyDeclarationContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<PropertyDeclarationContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,PropertyDeclarationContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait PropertyDeclarationContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<PropertyDeclarationContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token VAL
/// Returns `None` if there is no child corresponding to token VAL
fn VAL(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(VAL, 0)
}
/// Retrieves first TerminalNode corresponding to token VAR
/// Returns `None` if there is no child corresponding to token VAR
fn VAR(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(VAR, 0)
}
fn modifiers(&self) -> Option<Rc<ModifiersContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn typeParameters(&self) -> Option<Rc<TypeParametersContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn receiverType(&self) -> Option<Rc<ReceiverTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token DOT
/// Returns `None` if there is no child corresponding to token DOT
fn DOT(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(DOT, 0)
}
fn typeConstraints(&self) -> Option<Rc<TypeConstraintsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token SEMICOLON
/// Returns `None` if there is no child corresponding to token SEMICOLON
fn SEMICOLON(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(SEMICOLON, 0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}
fn multiVariableDeclaration(&self) -> Option<Rc<MultiVariableDeclarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn variableDeclaration(&self) -> Option<Rc<VariableDeclarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token ASSIGNMENT
/// Returns `None` if there is no child corresponding to token ASSIGNMENT
fn ASSIGNMENT(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(ASSIGNMENT, 0)
}
fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn propertyDelegate(&self) -> Option<Rc<PropertyDelegateContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn getter(&self) -> Option<Rc<GetterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn setter(&self) -> Option<Rc<SetterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn semi(&self) -> Option<Rc<SemiContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> PropertyDeclarationContextAttrs<'input> for PropertyDeclarationContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn propertyDeclaration(&mut self,)
	-> Result<Rc<PropertyDeclarationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = PropertyDeclarationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 70, RULE_propertyDeclaration);
        let mut _localctx: Rc<PropertyDeclarationContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1207);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==AT_NO_WS || _la==AT_PRE_WS || ((((_la - 109)) & !0x3f) == 0 && ((1usize << (_la - 109)) & ((1usize << (PUBLIC - 109)) | (1usize << (PRIVATE - 109)) | (1usize << (PROTECTED - 109)) | (1usize << (INTERNAL - 109)) | (1usize << (ENUM - 109)) | (1usize << (SEALED - 109)) | (1usize << (ANNOTATION - 109)) | (1usize << (DATA - 109)) | (1usize << (INNER - 109)) | (1usize << (VALUE - 109)) | (1usize << (TAILREC - 109)) | (1usize << (OPERATOR - 109)) | (1usize << (INLINE - 109)) | (1usize << (INFIX - 109)) | (1usize << (EXTERNAL - 109)) | (1usize << (SUSPEND - 109)) | (1usize << (OVERRIDE - 109)) | (1usize << (ABSTRACT - 109)) | (1usize << (FINAL - 109)) | (1usize << (OPEN - 109)) | (1usize << (CONST - 109)) | (1usize << (LATEINIT - 109)) | (1usize << (VARARG - 109)) | (1usize << (NOINLINE - 109)) | (1usize << (CROSSINLINE - 109)) | (1usize << (EXPECT - 109)) | (1usize << (ACTUAL - 109)))) != 0) {
				{
				/*InvokeRule modifiers*/
				recog.base.set_state(1206);
				recog.modifiers()?;

				}
			}

			recog.base.set_state(1209);
			_la = recog.base.input.la(1);
			if { !(_la==VAL || _la==VAR) } {
				recog.err_handler.recover_inline(&mut recog.base)?;

			}
			else {
				if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
				recog.err_handler.report_match(&mut recog.base);
				recog.base.consume(&mut recog.err_handler);
			}
			recog.base.set_state(1217);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(152,&mut recog.base)? {
				x if x == 1=>{
					{
					recog.base.set_state(1213);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(1210);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(1215);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					/*InvokeRule typeParameters*/
					recog.base.set_state(1216);
					recog.typeParameters()?;

					}
				}

				_ => {}
			}
			recog.base.set_state(1234);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(155,&mut recog.base)? {
				x if x == 1=>{
					{
					recog.base.set_state(1222);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(1219);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(1224);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					/*InvokeRule receiverType*/
					recog.base.set_state(1225);
					recog.receiverType()?;

					recog.base.set_state(1229);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(1226);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(1231);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(1232);
					recog.base.match_token(DOT,&mut recog.err_handler)?;

					}
				}

				_ => {}
			}
			{
			recog.base.set_state(1239);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(156,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					recog.base.set_state(1236);
					recog.base.match_token(NL,&mut recog.err_handler)?;

					}
					} 
				}
				recog.base.set_state(1241);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(156,&mut recog.base)?;
			}
			recog.base.set_state(1244);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 LPAREN 
				=> {
					{
					/*InvokeRule multiVariableDeclaration*/
					recog.base.set_state(1242);
					recog.multiVariableDeclaration()?;

					}
				}

			 NL | AT_NO_WS | AT_PRE_WS | FILE | FIELD | PROPERTY | GET | SET | RECEIVER |
			 PARAM | SETPARAM | DELEGATE | IMPORT | CONSTRUCTOR | BY | COMPANION |
			 INIT | WHERE | CATCH | FINALLY | OUT | DYNAMIC | PUBLIC | PRIVATE | PROTECTED |
			 INTERNAL | ENUM | SEALED | ANNOTATION | DATA | INNER | VALUE | TAILREC |
			 OPERATOR | INLINE | INFIX | EXTERNAL | SUSPEND | OVERRIDE | ABSTRACT |
			 FINAL | OPEN | CONST | LATEINIT | VARARG | NOINLINE | CROSSINLINE | REIFIED |
			 EXPECT | ACTUAL | Identifier 
				=> {
					{
					/*InvokeRule variableDeclaration*/
					recog.base.set_state(1243);
					recog.variableDeclaration()?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			}
			recog.base.set_state(1253);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(159,&mut recog.base)? {
				x if x == 1=>{
					{
					recog.base.set_state(1249);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(1246);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(1251);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					/*InvokeRule typeConstraints*/
					recog.base.set_state(1252);
					recog.typeConstraints()?;

					}
				}

				_ => {}
			}
			recog.base.set_state(1272);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(163,&mut recog.base)? {
				x if x == 1=>{
					{
					recog.base.set_state(1258);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(1255);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(1260);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(1270);
					recog.err_handler.sync(&mut recog.base)?;
					match recog.base.input.la(1) {
					 ASSIGNMENT 
						=> {
							{
							recog.base.set_state(1261);
							recog.base.match_token(ASSIGNMENT,&mut recog.err_handler)?;

							recog.base.set_state(1265);
							recog.err_handler.sync(&mut recog.base)?;
							_alt = recog.interpreter.adaptive_predict(161,&mut recog.base)?;
							while { _alt!=2 && _alt!=INVALID_ALT } {
								if _alt==1 {
									{
									{
									recog.base.set_state(1262);
									recog.base.match_token(NL,&mut recog.err_handler)?;

									}
									} 
								}
								recog.base.set_state(1267);
								recog.err_handler.sync(&mut recog.base)?;
								_alt = recog.interpreter.adaptive_predict(161,&mut recog.base)?;
							}
							/*InvokeRule expression*/
							recog.base.set_state(1268);
							recog.expression()?;

							}
						}

					 BY 
						=> {
							{
							/*InvokeRule propertyDelegate*/
							recog.base.set_state(1269);
							recog.propertyDelegate()?;

							}
						}

						_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
					}
					}
				}

				_ => {}
			}
			recog.base.set_state(1281);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(165,&mut recog.base)? {
				x if x == 1=>{
					{
					recog.base.set_state(1277);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(1274);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(1279);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(1280);
					recog.base.match_token(SEMICOLON,&mut recog.err_handler)?;

					}
				}

				_ => {}
			}
			recog.base.set_state(1286);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(166,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					recog.base.set_state(1283);
					recog.base.match_token(NL,&mut recog.err_handler)?;

					}
					} 
				}
				recog.base.set_state(1288);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(166,&mut recog.base)?;
			}
			recog.base.set_state(1319);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(175,&mut recog.base)? {
				1 =>{
					{
					recog.base.set_state(1290);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(167,&mut recog.base)? {
						x if x == 1=>{
							{
							/*InvokeRule getter*/
							recog.base.set_state(1289);
							recog.getter()?;

							}
						}

						_ => {}
					}
					recog.base.set_state(1302);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(170,&mut recog.base)? {
						x if x == 1=>{
							{
							recog.base.set_state(1295);
							recog.err_handler.sync(&mut recog.base)?;
							_alt = recog.interpreter.adaptive_predict(168,&mut recog.base)?;
							while { _alt!=2 && _alt!=INVALID_ALT } {
								if _alt==1 {
									{
									{
									recog.base.set_state(1292);
									recog.base.match_token(NL,&mut recog.err_handler)?;

									}
									} 
								}
								recog.base.set_state(1297);
								recog.err_handler.sync(&mut recog.base)?;
								_alt = recog.interpreter.adaptive_predict(168,&mut recog.base)?;
							}
							recog.base.set_state(1299);
							recog.err_handler.sync(&mut recog.base)?;
							_la = recog.base.input.la(1);
							if _la==NL || _la==SEMICOLON {
								{
								/*InvokeRule semi*/
								recog.base.set_state(1298);
								recog.semi()?;

								}
							}

							/*InvokeRule setter*/
							recog.base.set_state(1301);
							recog.setter()?;

							}
						}

						_ => {}
					}
					}
				}
			,
				2 =>{
					{
					recog.base.set_state(1305);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(171,&mut recog.base)? {
						x if x == 1=>{
							{
							/*InvokeRule setter*/
							recog.base.set_state(1304);
							recog.setter()?;

							}
						}

						_ => {}
					}
					recog.base.set_state(1317);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(174,&mut recog.base)? {
						x if x == 1=>{
							{
							recog.base.set_state(1310);
							recog.err_handler.sync(&mut recog.base)?;
							_alt = recog.interpreter.adaptive_predict(172,&mut recog.base)?;
							while { _alt!=2 && _alt!=INVALID_ALT } {
								if _alt==1 {
									{
									{
									recog.base.set_state(1307);
									recog.base.match_token(NL,&mut recog.err_handler)?;

									}
									} 
								}
								recog.base.set_state(1312);
								recog.err_handler.sync(&mut recog.base)?;
								_alt = recog.interpreter.adaptive_predict(172,&mut recog.base)?;
							}
							recog.base.set_state(1314);
							recog.err_handler.sync(&mut recog.base)?;
							_la = recog.base.input.la(1);
							if _la==NL || _la==SEMICOLON {
								{
								/*InvokeRule semi*/
								recog.base.set_state(1313);
								recog.semi()?;

								}
							}

							/*InvokeRule getter*/
							recog.base.set_state(1316);
							recog.getter()?;

							}
						}

						_ => {}
					}
					}
				}

				_ => {}
			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- propertyDelegate ----------------
pub type PropertyDelegateContextAll<'input> = PropertyDelegateContext<'input>;


pub type PropertyDelegateContext<'input> = BaseParserRuleContext<'input,PropertyDelegateContextExt<'input>>;

#[derive(Clone)]
pub struct PropertyDelegateContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for PropertyDelegateContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for PropertyDelegateContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_propertyDelegate(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_propertyDelegate(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for PropertyDelegateContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_propertyDelegate(self);
	}
}

impl<'input> CustomRuleContext<'input> for PropertyDelegateContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_propertyDelegate }
	//fn type_rule_index() -> usize where Self: Sized { RULE_propertyDelegate }
}
antlr_rust::type_id!{PropertyDelegateContextExt<'a>}

impl<'input> PropertyDelegateContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<PropertyDelegateContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,PropertyDelegateContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait PropertyDelegateContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<PropertyDelegateContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token BY
/// Returns `None` if there is no child corresponding to token BY
fn BY(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(BY, 0)
}
fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}

}

impl<'input> PropertyDelegateContextAttrs<'input> for PropertyDelegateContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn propertyDelegate(&mut self,)
	-> Result<Rc<PropertyDelegateContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = PropertyDelegateContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 72, RULE_propertyDelegate);
        let mut _localctx: Rc<PropertyDelegateContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1321);
			recog.base.match_token(BY,&mut recog.err_handler)?;

			recog.base.set_state(1325);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(176,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					recog.base.set_state(1322);
					recog.base.match_token(NL,&mut recog.err_handler)?;

					}
					} 
				}
				recog.base.set_state(1327);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(176,&mut recog.base)?;
			}
			/*InvokeRule expression*/
			recog.base.set_state(1328);
			recog.expression()?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- getter ----------------
pub type GetterContextAll<'input> = GetterContext<'input>;


pub type GetterContext<'input> = BaseParserRuleContext<'input,GetterContextExt<'input>>;

#[derive(Clone)]
pub struct GetterContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for GetterContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for GetterContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_getter(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_getter(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for GetterContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_getter(self);
	}
}

impl<'input> CustomRuleContext<'input> for GetterContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_getter }
	//fn type_rule_index() -> usize where Self: Sized { RULE_getter }
}
antlr_rust::type_id!{GetterContextExt<'a>}

impl<'input> GetterContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<GetterContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,GetterContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait GetterContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<GetterContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token GET
/// Returns `None` if there is no child corresponding to token GET
fn GET(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(GET, 0)
}
fn modifiers(&self) -> Option<Rc<ModifiersContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token LPAREN
/// Returns `None` if there is no child corresponding to token LPAREN
fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(LPAREN, 0)
}
/// Retrieves first TerminalNode corresponding to token RPAREN
/// Returns `None` if there is no child corresponding to token RPAREN
fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(RPAREN, 0)
}
fn functionBody(&self) -> Option<Rc<FunctionBodyContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}
/// Retrieves first TerminalNode corresponding to token COLON
/// Returns `None` if there is no child corresponding to token COLON
fn COLON(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(COLON, 0)
}
fn type(&self) -> Option<Rc<TypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> GetterContextAttrs<'input> for GetterContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn getter(&mut self,)
	-> Result<Rc<GetterContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = GetterContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 74, RULE_getter);
        let mut _localctx: Rc<GetterContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1331);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==AT_NO_WS || _la==AT_PRE_WS || ((((_la - 109)) & !0x3f) == 0 && ((1usize << (_la - 109)) & ((1usize << (PUBLIC - 109)) | (1usize << (PRIVATE - 109)) | (1usize << (PROTECTED - 109)) | (1usize << (INTERNAL - 109)) | (1usize << (ENUM - 109)) | (1usize << (SEALED - 109)) | (1usize << (ANNOTATION - 109)) | (1usize << (DATA - 109)) | (1usize << (INNER - 109)) | (1usize << (VALUE - 109)) | (1usize << (TAILREC - 109)) | (1usize << (OPERATOR - 109)) | (1usize << (INLINE - 109)) | (1usize << (INFIX - 109)) | (1usize << (EXTERNAL - 109)) | (1usize << (SUSPEND - 109)) | (1usize << (OVERRIDE - 109)) | (1usize << (ABSTRACT - 109)) | (1usize << (FINAL - 109)) | (1usize << (OPEN - 109)) | (1usize << (CONST - 109)) | (1usize << (LATEINIT - 109)) | (1usize << (VARARG - 109)) | (1usize << (NOINLINE - 109)) | (1usize << (CROSSINLINE - 109)) | (1usize << (EXPECT - 109)) | (1usize << (ACTUAL - 109)))) != 0) {
				{
				/*InvokeRule modifiers*/
				recog.base.set_state(1330);
				recog.modifiers()?;

				}
			}

			recog.base.set_state(1333);
			recog.base.match_token(GET,&mut recog.err_handler)?;

			recog.base.set_state(1371);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(184,&mut recog.base)? {
				x if x == 1=>{
					{
					recog.base.set_state(1337);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(1334);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(1339);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(1340);
					recog.base.match_token(LPAREN,&mut recog.err_handler)?;

					recog.base.set_state(1344);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(1341);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(1346);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(1347);
					recog.base.match_token(RPAREN,&mut recog.err_handler)?;

					recog.base.set_state(1362);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(182,&mut recog.base)? {
						x if x == 1=>{
							{
							recog.base.set_state(1351);
							recog.err_handler.sync(&mut recog.base)?;
							_la = recog.base.input.la(1);
							while _la==NL {
								{
								{
								recog.base.set_state(1348);
								recog.base.match_token(NL,&mut recog.err_handler)?;

								}
								}
								recog.base.set_state(1353);
								recog.err_handler.sync(&mut recog.base)?;
								_la = recog.base.input.la(1);
							}
							recog.base.set_state(1354);
							recog.base.match_token(COLON,&mut recog.err_handler)?;

							recog.base.set_state(1358);
							recog.err_handler.sync(&mut recog.base)?;
							_la = recog.base.input.la(1);
							while _la==NL {
								{
								{
								recog.base.set_state(1355);
								recog.base.match_token(NL,&mut recog.err_handler)?;

								}
								}
								recog.base.set_state(1360);
								recog.err_handler.sync(&mut recog.base)?;
								_la = recog.base.input.la(1);
							}
							/*InvokeRule type*/
							recog.base.set_state(1361);
							recog.type()?;

							}
						}

						_ => {}
					}
					recog.base.set_state(1367);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(1364);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(1369);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					/*InvokeRule functionBody*/
					recog.base.set_state(1370);
					recog.functionBody()?;

					}
				}

				_ => {}
			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- setter ----------------
pub type SetterContextAll<'input> = SetterContext<'input>;


pub type SetterContext<'input> = BaseParserRuleContext<'input,SetterContextExt<'input>>;

#[derive(Clone)]
pub struct SetterContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for SetterContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for SetterContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_setter(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_setter(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for SetterContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_setter(self);
	}
}

impl<'input> CustomRuleContext<'input> for SetterContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_setter }
	//fn type_rule_index() -> usize where Self: Sized { RULE_setter }
}
antlr_rust::type_id!{SetterContextExt<'a>}

impl<'input> SetterContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<SetterContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,SetterContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait SetterContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<SetterContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token SET
/// Returns `None` if there is no child corresponding to token SET
fn SET(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(SET, 0)
}
fn modifiers(&self) -> Option<Rc<ModifiersContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token LPAREN
/// Returns `None` if there is no child corresponding to token LPAREN
fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(LPAREN, 0)
}
fn functionValueParameterWithOptionalType(&self) -> Option<Rc<FunctionValueParameterWithOptionalTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token RPAREN
/// Returns `None` if there is no child corresponding to token RPAREN
fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(RPAREN, 0)
}
fn functionBody(&self) -> Option<Rc<FunctionBodyContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}
/// Retrieves first TerminalNode corresponding to token COMMA
/// Returns `None` if there is no child corresponding to token COMMA
fn COMMA(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(COMMA, 0)
}
/// Retrieves first TerminalNode corresponding to token COLON
/// Returns `None` if there is no child corresponding to token COLON
fn COLON(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(COLON, 0)
}
fn type(&self) -> Option<Rc<TypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> SetterContextAttrs<'input> for SetterContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn setter(&mut self,)
	-> Result<Rc<SetterContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = SetterContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 76, RULE_setter);
        let mut _localctx: Rc<SetterContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1374);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==AT_NO_WS || _la==AT_PRE_WS || ((((_la - 109)) & !0x3f) == 0 && ((1usize << (_la - 109)) & ((1usize << (PUBLIC - 109)) | (1usize << (PRIVATE - 109)) | (1usize << (PROTECTED - 109)) | (1usize << (INTERNAL - 109)) | (1usize << (ENUM - 109)) | (1usize << (SEALED - 109)) | (1usize << (ANNOTATION - 109)) | (1usize << (DATA - 109)) | (1usize << (INNER - 109)) | (1usize << (VALUE - 109)) | (1usize << (TAILREC - 109)) | (1usize << (OPERATOR - 109)) | (1usize << (INLINE - 109)) | (1usize << (INFIX - 109)) | (1usize << (EXTERNAL - 109)) | (1usize << (SUSPEND - 109)) | (1usize << (OVERRIDE - 109)) | (1usize << (ABSTRACT - 109)) | (1usize << (FINAL - 109)) | (1usize << (OPEN - 109)) | (1usize << (CONST - 109)) | (1usize << (LATEINIT - 109)) | (1usize << (VARARG - 109)) | (1usize << (NOINLINE - 109)) | (1usize << (CROSSINLINE - 109)) | (1usize << (EXPECT - 109)) | (1usize << (ACTUAL - 109)))) != 0) {
				{
				/*InvokeRule modifiers*/
				recog.base.set_state(1373);
				recog.modifiers()?;

				}
			}

			recog.base.set_state(1376);
			recog.base.match_token(SET,&mut recog.err_handler)?;

			recog.base.set_state(1431);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(195,&mut recog.base)? {
				x if x == 1=>{
					{
					recog.base.set_state(1380);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(1377);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(1382);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(1383);
					recog.base.match_token(LPAREN,&mut recog.err_handler)?;

					recog.base.set_state(1387);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(1384);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(1389);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					/*InvokeRule functionValueParameterWithOptionalType*/
					recog.base.set_state(1390);
					recog.functionValueParameterWithOptionalType()?;

					recog.base.set_state(1398);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(189,&mut recog.base)? {
						x if x == 1=>{
							{
							recog.base.set_state(1394);
							recog.err_handler.sync(&mut recog.base)?;
							_la = recog.base.input.la(1);
							while _la==NL {
								{
								{
								recog.base.set_state(1391);
								recog.base.match_token(NL,&mut recog.err_handler)?;

								}
								}
								recog.base.set_state(1396);
								recog.err_handler.sync(&mut recog.base)?;
								_la = recog.base.input.la(1);
							}
							recog.base.set_state(1397);
							recog.base.match_token(COMMA,&mut recog.err_handler)?;

							}
						}

						_ => {}
					}
					recog.base.set_state(1403);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(1400);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(1405);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(1406);
					recog.base.match_token(RPAREN,&mut recog.err_handler)?;

					recog.base.set_state(1421);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(193,&mut recog.base)? {
						x if x == 1=>{
							{
							recog.base.set_state(1410);
							recog.err_handler.sync(&mut recog.base)?;
							_la = recog.base.input.la(1);
							while _la==NL {
								{
								{
								recog.base.set_state(1407);
								recog.base.match_token(NL,&mut recog.err_handler)?;

								}
								}
								recog.base.set_state(1412);
								recog.err_handler.sync(&mut recog.base)?;
								_la = recog.base.input.la(1);
							}
							recog.base.set_state(1413);
							recog.base.match_token(COLON,&mut recog.err_handler)?;

							recog.base.set_state(1417);
							recog.err_handler.sync(&mut recog.base)?;
							_la = recog.base.input.la(1);
							while _la==NL {
								{
								{
								recog.base.set_state(1414);
								recog.base.match_token(NL,&mut recog.err_handler)?;

								}
								}
								recog.base.set_state(1419);
								recog.err_handler.sync(&mut recog.base)?;
								_la = recog.base.input.la(1);
							}
							/*InvokeRule type*/
							recog.base.set_state(1420);
							recog.type()?;

							}
						}

						_ => {}
					}
					recog.base.set_state(1426);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(1423);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(1428);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					/*InvokeRule functionBody*/
					recog.base.set_state(1429);
					recog.functionBody()?;

					}
				}

				_ => {}
			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- parametersWithOptionalType ----------------
pub type ParametersWithOptionalTypeContextAll<'input> = ParametersWithOptionalTypeContext<'input>;


pub type ParametersWithOptionalTypeContext<'input> = BaseParserRuleContext<'input,ParametersWithOptionalTypeContextExt<'input>>;

#[derive(Clone)]
pub struct ParametersWithOptionalTypeContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for ParametersWithOptionalTypeContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for ParametersWithOptionalTypeContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_parametersWithOptionalType(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_parametersWithOptionalType(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for ParametersWithOptionalTypeContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_parametersWithOptionalType(self);
	}
}

impl<'input> CustomRuleContext<'input> for ParametersWithOptionalTypeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_parametersWithOptionalType }
	//fn type_rule_index() -> usize where Self: Sized { RULE_parametersWithOptionalType }
}
antlr_rust::type_id!{ParametersWithOptionalTypeContextExt<'a>}

impl<'input> ParametersWithOptionalTypeContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ParametersWithOptionalTypeContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ParametersWithOptionalTypeContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ParametersWithOptionalTypeContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<ParametersWithOptionalTypeContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token LPAREN
/// Returns `None` if there is no child corresponding to token LPAREN
fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(LPAREN, 0)
}
/// Retrieves first TerminalNode corresponding to token RPAREN
/// Returns `None` if there is no child corresponding to token RPAREN
fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(RPAREN, 0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}
fn functionValueParameterWithOptionalType_all(&self) ->  Vec<Rc<FunctionValueParameterWithOptionalTypeContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn functionValueParameterWithOptionalType(&self, i: usize) -> Option<Rc<FunctionValueParameterWithOptionalTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}

}

impl<'input> ParametersWithOptionalTypeContextAttrs<'input> for ParametersWithOptionalTypeContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn parametersWithOptionalType(&mut self,)
	-> Result<Rc<ParametersWithOptionalTypeContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ParametersWithOptionalTypeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 78, RULE_parametersWithOptionalType);
        let mut _localctx: Rc<ParametersWithOptionalTypeContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1433);
			recog.base.match_token(LPAREN,&mut recog.err_handler)?;

			recog.base.set_state(1437);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(196,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					recog.base.set_state(1434);
					recog.base.match_token(NL,&mut recog.err_handler)?;

					}
					} 
				}
				recog.base.set_state(1439);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(196,&mut recog.base)?;
			}
			recog.base.set_state(1469);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if ((((_la - 41)) & !0x3f) == 0 && ((1usize << (_la - 41)) & ((1usize << (AT_NO_WS - 41)) | (1usize << (AT_PRE_WS - 41)) | (1usize << (FILE - 41)) | (1usize << (FIELD - 41)) | (1usize << (PROPERTY - 41)) | (1usize << (GET - 41)) | (1usize << (SET - 41)) | (1usize << (RECEIVER - 41)) | (1usize << (PARAM - 41)) | (1usize << (SETPARAM - 41)) | (1usize << (DELEGATE - 41)) | (1usize << (IMPORT - 41)) | (1usize << (CONSTRUCTOR - 41)) | (1usize << (BY - 41)) | (1usize << (COMPANION - 41)) | (1usize << (INIT - 41)) | (1usize << (WHERE - 41)) | (1usize << (CATCH - 41)) | (1usize << (FINALLY - 41)))) != 0) || ((((_la - 107)) & !0x3f) == 0 && ((1usize << (_la - 107)) & ((1usize << (OUT - 107)) | (1usize << (DYNAMIC - 107)) | (1usize << (PUBLIC - 107)) | (1usize << (PRIVATE - 107)) | (1usize << (PROTECTED - 107)) | (1usize << (INTERNAL - 107)) | (1usize << (ENUM - 107)) | (1usize << (SEALED - 107)) | (1usize << (ANNOTATION - 107)) | (1usize << (DATA - 107)) | (1usize << (INNER - 107)) | (1usize << (VALUE - 107)) | (1usize << (TAILREC - 107)) | (1usize << (OPERATOR - 107)) | (1usize << (INLINE - 107)) | (1usize << (INFIX - 107)) | (1usize << (EXTERNAL - 107)) | (1usize << (SUSPEND - 107)) | (1usize << (OVERRIDE - 107)) | (1usize << (ABSTRACT - 107)) | (1usize << (FINAL - 107)) | (1usize << (OPEN - 107)) | (1usize << (CONST - 107)) | (1usize << (LATEINIT - 107)) | (1usize << (VARARG - 107)) | (1usize << (NOINLINE - 107)) | (1usize << (CROSSINLINE - 107)) | (1usize << (REIFIED - 107)) | (1usize << (EXPECT - 107)) | (1usize << (ACTUAL - 107)) | (1usize << (Identifier - 107)))) != 0) {
				{
				/*InvokeRule functionValueParameterWithOptionalType*/
				recog.base.set_state(1440);
				recog.functionValueParameterWithOptionalType()?;

				recog.base.set_state(1457);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(199,&mut recog.base)?;
				while { _alt!=2 && _alt!=INVALID_ALT } {
					if _alt==1 {
						{
						{
						recog.base.set_state(1444);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
						while _la==NL {
							{
							{
							recog.base.set_state(1441);
							recog.base.match_token(NL,&mut recog.err_handler)?;

							}
							}
							recog.base.set_state(1446);
							recog.err_handler.sync(&mut recog.base)?;
							_la = recog.base.input.la(1);
						}
						recog.base.set_state(1447);
						recog.base.match_token(COMMA,&mut recog.err_handler)?;

						recog.base.set_state(1451);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
						while _la==NL {
							{
							{
							recog.base.set_state(1448);
							recog.base.match_token(NL,&mut recog.err_handler)?;

							}
							}
							recog.base.set_state(1453);
							recog.err_handler.sync(&mut recog.base)?;
							_la = recog.base.input.la(1);
						}
						/*InvokeRule functionValueParameterWithOptionalType*/
						recog.base.set_state(1454);
						recog.functionValueParameterWithOptionalType()?;

						}
						} 
					}
					recog.base.set_state(1459);
					recog.err_handler.sync(&mut recog.base)?;
					_alt = recog.interpreter.adaptive_predict(199,&mut recog.base)?;
				}
				recog.base.set_state(1467);
				recog.err_handler.sync(&mut recog.base)?;
				match  recog.interpreter.adaptive_predict(201,&mut recog.base)? {
					x if x == 1=>{
						{
						recog.base.set_state(1463);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
						while _la==NL {
							{
							{
							recog.base.set_state(1460);
							recog.base.match_token(NL,&mut recog.err_handler)?;

							}
							}
							recog.base.set_state(1465);
							recog.err_handler.sync(&mut recog.base)?;
							_la = recog.base.input.la(1);
						}
						recog.base.set_state(1466);
						recog.base.match_token(COMMA,&mut recog.err_handler)?;

						}
					}

					_ => {}
				}
				}
			}

			recog.base.set_state(1474);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(1471);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(1476);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(1477);
			recog.base.match_token(RPAREN,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- functionValueParameterWithOptionalType ----------------
pub type FunctionValueParameterWithOptionalTypeContextAll<'input> = FunctionValueParameterWithOptionalTypeContext<'input>;


pub type FunctionValueParameterWithOptionalTypeContext<'input> = BaseParserRuleContext<'input,FunctionValueParameterWithOptionalTypeContextExt<'input>>;

#[derive(Clone)]
pub struct FunctionValueParameterWithOptionalTypeContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for FunctionValueParameterWithOptionalTypeContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for FunctionValueParameterWithOptionalTypeContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_functionValueParameterWithOptionalType(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_functionValueParameterWithOptionalType(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for FunctionValueParameterWithOptionalTypeContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_functionValueParameterWithOptionalType(self);
	}
}

impl<'input> CustomRuleContext<'input> for FunctionValueParameterWithOptionalTypeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_functionValueParameterWithOptionalType }
	//fn type_rule_index() -> usize where Self: Sized { RULE_functionValueParameterWithOptionalType }
}
antlr_rust::type_id!{FunctionValueParameterWithOptionalTypeContextExt<'a>}

impl<'input> FunctionValueParameterWithOptionalTypeContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<FunctionValueParameterWithOptionalTypeContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,FunctionValueParameterWithOptionalTypeContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait FunctionValueParameterWithOptionalTypeContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<FunctionValueParameterWithOptionalTypeContextExt<'input>>{

fn parameterWithOptionalType(&self) -> Option<Rc<ParameterWithOptionalTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn parameterModifiers(&self) -> Option<Rc<ParameterModifiersContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token ASSIGNMENT
/// Returns `None` if there is no child corresponding to token ASSIGNMENT
fn ASSIGNMENT(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(ASSIGNMENT, 0)
}
fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}

}

impl<'input> FunctionValueParameterWithOptionalTypeContextAttrs<'input> for FunctionValueParameterWithOptionalTypeContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn functionValueParameterWithOptionalType(&mut self,)
	-> Result<Rc<FunctionValueParameterWithOptionalTypeContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = FunctionValueParameterWithOptionalTypeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 80, RULE_functionValueParameterWithOptionalType);
        let mut _localctx: Rc<FunctionValueParameterWithOptionalTypeContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1480);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(204,&mut recog.base)? {
				x if x == 1=>{
					{
					/*InvokeRule parameterModifiers*/
					recog.base.set_state(1479);
					recog.parameterModifiers()?;

					}
				}

				_ => {}
			}
			/*InvokeRule parameterWithOptionalType*/
			recog.base.set_state(1482);
			recog.parameterWithOptionalType()?;

			recog.base.set_state(1497);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(207,&mut recog.base)? {
				x if x == 1=>{
					{
					recog.base.set_state(1486);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(1483);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(1488);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(1489);
					recog.base.match_token(ASSIGNMENT,&mut recog.err_handler)?;

					recog.base.set_state(1493);
					recog.err_handler.sync(&mut recog.base)?;
					_alt = recog.interpreter.adaptive_predict(206,&mut recog.base)?;
					while { _alt!=2 && _alt!=INVALID_ALT } {
						if _alt==1 {
							{
							{
							recog.base.set_state(1490);
							recog.base.match_token(NL,&mut recog.err_handler)?;

							}
							} 
						}
						recog.base.set_state(1495);
						recog.err_handler.sync(&mut recog.base)?;
						_alt = recog.interpreter.adaptive_predict(206,&mut recog.base)?;
					}
					/*InvokeRule expression*/
					recog.base.set_state(1496);
					recog.expression()?;

					}
				}

				_ => {}
			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- parameterWithOptionalType ----------------
pub type ParameterWithOptionalTypeContextAll<'input> = ParameterWithOptionalTypeContext<'input>;


pub type ParameterWithOptionalTypeContext<'input> = BaseParserRuleContext<'input,ParameterWithOptionalTypeContextExt<'input>>;

#[derive(Clone)]
pub struct ParameterWithOptionalTypeContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for ParameterWithOptionalTypeContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for ParameterWithOptionalTypeContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_parameterWithOptionalType(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_parameterWithOptionalType(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for ParameterWithOptionalTypeContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_parameterWithOptionalType(self);
	}
}

impl<'input> CustomRuleContext<'input> for ParameterWithOptionalTypeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_parameterWithOptionalType }
	//fn type_rule_index() -> usize where Self: Sized { RULE_parameterWithOptionalType }
}
antlr_rust::type_id!{ParameterWithOptionalTypeContextExt<'a>}

impl<'input> ParameterWithOptionalTypeContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ParameterWithOptionalTypeContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ParameterWithOptionalTypeContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ParameterWithOptionalTypeContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<ParameterWithOptionalTypeContextExt<'input>>{

fn simpleIdentifier(&self) -> Option<Rc<SimpleIdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}
/// Retrieves first TerminalNode corresponding to token COLON
/// Returns `None` if there is no child corresponding to token COLON
fn COLON(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(COLON, 0)
}
fn type(&self) -> Option<Rc<TypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ParameterWithOptionalTypeContextAttrs<'input> for ParameterWithOptionalTypeContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn parameterWithOptionalType(&mut self,)
	-> Result<Rc<ParameterWithOptionalTypeContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ParameterWithOptionalTypeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 82, RULE_parameterWithOptionalType);
        let mut _localctx: Rc<ParameterWithOptionalTypeContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule simpleIdentifier*/
			recog.base.set_state(1499);
			recog.simpleIdentifier()?;

			recog.base.set_state(1503);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(208,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					recog.base.set_state(1500);
					recog.base.match_token(NL,&mut recog.err_handler)?;

					}
					} 
				}
				recog.base.set_state(1505);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(208,&mut recog.base)?;
			}
			recog.base.set_state(1514);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==COLON {
				{
				recog.base.set_state(1506);
				recog.base.match_token(COLON,&mut recog.err_handler)?;

				recog.base.set_state(1510);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
				while _la==NL {
					{
					{
					recog.base.set_state(1507);
					recog.base.match_token(NL,&mut recog.err_handler)?;

					}
					}
					recog.base.set_state(1512);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
				}
				/*InvokeRule type*/
				recog.base.set_state(1513);
				recog.type()?;

				}
			}

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- parameter ----------------
pub type ParameterContextAll<'input> = ParameterContext<'input>;


pub type ParameterContext<'input> = BaseParserRuleContext<'input,ParameterContextExt<'input>>;

#[derive(Clone)]
pub struct ParameterContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for ParameterContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for ParameterContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_parameter(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_parameter(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for ParameterContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_parameter(self);
	}
}

impl<'input> CustomRuleContext<'input> for ParameterContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_parameter }
	//fn type_rule_index() -> usize where Self: Sized { RULE_parameter }
}
antlr_rust::type_id!{ParameterContextExt<'a>}

impl<'input> ParameterContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ParameterContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ParameterContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ParameterContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<ParameterContextExt<'input>>{

fn simpleIdentifier(&self) -> Option<Rc<SimpleIdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COLON
/// Returns `None` if there is no child corresponding to token COLON
fn COLON(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(COLON, 0)
}
fn type(&self) -> Option<Rc<TypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}

}

impl<'input> ParameterContextAttrs<'input> for ParameterContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn parameter(&mut self,)
	-> Result<Rc<ParameterContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ParameterContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 84, RULE_parameter);
        let mut _localctx: Rc<ParameterContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule simpleIdentifier*/
			recog.base.set_state(1516);
			recog.simpleIdentifier()?;

			recog.base.set_state(1520);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(1517);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(1522);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(1523);
			recog.base.match_token(COLON,&mut recog.err_handler)?;

			recog.base.set_state(1527);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(1524);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(1529);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			/*InvokeRule type*/
			recog.base.set_state(1530);
			recog.type()?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- objectDeclaration ----------------
pub type ObjectDeclarationContextAll<'input> = ObjectDeclarationContext<'input>;


pub type ObjectDeclarationContext<'input> = BaseParserRuleContext<'input,ObjectDeclarationContextExt<'input>>;

#[derive(Clone)]
pub struct ObjectDeclarationContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for ObjectDeclarationContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for ObjectDeclarationContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_objectDeclaration(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_objectDeclaration(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for ObjectDeclarationContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_objectDeclaration(self);
	}
}

impl<'input> CustomRuleContext<'input> for ObjectDeclarationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_objectDeclaration }
	//fn type_rule_index() -> usize where Self: Sized { RULE_objectDeclaration }
}
antlr_rust::type_id!{ObjectDeclarationContextExt<'a>}

impl<'input> ObjectDeclarationContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ObjectDeclarationContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ObjectDeclarationContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ObjectDeclarationContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<ObjectDeclarationContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OBJECT
/// Returns `None` if there is no child corresponding to token OBJECT
fn OBJECT(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(OBJECT, 0)
}
fn simpleIdentifier(&self) -> Option<Rc<SimpleIdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn modifiers(&self) -> Option<Rc<ModifiersContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}
/// Retrieves first TerminalNode corresponding to token COLON
/// Returns `None` if there is no child corresponding to token COLON
fn COLON(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(COLON, 0)
}
fn delegationSpecifiers(&self) -> Option<Rc<DelegationSpecifiersContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn classBody(&self) -> Option<Rc<ClassBodyContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ObjectDeclarationContextAttrs<'input> for ObjectDeclarationContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn objectDeclaration(&mut self,)
	-> Result<Rc<ObjectDeclarationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ObjectDeclarationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 86, RULE_objectDeclaration);
        let mut _localctx: Rc<ObjectDeclarationContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1533);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==AT_NO_WS || _la==AT_PRE_WS || ((((_la - 109)) & !0x3f) == 0 && ((1usize << (_la - 109)) & ((1usize << (PUBLIC - 109)) | (1usize << (PRIVATE - 109)) | (1usize << (PROTECTED - 109)) | (1usize << (INTERNAL - 109)) | (1usize << (ENUM - 109)) | (1usize << (SEALED - 109)) | (1usize << (ANNOTATION - 109)) | (1usize << (DATA - 109)) | (1usize << (INNER - 109)) | (1usize << (VALUE - 109)) | (1usize << (TAILREC - 109)) | (1usize << (OPERATOR - 109)) | (1usize << (INLINE - 109)) | (1usize << (INFIX - 109)) | (1usize << (EXTERNAL - 109)) | (1usize << (SUSPEND - 109)) | (1usize << (OVERRIDE - 109)) | (1usize << (ABSTRACT - 109)) | (1usize << (FINAL - 109)) | (1usize << (OPEN - 109)) | (1usize << (CONST - 109)) | (1usize << (LATEINIT - 109)) | (1usize << (VARARG - 109)) | (1usize << (NOINLINE - 109)) | (1usize << (CROSSINLINE - 109)) | (1usize << (EXPECT - 109)) | (1usize << (ACTUAL - 109)))) != 0) {
				{
				/*InvokeRule modifiers*/
				recog.base.set_state(1532);
				recog.modifiers()?;

				}
			}

			recog.base.set_state(1535);
			recog.base.match_token(OBJECT,&mut recog.err_handler)?;

			recog.base.set_state(1539);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(1536);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(1541);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			/*InvokeRule simpleIdentifier*/
			recog.base.set_state(1542);
			recog.simpleIdentifier()?;

			recog.base.set_state(1557);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(217,&mut recog.base)? {
				x if x == 1=>{
					{
					recog.base.set_state(1546);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(1543);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(1548);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(1549);
					recog.base.match_token(COLON,&mut recog.err_handler)?;

					recog.base.set_state(1553);
					recog.err_handler.sync(&mut recog.base)?;
					_alt = recog.interpreter.adaptive_predict(216,&mut recog.base)?;
					while { _alt!=2 && _alt!=INVALID_ALT } {
						if _alt==1 {
							{
							{
							recog.base.set_state(1550);
							recog.base.match_token(NL,&mut recog.err_handler)?;

							}
							} 
						}
						recog.base.set_state(1555);
						recog.err_handler.sync(&mut recog.base)?;
						_alt = recog.interpreter.adaptive_predict(216,&mut recog.base)?;
					}
					/*InvokeRule delegationSpecifiers*/
					recog.base.set_state(1556);
					recog.delegationSpecifiers()?;

					}
				}

				_ => {}
			}
			recog.base.set_state(1566);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(219,&mut recog.base)? {
				x if x == 1=>{
					{
					recog.base.set_state(1562);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(1559);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(1564);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					/*InvokeRule classBody*/
					recog.base.set_state(1565);
					recog.classBody()?;

					}
				}

				_ => {}
			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- secondaryConstructor ----------------
pub type SecondaryConstructorContextAll<'input> = SecondaryConstructorContext<'input>;


pub type SecondaryConstructorContext<'input> = BaseParserRuleContext<'input,SecondaryConstructorContextExt<'input>>;

#[derive(Clone)]
pub struct SecondaryConstructorContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for SecondaryConstructorContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for SecondaryConstructorContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_secondaryConstructor(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_secondaryConstructor(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for SecondaryConstructorContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_secondaryConstructor(self);
	}
}

impl<'input> CustomRuleContext<'input> for SecondaryConstructorContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_secondaryConstructor }
	//fn type_rule_index() -> usize where Self: Sized { RULE_secondaryConstructor }
}
antlr_rust::type_id!{SecondaryConstructorContextExt<'a>}

impl<'input> SecondaryConstructorContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<SecondaryConstructorContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,SecondaryConstructorContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait SecondaryConstructorContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<SecondaryConstructorContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token CONSTRUCTOR
/// Returns `None` if there is no child corresponding to token CONSTRUCTOR
fn CONSTRUCTOR(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(CONSTRUCTOR, 0)
}
fn functionValueParameters(&self) -> Option<Rc<FunctionValueParametersContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn modifiers(&self) -> Option<Rc<ModifiersContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}
/// Retrieves first TerminalNode corresponding to token COLON
/// Returns `None` if there is no child corresponding to token COLON
fn COLON(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(COLON, 0)
}
fn constructorDelegationCall(&self) -> Option<Rc<ConstructorDelegationCallContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn block(&self) -> Option<Rc<BlockContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> SecondaryConstructorContextAttrs<'input> for SecondaryConstructorContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn secondaryConstructor(&mut self,)
	-> Result<Rc<SecondaryConstructorContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = SecondaryConstructorContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 88, RULE_secondaryConstructor);
        let mut _localctx: Rc<SecondaryConstructorContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1569);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==AT_NO_WS || _la==AT_PRE_WS || ((((_la - 109)) & !0x3f) == 0 && ((1usize << (_la - 109)) & ((1usize << (PUBLIC - 109)) | (1usize << (PRIVATE - 109)) | (1usize << (PROTECTED - 109)) | (1usize << (INTERNAL - 109)) | (1usize << (ENUM - 109)) | (1usize << (SEALED - 109)) | (1usize << (ANNOTATION - 109)) | (1usize << (DATA - 109)) | (1usize << (INNER - 109)) | (1usize << (VALUE - 109)) | (1usize << (TAILREC - 109)) | (1usize << (OPERATOR - 109)) | (1usize << (INLINE - 109)) | (1usize << (INFIX - 109)) | (1usize << (EXTERNAL - 109)) | (1usize << (SUSPEND - 109)) | (1usize << (OVERRIDE - 109)) | (1usize << (ABSTRACT - 109)) | (1usize << (FINAL - 109)) | (1usize << (OPEN - 109)) | (1usize << (CONST - 109)) | (1usize << (LATEINIT - 109)) | (1usize << (VARARG - 109)) | (1usize << (NOINLINE - 109)) | (1usize << (CROSSINLINE - 109)) | (1usize << (EXPECT - 109)) | (1usize << (ACTUAL - 109)))) != 0) {
				{
				/*InvokeRule modifiers*/
				recog.base.set_state(1568);
				recog.modifiers()?;

				}
			}

			recog.base.set_state(1571);
			recog.base.match_token(CONSTRUCTOR,&mut recog.err_handler)?;

			recog.base.set_state(1575);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(1572);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(1577);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			/*InvokeRule functionValueParameters*/
			recog.base.set_state(1578);
			recog.functionValueParameters()?;

			recog.base.set_state(1593);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(224,&mut recog.base)? {
				x if x == 1=>{
					{
					recog.base.set_state(1582);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(1579);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(1584);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(1585);
					recog.base.match_token(COLON,&mut recog.err_handler)?;

					recog.base.set_state(1589);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(1586);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(1591);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					/*InvokeRule constructorDelegationCall*/
					recog.base.set_state(1592);
					recog.constructorDelegationCall()?;

					}
				}

				_ => {}
			}
			recog.base.set_state(1598);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(225,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					recog.base.set_state(1595);
					recog.base.match_token(NL,&mut recog.err_handler)?;

					}
					} 
				}
				recog.base.set_state(1600);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(225,&mut recog.base)?;
			}
			recog.base.set_state(1602);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==LCURL {
				{
				/*InvokeRule block*/
				recog.base.set_state(1601);
				recog.block()?;

				}
			}

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- constructorDelegationCall ----------------
pub type ConstructorDelegationCallContextAll<'input> = ConstructorDelegationCallContext<'input>;


pub type ConstructorDelegationCallContext<'input> = BaseParserRuleContext<'input,ConstructorDelegationCallContextExt<'input>>;

#[derive(Clone)]
pub struct ConstructorDelegationCallContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for ConstructorDelegationCallContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for ConstructorDelegationCallContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_constructorDelegationCall(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_constructorDelegationCall(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for ConstructorDelegationCallContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_constructorDelegationCall(self);
	}
}

impl<'input> CustomRuleContext<'input> for ConstructorDelegationCallContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_constructorDelegationCall }
	//fn type_rule_index() -> usize where Self: Sized { RULE_constructorDelegationCall }
}
antlr_rust::type_id!{ConstructorDelegationCallContextExt<'a>}

impl<'input> ConstructorDelegationCallContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ConstructorDelegationCallContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ConstructorDelegationCallContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ConstructorDelegationCallContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<ConstructorDelegationCallContextExt<'input>>{

fn valueArguments(&self) -> Option<Rc<ValueArgumentsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token THIS
/// Returns `None` if there is no child corresponding to token THIS
fn THIS(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(THIS, 0)
}
/// Retrieves first TerminalNode corresponding to token SUPER
/// Returns `None` if there is no child corresponding to token SUPER
fn SUPER(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(SUPER, 0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}

}

impl<'input> ConstructorDelegationCallContextAttrs<'input> for ConstructorDelegationCallContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn constructorDelegationCall(&mut self,)
	-> Result<Rc<ConstructorDelegationCallContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ConstructorDelegationCallContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 90, RULE_constructorDelegationCall);
        let mut _localctx: Rc<ConstructorDelegationCallContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1604);
			_la = recog.base.input.la(1);
			if { !(_la==THIS || _la==SUPER) } {
				recog.err_handler.recover_inline(&mut recog.base)?;

			}
			else {
				if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
				recog.err_handler.report_match(&mut recog.base);
				recog.base.consume(&mut recog.err_handler);
			}
			recog.base.set_state(1608);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(1605);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(1610);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			/*InvokeRule valueArguments*/
			recog.base.set_state(1611);
			recog.valueArguments()?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- enumClassBody ----------------
pub type EnumClassBodyContextAll<'input> = EnumClassBodyContext<'input>;


pub type EnumClassBodyContext<'input> = BaseParserRuleContext<'input,EnumClassBodyContextExt<'input>>;

#[derive(Clone)]
pub struct EnumClassBodyContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for EnumClassBodyContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for EnumClassBodyContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_enumClassBody(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_enumClassBody(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for EnumClassBodyContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_enumClassBody(self);
	}
}

impl<'input> CustomRuleContext<'input> for EnumClassBodyContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_enumClassBody }
	//fn type_rule_index() -> usize where Self: Sized { RULE_enumClassBody }
}
antlr_rust::type_id!{EnumClassBodyContextExt<'a>}

impl<'input> EnumClassBodyContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<EnumClassBodyContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,EnumClassBodyContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait EnumClassBodyContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<EnumClassBodyContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token LCURL
/// Returns `None` if there is no child corresponding to token LCURL
fn LCURL(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(LCURL, 0)
}
/// Retrieves first TerminalNode corresponding to token RCURL
/// Returns `None` if there is no child corresponding to token RCURL
fn RCURL(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(RCURL, 0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}
fn enumEntries(&self) -> Option<Rc<EnumEntriesContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token SEMICOLON
/// Returns `None` if there is no child corresponding to token SEMICOLON
fn SEMICOLON(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(SEMICOLON, 0)
}
fn classMemberDeclarations(&self) -> Option<Rc<ClassMemberDeclarationsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> EnumClassBodyContextAttrs<'input> for EnumClassBodyContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn enumClassBody(&mut self,)
	-> Result<Rc<EnumClassBodyContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = EnumClassBodyContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 92, RULE_enumClassBody);
        let mut _localctx: Rc<EnumClassBodyContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1613);
			recog.base.match_token(LCURL,&mut recog.err_handler)?;

			recog.base.set_state(1617);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(228,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					recog.base.set_state(1614);
					recog.base.match_token(NL,&mut recog.err_handler)?;

					}
					} 
				}
				recog.base.set_state(1619);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(228,&mut recog.base)?;
			}
			recog.base.set_state(1621);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if ((((_la - 41)) & !0x3f) == 0 && ((1usize << (_la - 41)) & ((1usize << (AT_NO_WS - 41)) | (1usize << (AT_PRE_WS - 41)) | (1usize << (FILE - 41)) | (1usize << (FIELD - 41)) | (1usize << (PROPERTY - 41)) | (1usize << (GET - 41)) | (1usize << (SET - 41)) | (1usize << (RECEIVER - 41)) | (1usize << (PARAM - 41)) | (1usize << (SETPARAM - 41)) | (1usize << (DELEGATE - 41)) | (1usize << (IMPORT - 41)) | (1usize << (CONSTRUCTOR - 41)) | (1usize << (BY - 41)) | (1usize << (COMPANION - 41)) | (1usize << (INIT - 41)) | (1usize << (WHERE - 41)) | (1usize << (CATCH - 41)) | (1usize << (FINALLY - 41)))) != 0) || ((((_la - 107)) & !0x3f) == 0 && ((1usize << (_la - 107)) & ((1usize << (OUT - 107)) | (1usize << (DYNAMIC - 107)) | (1usize << (PUBLIC - 107)) | (1usize << (PRIVATE - 107)) | (1usize << (PROTECTED - 107)) | (1usize << (INTERNAL - 107)) | (1usize << (ENUM - 107)) | (1usize << (SEALED - 107)) | (1usize << (ANNOTATION - 107)) | (1usize << (DATA - 107)) | (1usize << (INNER - 107)) | (1usize << (VALUE - 107)) | (1usize << (TAILREC - 107)) | (1usize << (OPERATOR - 107)) | (1usize << (INLINE - 107)) | (1usize << (INFIX - 107)) | (1usize << (EXTERNAL - 107)) | (1usize << (SUSPEND - 107)) | (1usize << (OVERRIDE - 107)) | (1usize << (ABSTRACT - 107)) | (1usize << (FINAL - 107)) | (1usize << (OPEN - 107)) | (1usize << (CONST - 107)) | (1usize << (LATEINIT - 107)) | (1usize << (VARARG - 107)) | (1usize << (NOINLINE - 107)) | (1usize << (CROSSINLINE - 107)) | (1usize << (REIFIED - 107)) | (1usize << (EXPECT - 107)) | (1usize << (ACTUAL - 107)) | (1usize << (Identifier - 107)))) != 0) {
				{
				/*InvokeRule enumEntries*/
				recog.base.set_state(1620);
				recog.enumEntries()?;

				}
			}

			recog.base.set_state(1637);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(232,&mut recog.base)? {
				x if x == 1=>{
					{
					recog.base.set_state(1626);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(1623);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(1628);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(1629);
					recog.base.match_token(SEMICOLON,&mut recog.err_handler)?;

					recog.base.set_state(1633);
					recog.err_handler.sync(&mut recog.base)?;
					_alt = recog.interpreter.adaptive_predict(231,&mut recog.base)?;
					while { _alt!=2 && _alt!=INVALID_ALT } {
						if _alt==1 {
							{
							{
							recog.base.set_state(1630);
							recog.base.match_token(NL,&mut recog.err_handler)?;

							}
							} 
						}
						recog.base.set_state(1635);
						recog.err_handler.sync(&mut recog.base)?;
						_alt = recog.interpreter.adaptive_predict(231,&mut recog.base)?;
					}
					/*InvokeRule classMemberDeclarations*/
					recog.base.set_state(1636);
					recog.classMemberDeclarations()?;

					}
				}

				_ => {}
			}
			recog.base.set_state(1642);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(1639);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(1644);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(1645);
			recog.base.match_token(RCURL,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- enumEntries ----------------
pub type EnumEntriesContextAll<'input> = EnumEntriesContext<'input>;


pub type EnumEntriesContext<'input> = BaseParserRuleContext<'input,EnumEntriesContextExt<'input>>;

#[derive(Clone)]
pub struct EnumEntriesContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for EnumEntriesContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for EnumEntriesContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_enumEntries(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_enumEntries(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for EnumEntriesContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_enumEntries(self);
	}
}

impl<'input> CustomRuleContext<'input> for EnumEntriesContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_enumEntries }
	//fn type_rule_index() -> usize where Self: Sized { RULE_enumEntries }
}
antlr_rust::type_id!{EnumEntriesContextExt<'a>}

impl<'input> EnumEntriesContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<EnumEntriesContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,EnumEntriesContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait EnumEntriesContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<EnumEntriesContextExt<'input>>{

fn enumEntry_all(&self) ->  Vec<Rc<EnumEntryContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn enumEntry(&self, i: usize) -> Option<Rc<EnumEntryContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}

}

impl<'input> EnumEntriesContextAttrs<'input> for EnumEntriesContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn enumEntries(&mut self,)
	-> Result<Rc<EnumEntriesContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = EnumEntriesContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 94, RULE_enumEntries);
        let mut _localctx: Rc<EnumEntriesContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule enumEntry*/
			recog.base.set_state(1647);
			recog.enumEntry()?;

			recog.base.set_state(1664);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(236,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					recog.base.set_state(1651);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(1648);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(1653);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(1654);
					recog.base.match_token(COMMA,&mut recog.err_handler)?;

					recog.base.set_state(1658);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(1655);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(1660);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					/*InvokeRule enumEntry*/
					recog.base.set_state(1661);
					recog.enumEntry()?;

					}
					} 
				}
				recog.base.set_state(1666);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(236,&mut recog.base)?;
			}
			recog.base.set_state(1670);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(237,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					recog.base.set_state(1667);
					recog.base.match_token(NL,&mut recog.err_handler)?;

					}
					} 
				}
				recog.base.set_state(1672);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(237,&mut recog.base)?;
			}
			recog.base.set_state(1674);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==COMMA {
				{
				recog.base.set_state(1673);
				recog.base.match_token(COMMA,&mut recog.err_handler)?;

				}
			}

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- enumEntry ----------------
pub type EnumEntryContextAll<'input> = EnumEntryContext<'input>;


pub type EnumEntryContext<'input> = BaseParserRuleContext<'input,EnumEntryContextExt<'input>>;

#[derive(Clone)]
pub struct EnumEntryContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for EnumEntryContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for EnumEntryContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_enumEntry(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_enumEntry(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for EnumEntryContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_enumEntry(self);
	}
}

impl<'input> CustomRuleContext<'input> for EnumEntryContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_enumEntry }
	//fn type_rule_index() -> usize where Self: Sized { RULE_enumEntry }
}
antlr_rust::type_id!{EnumEntryContextExt<'a>}

impl<'input> EnumEntryContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<EnumEntryContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,EnumEntryContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait EnumEntryContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<EnumEntryContextExt<'input>>{

fn simpleIdentifier(&self) -> Option<Rc<SimpleIdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn modifiers(&self) -> Option<Rc<ModifiersContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn valueArguments(&self) -> Option<Rc<ValueArgumentsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn classBody(&self) -> Option<Rc<ClassBodyContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}

}

impl<'input> EnumEntryContextAttrs<'input> for EnumEntryContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn enumEntry(&mut self,)
	-> Result<Rc<EnumEntryContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = EnumEntryContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 96, RULE_enumEntry);
        let mut _localctx: Rc<EnumEntryContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1683);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(240,&mut recog.base)? {
				x if x == 1=>{
					{
					/*InvokeRule modifiers*/
					recog.base.set_state(1676);
					recog.modifiers()?;

					recog.base.set_state(1680);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(1677);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(1682);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					}
				}

				_ => {}
			}
			/*InvokeRule simpleIdentifier*/
			recog.base.set_state(1685);
			recog.simpleIdentifier()?;

			recog.base.set_state(1693);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(242,&mut recog.base)? {
				x if x == 1=>{
					{
					recog.base.set_state(1689);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(1686);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(1691);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					/*InvokeRule valueArguments*/
					recog.base.set_state(1692);
					recog.valueArguments()?;

					}
				}

				_ => {}
			}
			recog.base.set_state(1702);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(244,&mut recog.base)? {
				x if x == 1=>{
					{
					recog.base.set_state(1698);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(1695);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(1700);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					/*InvokeRule classBody*/
					recog.base.set_state(1701);
					recog.classBody()?;

					}
				}

				_ => {}
			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- type ----------------
pub type TypeContextAll<'input> = TypeContext<'input>;


pub type TypeContext<'input> = BaseParserRuleContext<'input,TypeContextExt<'input>>;

#[derive(Clone)]
pub struct TypeContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for TypeContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for TypeContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_type(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_type(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for TypeContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_type(self);
	}
}

impl<'input> CustomRuleContext<'input> for TypeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_type }
	//fn type_rule_index() -> usize where Self: Sized { RULE_type }
}
antlr_rust::type_id!{TypeContextExt<'a>}

impl<'input> TypeContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<TypeContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,TypeContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait TypeContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<TypeContextExt<'input>>{

fn functionType(&self) -> Option<Rc<FunctionTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn parenthesizedType(&self) -> Option<Rc<ParenthesizedTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn nullableType(&self) -> Option<Rc<NullableTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn typeReference(&self) -> Option<Rc<TypeReferenceContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn definitelyNonNullableType(&self) -> Option<Rc<DefinitelyNonNullableTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn typeModifiers(&self) -> Option<Rc<TypeModifiersContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> TypeContextAttrs<'input> for TypeContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn type(&mut self,)
	-> Result<Rc<TypeContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = TypeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 98, RULE_type);
        let mut _localctx: Rc<TypeContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1705);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(245,&mut recog.base)? {
				x if x == 1=>{
					{
					/*InvokeRule typeModifiers*/
					recog.base.set_state(1704);
					recog.typeModifiers()?;

					}
				}

				_ => {}
			}
			recog.base.set_state(1712);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(246,&mut recog.base)? {
				1 =>{
					{
					/*InvokeRule functionType*/
					recog.base.set_state(1707);
					recog.functionType()?;

					}
				}
			,
				2 =>{
					{
					/*InvokeRule parenthesizedType*/
					recog.base.set_state(1708);
					recog.parenthesizedType()?;

					}
				}
			,
				3 =>{
					{
					/*InvokeRule nullableType*/
					recog.base.set_state(1709);
					recog.nullableType()?;

					}
				}
			,
				4 =>{
					{
					/*InvokeRule typeReference*/
					recog.base.set_state(1710);
					recog.typeReference()?;

					}
				}
			,
				5 =>{
					{
					/*InvokeRule definitelyNonNullableType*/
					recog.base.set_state(1711);
					recog.definitelyNonNullableType()?;

					}
				}

				_ => {}
			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- typeReference ----------------
pub type TypeReferenceContextAll<'input> = TypeReferenceContext<'input>;


pub type TypeReferenceContext<'input> = BaseParserRuleContext<'input,TypeReferenceContextExt<'input>>;

#[derive(Clone)]
pub struct TypeReferenceContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for TypeReferenceContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for TypeReferenceContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_typeReference(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_typeReference(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for TypeReferenceContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_typeReference(self);
	}
}

impl<'input> CustomRuleContext<'input> for TypeReferenceContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_typeReference }
	//fn type_rule_index() -> usize where Self: Sized { RULE_typeReference }
}
antlr_rust::type_id!{TypeReferenceContextExt<'a>}

impl<'input> TypeReferenceContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<TypeReferenceContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,TypeReferenceContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait TypeReferenceContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<TypeReferenceContextExt<'input>>{

fn userType(&self) -> Option<Rc<UserTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token DYNAMIC
/// Returns `None` if there is no child corresponding to token DYNAMIC
fn DYNAMIC(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(DYNAMIC, 0)
}

}

impl<'input> TypeReferenceContextAttrs<'input> for TypeReferenceContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn typeReference(&mut self,)
	-> Result<Rc<TypeReferenceContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = TypeReferenceContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 100, RULE_typeReference);
        let mut _localctx: Rc<TypeReferenceContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			recog.base.set_state(1716);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(247,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule userType*/
					recog.base.set_state(1714);
					recog.userType()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(1715);
					recog.base.match_token(DYNAMIC,&mut recog.err_handler)?;

					}
				}

				_ => {}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- nullableType ----------------
pub type NullableTypeContextAll<'input> = NullableTypeContext<'input>;


pub type NullableTypeContext<'input> = BaseParserRuleContext<'input,NullableTypeContextExt<'input>>;

#[derive(Clone)]
pub struct NullableTypeContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for NullableTypeContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for NullableTypeContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_nullableType(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_nullableType(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for NullableTypeContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_nullableType(self);
	}
}

impl<'input> CustomRuleContext<'input> for NullableTypeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_nullableType }
	//fn type_rule_index() -> usize where Self: Sized { RULE_nullableType }
}
antlr_rust::type_id!{NullableTypeContextExt<'a>}

impl<'input> NullableTypeContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<NullableTypeContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,NullableTypeContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait NullableTypeContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<NullableTypeContextExt<'input>>{

fn typeReference(&self) -> Option<Rc<TypeReferenceContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn parenthesizedType(&self) -> Option<Rc<ParenthesizedTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}
fn quest_all(&self) ->  Vec<Rc<QuestContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn quest(&self, i: usize) -> Option<Rc<QuestContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> NullableTypeContextAttrs<'input> for NullableTypeContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn nullableType(&mut self,)
	-> Result<Rc<NullableTypeContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = NullableTypeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 102, RULE_nullableType);
        let mut _localctx: Rc<NullableTypeContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1720);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 FILE | FIELD | PROPERTY | GET | SET | RECEIVER | PARAM | SETPARAM | DELEGATE |
			 IMPORT | CONSTRUCTOR | BY | COMPANION | INIT | WHERE | CATCH | FINALLY |
			 OUT | DYNAMIC | PUBLIC | PRIVATE | PROTECTED | INTERNAL | ENUM | SEALED |
			 ANNOTATION | DATA | INNER | VALUE | TAILREC | OPERATOR | INLINE | INFIX |
			 EXTERNAL | SUSPEND | OVERRIDE | ABSTRACT | FINAL | OPEN | CONST | LATEINIT |
			 VARARG | NOINLINE | CROSSINLINE | REIFIED | EXPECT | ACTUAL | Identifier 
				=> {
					{
					/*InvokeRule typeReference*/
					recog.base.set_state(1718);
					recog.typeReference()?;

					}
				}

			 LPAREN 
				=> {
					{
					/*InvokeRule parenthesizedType*/
					recog.base.set_state(1719);
					recog.parenthesizedType()?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			recog.base.set_state(1725);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(1722);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(1727);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(1729); 
			recog.err_handler.sync(&mut recog.base)?;
			_alt = 1;
			loop {
				match _alt {
				    x if x == 1=>
					{
					{
					/*InvokeRule quest*/
					recog.base.set_state(1728);
					recog.quest()?;

					}
					}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
				}
				recog.base.set_state(1731); 
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(250,&mut recog.base)?;
				if _alt==2 || _alt==INVALID_ALT { break }
			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- quest ----------------
pub type QuestContextAll<'input> = QuestContext<'input>;


pub type QuestContext<'input> = BaseParserRuleContext<'input,QuestContextExt<'input>>;

#[derive(Clone)]
pub struct QuestContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for QuestContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for QuestContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_quest(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_quest(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for QuestContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_quest(self);
	}
}

impl<'input> CustomRuleContext<'input> for QuestContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_quest }
	//fn type_rule_index() -> usize where Self: Sized { RULE_quest }
}
antlr_rust::type_id!{QuestContextExt<'a>}

impl<'input> QuestContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<QuestContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,QuestContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait QuestContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<QuestContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token QUEST_NO_WS
/// Returns `None` if there is no child corresponding to token QUEST_NO_WS
fn QUEST_NO_WS(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(QUEST_NO_WS, 0)
}
/// Retrieves first TerminalNode corresponding to token QUEST_WS
/// Returns `None` if there is no child corresponding to token QUEST_WS
fn QUEST_WS(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(QUEST_WS, 0)
}

}

impl<'input> QuestContextAttrs<'input> for QuestContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn quest(&mut self,)
	-> Result<Rc<QuestContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = QuestContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 104, RULE_quest);
        let mut _localctx: Rc<QuestContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1733);
			_la = recog.base.input.la(1);
			if { !(_la==QUEST_WS || _la==QUEST_NO_WS) } {
				recog.err_handler.recover_inline(&mut recog.base)?;

			}
			else {
				if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
				recog.err_handler.report_match(&mut recog.base);
				recog.base.consume(&mut recog.err_handler);
			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- userType ----------------
pub type UserTypeContextAll<'input> = UserTypeContext<'input>;


pub type UserTypeContext<'input> = BaseParserRuleContext<'input,UserTypeContextExt<'input>>;

#[derive(Clone)]
pub struct UserTypeContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for UserTypeContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for UserTypeContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_userType(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_userType(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for UserTypeContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_userType(self);
	}
}

impl<'input> CustomRuleContext<'input> for UserTypeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_userType }
	//fn type_rule_index() -> usize where Self: Sized { RULE_userType }
}
antlr_rust::type_id!{UserTypeContextExt<'a>}

impl<'input> UserTypeContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<UserTypeContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,UserTypeContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait UserTypeContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<UserTypeContextExt<'input>>{

fn simpleUserType_all(&self) ->  Vec<Rc<SimpleUserTypeContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn simpleUserType(&self, i: usize) -> Option<Rc<SimpleUserTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token DOT in current rule
fn DOT_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token DOT, starting from 0.
/// Returns `None` if number of children corresponding to token DOT is less or equal than `i`.
fn DOT(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(DOT, i)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}

}

impl<'input> UserTypeContextAttrs<'input> for UserTypeContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn userType(&mut self,)
	-> Result<Rc<UserTypeContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = UserTypeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 106, RULE_userType);
        let mut _localctx: Rc<UserTypeContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule simpleUserType*/
			recog.base.set_state(1735);
			recog.simpleUserType()?;

			recog.base.set_state(1752);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(253,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					recog.base.set_state(1739);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(1736);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(1741);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(1742);
					recog.base.match_token(DOT,&mut recog.err_handler)?;

					recog.base.set_state(1746);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(1743);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(1748);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					/*InvokeRule simpleUserType*/
					recog.base.set_state(1749);
					recog.simpleUserType()?;

					}
					} 
				}
				recog.base.set_state(1754);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(253,&mut recog.base)?;
			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- simpleUserType ----------------
pub type SimpleUserTypeContextAll<'input> = SimpleUserTypeContext<'input>;


pub type SimpleUserTypeContext<'input> = BaseParserRuleContext<'input,SimpleUserTypeContextExt<'input>>;

#[derive(Clone)]
pub struct SimpleUserTypeContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for SimpleUserTypeContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for SimpleUserTypeContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_simpleUserType(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_simpleUserType(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for SimpleUserTypeContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_simpleUserType(self);
	}
}

impl<'input> CustomRuleContext<'input> for SimpleUserTypeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_simpleUserType }
	//fn type_rule_index() -> usize where Self: Sized { RULE_simpleUserType }
}
antlr_rust::type_id!{SimpleUserTypeContextExt<'a>}

impl<'input> SimpleUserTypeContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<SimpleUserTypeContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,SimpleUserTypeContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait SimpleUserTypeContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<SimpleUserTypeContextExt<'input>>{

fn simpleIdentifier(&self) -> Option<Rc<SimpleIdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn typeArguments(&self) -> Option<Rc<TypeArgumentsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}

}

impl<'input> SimpleUserTypeContextAttrs<'input> for SimpleUserTypeContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn simpleUserType(&mut self,)
	-> Result<Rc<SimpleUserTypeContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = SimpleUserTypeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 108, RULE_simpleUserType);
        let mut _localctx: Rc<SimpleUserTypeContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule simpleIdentifier*/
			recog.base.set_state(1755);
			recog.simpleIdentifier()?;

			recog.base.set_state(1763);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(255,&mut recog.base)? {
				x if x == 1=>{
					{
					recog.base.set_state(1759);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(1756);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(1761);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					/*InvokeRule typeArguments*/
					recog.base.set_state(1762);
					recog.typeArguments()?;

					}
				}

				_ => {}
			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- typeProjection ----------------
pub type TypeProjectionContextAll<'input> = TypeProjectionContext<'input>;


pub type TypeProjectionContext<'input> = BaseParserRuleContext<'input,TypeProjectionContextExt<'input>>;

#[derive(Clone)]
pub struct TypeProjectionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for TypeProjectionContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for TypeProjectionContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_typeProjection(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_typeProjection(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for TypeProjectionContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_typeProjection(self);
	}
}

impl<'input> CustomRuleContext<'input> for TypeProjectionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_typeProjection }
	//fn type_rule_index() -> usize where Self: Sized { RULE_typeProjection }
}
antlr_rust::type_id!{TypeProjectionContextExt<'a>}

impl<'input> TypeProjectionContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<TypeProjectionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,TypeProjectionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait TypeProjectionContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<TypeProjectionContextExt<'input>>{

fn type(&self) -> Option<Rc<TypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn typeProjectionModifiers(&self) -> Option<Rc<TypeProjectionModifiersContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token MULT
/// Returns `None` if there is no child corresponding to token MULT
fn MULT(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(MULT, 0)
}

}

impl<'input> TypeProjectionContextAttrs<'input> for TypeProjectionContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn typeProjection(&mut self,)
	-> Result<Rc<TypeProjectionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = TypeProjectionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 110, RULE_typeProjection);
        let mut _localctx: Rc<TypeProjectionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			recog.base.set_state(1770);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 LPAREN | AT_NO_WS | AT_PRE_WS | FILE | FIELD | PROPERTY | GET | SET |
			 RECEIVER | PARAM | SETPARAM | DELEGATE | IMPORT | CONSTRUCTOR | BY |
			 COMPANION | INIT | WHERE | CATCH | FINALLY | IN | OUT | DYNAMIC | PUBLIC |
			 PRIVATE | PROTECTED | INTERNAL | ENUM | SEALED | ANNOTATION | DATA |
			 INNER | VALUE | TAILREC | OPERATOR | INLINE | INFIX | EXTERNAL | SUSPEND |
			 OVERRIDE | ABSTRACT | FINAL | OPEN | CONST | LATEINIT | VARARG | NOINLINE |
			 CROSSINLINE | REIFIED | EXPECT | ACTUAL | Identifier 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					recog.base.set_state(1766);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(256,&mut recog.base)? {
						x if x == 1=>{
							{
							/*InvokeRule typeProjectionModifiers*/
							recog.base.set_state(1765);
							recog.typeProjectionModifiers()?;

							}
						}

						_ => {}
					}
					/*InvokeRule type*/
					recog.base.set_state(1768);
					recog.type()?;

					}
				}

			 MULT 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(1769);
					recog.base.match_token(MULT,&mut recog.err_handler)?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- typeProjectionModifiers ----------------
pub type TypeProjectionModifiersContextAll<'input> = TypeProjectionModifiersContext<'input>;


pub type TypeProjectionModifiersContext<'input> = BaseParserRuleContext<'input,TypeProjectionModifiersContextExt<'input>>;

#[derive(Clone)]
pub struct TypeProjectionModifiersContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for TypeProjectionModifiersContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for TypeProjectionModifiersContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_typeProjectionModifiers(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_typeProjectionModifiers(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for TypeProjectionModifiersContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_typeProjectionModifiers(self);
	}
}

impl<'input> CustomRuleContext<'input> for TypeProjectionModifiersContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_typeProjectionModifiers }
	//fn type_rule_index() -> usize where Self: Sized { RULE_typeProjectionModifiers }
}
antlr_rust::type_id!{TypeProjectionModifiersContextExt<'a>}

impl<'input> TypeProjectionModifiersContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<TypeProjectionModifiersContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,TypeProjectionModifiersContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait TypeProjectionModifiersContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<TypeProjectionModifiersContextExt<'input>>{

fn typeProjectionModifier_all(&self) ->  Vec<Rc<TypeProjectionModifierContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn typeProjectionModifier(&self, i: usize) -> Option<Rc<TypeProjectionModifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> TypeProjectionModifiersContextAttrs<'input> for TypeProjectionModifiersContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn typeProjectionModifiers(&mut self,)
	-> Result<Rc<TypeProjectionModifiersContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = TypeProjectionModifiersContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 112, RULE_typeProjectionModifiers);
        let mut _localctx: Rc<TypeProjectionModifiersContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1773); 
			recog.err_handler.sync(&mut recog.base)?;
			_alt = 1;
			loop {
				match _alt {
				    x if x == 1=>
					{
					{
					/*InvokeRule typeProjectionModifier*/
					recog.base.set_state(1772);
					recog.typeProjectionModifier()?;

					}
					}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
				}
				recog.base.set_state(1775); 
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(258,&mut recog.base)?;
				if _alt==2 || _alt==INVALID_ALT { break }
			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- typeProjectionModifier ----------------
pub type TypeProjectionModifierContextAll<'input> = TypeProjectionModifierContext<'input>;


pub type TypeProjectionModifierContext<'input> = BaseParserRuleContext<'input,TypeProjectionModifierContextExt<'input>>;

#[derive(Clone)]
pub struct TypeProjectionModifierContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for TypeProjectionModifierContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for TypeProjectionModifierContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_typeProjectionModifier(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_typeProjectionModifier(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for TypeProjectionModifierContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_typeProjectionModifier(self);
	}
}

impl<'input> CustomRuleContext<'input> for TypeProjectionModifierContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_typeProjectionModifier }
	//fn type_rule_index() -> usize where Self: Sized { RULE_typeProjectionModifier }
}
antlr_rust::type_id!{TypeProjectionModifierContextExt<'a>}

impl<'input> TypeProjectionModifierContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<TypeProjectionModifierContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,TypeProjectionModifierContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait TypeProjectionModifierContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<TypeProjectionModifierContextExt<'input>>{

fn varianceModifier(&self) -> Option<Rc<VarianceModifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}
fn annotation(&self) -> Option<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> TypeProjectionModifierContextAttrs<'input> for TypeProjectionModifierContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn typeProjectionModifier(&mut self,)
	-> Result<Rc<TypeProjectionModifierContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = TypeProjectionModifierContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 114, RULE_typeProjectionModifier);
        let mut _localctx: Rc<TypeProjectionModifierContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			recog.base.set_state(1785);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 IN | OUT 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule varianceModifier*/
					recog.base.set_state(1777);
					recog.varianceModifier()?;

					recog.base.set_state(1781);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(1778);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(1783);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					}
				}

			 AT_NO_WS | AT_PRE_WS 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule annotation*/
					recog.base.set_state(1784);
					recog.annotation()?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- functionType ----------------
pub type FunctionTypeContextAll<'input> = FunctionTypeContext<'input>;


pub type FunctionTypeContext<'input> = BaseParserRuleContext<'input,FunctionTypeContextExt<'input>>;

#[derive(Clone)]
pub struct FunctionTypeContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for FunctionTypeContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for FunctionTypeContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_functionType(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_functionType(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for FunctionTypeContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_functionType(self);
	}
}

impl<'input> CustomRuleContext<'input> for FunctionTypeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_functionType }
	//fn type_rule_index() -> usize where Self: Sized { RULE_functionType }
}
antlr_rust::type_id!{FunctionTypeContextExt<'a>}

impl<'input> FunctionTypeContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<FunctionTypeContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,FunctionTypeContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait FunctionTypeContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<FunctionTypeContextExt<'input>>{

fn functionTypeParameters(&self) -> Option<Rc<FunctionTypeParametersContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token ARROW
/// Returns `None` if there is no child corresponding to token ARROW
fn ARROW(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(ARROW, 0)
}
fn type(&self) -> Option<Rc<TypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn receiverType(&self) -> Option<Rc<ReceiverTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token DOT
/// Returns `None` if there is no child corresponding to token DOT
fn DOT(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(DOT, 0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}

}

impl<'input> FunctionTypeContextAttrs<'input> for FunctionTypeContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn functionType(&mut self,)
	-> Result<Rc<FunctionTypeContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = FunctionTypeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 116, RULE_functionType);
        let mut _localctx: Rc<FunctionTypeContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1801);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(263,&mut recog.base)? {
				x if x == 1=>{
					{
					/*InvokeRule receiverType*/
					recog.base.set_state(1787);
					recog.receiverType()?;

					recog.base.set_state(1791);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(1788);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(1793);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(1794);
					recog.base.match_token(DOT,&mut recog.err_handler)?;

					recog.base.set_state(1798);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(1795);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(1800);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					}
				}

				_ => {}
			}
			/*InvokeRule functionTypeParameters*/
			recog.base.set_state(1803);
			recog.functionTypeParameters()?;

			recog.base.set_state(1807);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(1804);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(1809);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(1810);
			recog.base.match_token(ARROW,&mut recog.err_handler)?;

			recog.base.set_state(1814);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(1811);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(1816);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			/*InvokeRule type*/
			recog.base.set_state(1817);
			recog.type()?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- functionTypeParameters ----------------
pub type FunctionTypeParametersContextAll<'input> = FunctionTypeParametersContext<'input>;


pub type FunctionTypeParametersContext<'input> = BaseParserRuleContext<'input,FunctionTypeParametersContextExt<'input>>;

#[derive(Clone)]
pub struct FunctionTypeParametersContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for FunctionTypeParametersContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for FunctionTypeParametersContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_functionTypeParameters(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_functionTypeParameters(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for FunctionTypeParametersContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_functionTypeParameters(self);
	}
}

impl<'input> CustomRuleContext<'input> for FunctionTypeParametersContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_functionTypeParameters }
	//fn type_rule_index() -> usize where Self: Sized { RULE_functionTypeParameters }
}
antlr_rust::type_id!{FunctionTypeParametersContextExt<'a>}

impl<'input> FunctionTypeParametersContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<FunctionTypeParametersContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,FunctionTypeParametersContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait FunctionTypeParametersContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<FunctionTypeParametersContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token LPAREN
/// Returns `None` if there is no child corresponding to token LPAREN
fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(LPAREN, 0)
}
/// Retrieves first TerminalNode corresponding to token RPAREN
/// Returns `None` if there is no child corresponding to token RPAREN
fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(RPAREN, 0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}
fn parameter_all(&self) ->  Vec<Rc<ParameterContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn parameter(&self, i: usize) -> Option<Rc<ParameterContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn type_all(&self) ->  Vec<Rc<TypeContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn type(&self, i: usize) -> Option<Rc<TypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}

}

impl<'input> FunctionTypeParametersContextAttrs<'input> for FunctionTypeParametersContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn functionTypeParameters(&mut self,)
	-> Result<Rc<FunctionTypeParametersContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = FunctionTypeParametersContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 118, RULE_functionTypeParameters);
        let mut _localctx: Rc<FunctionTypeParametersContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1819);
			recog.base.match_token(LPAREN,&mut recog.err_handler)?;

			recog.base.set_state(1823);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(266,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					recog.base.set_state(1820);
					recog.base.match_token(NL,&mut recog.err_handler)?;

					}
					} 
				}
				recog.base.set_state(1825);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(266,&mut recog.base)?;
			}
			recog.base.set_state(1828);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(267,&mut recog.base)? {
				x if x == 1=>{
					{
					/*InvokeRule parameter*/
					recog.base.set_state(1826);
					recog.parameter()?;

					}
				}

				x if x == 2=>{
					{
					/*InvokeRule type*/
					recog.base.set_state(1827);
					recog.type()?;

					}
				}

				_ => {}
			}
			recog.base.set_state(1849);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(271,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					recog.base.set_state(1833);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(1830);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(1835);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(1836);
					recog.base.match_token(COMMA,&mut recog.err_handler)?;

					recog.base.set_state(1840);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(1837);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(1842);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(1845);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(270,&mut recog.base)? {
						1 =>{
							{
							/*InvokeRule parameter*/
							recog.base.set_state(1843);
							recog.parameter()?;

							}
						}
					,
						2 =>{
							{
							/*InvokeRule type*/
							recog.base.set_state(1844);
							recog.type()?;

							}
						}

						_ => {}
					}
					}
					} 
				}
				recog.base.set_state(1851);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(271,&mut recog.base)?;
			}
			recog.base.set_state(1859);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(273,&mut recog.base)? {
				x if x == 1=>{
					{
					recog.base.set_state(1855);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(1852);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(1857);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(1858);
					recog.base.match_token(COMMA,&mut recog.err_handler)?;

					}
				}

				_ => {}
			}
			recog.base.set_state(1864);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(1861);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(1866);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(1867);
			recog.base.match_token(RPAREN,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- parenthesizedType ----------------
pub type ParenthesizedTypeContextAll<'input> = ParenthesizedTypeContext<'input>;


pub type ParenthesizedTypeContext<'input> = BaseParserRuleContext<'input,ParenthesizedTypeContextExt<'input>>;

#[derive(Clone)]
pub struct ParenthesizedTypeContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for ParenthesizedTypeContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for ParenthesizedTypeContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_parenthesizedType(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_parenthesizedType(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for ParenthesizedTypeContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_parenthesizedType(self);
	}
}

impl<'input> CustomRuleContext<'input> for ParenthesizedTypeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_parenthesizedType }
	//fn type_rule_index() -> usize where Self: Sized { RULE_parenthesizedType }
}
antlr_rust::type_id!{ParenthesizedTypeContextExt<'a>}

impl<'input> ParenthesizedTypeContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ParenthesizedTypeContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ParenthesizedTypeContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ParenthesizedTypeContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<ParenthesizedTypeContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token LPAREN
/// Returns `None` if there is no child corresponding to token LPAREN
fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(LPAREN, 0)
}
fn type(&self) -> Option<Rc<TypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token RPAREN
/// Returns `None` if there is no child corresponding to token RPAREN
fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(RPAREN, 0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}

}

impl<'input> ParenthesizedTypeContextAttrs<'input> for ParenthesizedTypeContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn parenthesizedType(&mut self,)
	-> Result<Rc<ParenthesizedTypeContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ParenthesizedTypeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 120, RULE_parenthesizedType);
        let mut _localctx: Rc<ParenthesizedTypeContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1869);
			recog.base.match_token(LPAREN,&mut recog.err_handler)?;

			recog.base.set_state(1873);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(1870);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(1875);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			/*InvokeRule type*/
			recog.base.set_state(1876);
			recog.type()?;

			recog.base.set_state(1880);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(1877);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(1882);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(1883);
			recog.base.match_token(RPAREN,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- receiverType ----------------
pub type ReceiverTypeContextAll<'input> = ReceiverTypeContext<'input>;


pub type ReceiverTypeContext<'input> = BaseParserRuleContext<'input,ReceiverTypeContextExt<'input>>;

#[derive(Clone)]
pub struct ReceiverTypeContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for ReceiverTypeContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for ReceiverTypeContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_receiverType(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_receiverType(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for ReceiverTypeContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_receiverType(self);
	}
}

impl<'input> CustomRuleContext<'input> for ReceiverTypeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_receiverType }
	//fn type_rule_index() -> usize where Self: Sized { RULE_receiverType }
}
antlr_rust::type_id!{ReceiverTypeContextExt<'a>}

impl<'input> ReceiverTypeContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ReceiverTypeContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ReceiverTypeContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ReceiverTypeContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<ReceiverTypeContextExt<'input>>{

fn parenthesizedType(&self) -> Option<Rc<ParenthesizedTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn nullableType(&self) -> Option<Rc<NullableTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn typeReference(&self) -> Option<Rc<TypeReferenceContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn typeModifiers(&self) -> Option<Rc<TypeModifiersContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ReceiverTypeContextAttrs<'input> for ReceiverTypeContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn receiverType(&mut self,)
	-> Result<Rc<ReceiverTypeContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ReceiverTypeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 122, RULE_receiverType);
        let mut _localctx: Rc<ReceiverTypeContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1886);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(277,&mut recog.base)? {
				x if x == 1=>{
					{
					/*InvokeRule typeModifiers*/
					recog.base.set_state(1885);
					recog.typeModifiers()?;

					}
				}

				_ => {}
			}
			recog.base.set_state(1891);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(278,&mut recog.base)? {
				1 =>{
					{
					/*InvokeRule parenthesizedType*/
					recog.base.set_state(1888);
					recog.parenthesizedType()?;

					}
				}
			,
				2 =>{
					{
					/*InvokeRule nullableType*/
					recog.base.set_state(1889);
					recog.nullableType()?;

					}
				}
			,
				3 =>{
					{
					/*InvokeRule typeReference*/
					recog.base.set_state(1890);
					recog.typeReference()?;

					}
				}

				_ => {}
			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- parenthesizedUserType ----------------
pub type ParenthesizedUserTypeContextAll<'input> = ParenthesizedUserTypeContext<'input>;


pub type ParenthesizedUserTypeContext<'input> = BaseParserRuleContext<'input,ParenthesizedUserTypeContextExt<'input>>;

#[derive(Clone)]
pub struct ParenthesizedUserTypeContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for ParenthesizedUserTypeContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for ParenthesizedUserTypeContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_parenthesizedUserType(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_parenthesizedUserType(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for ParenthesizedUserTypeContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_parenthesizedUserType(self);
	}
}

impl<'input> CustomRuleContext<'input> for ParenthesizedUserTypeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_parenthesizedUserType }
	//fn type_rule_index() -> usize where Self: Sized { RULE_parenthesizedUserType }
}
antlr_rust::type_id!{ParenthesizedUserTypeContextExt<'a>}

impl<'input> ParenthesizedUserTypeContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ParenthesizedUserTypeContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ParenthesizedUserTypeContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ParenthesizedUserTypeContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<ParenthesizedUserTypeContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token LPAREN
/// Returns `None` if there is no child corresponding to token LPAREN
fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(LPAREN, 0)
}
/// Retrieves first TerminalNode corresponding to token RPAREN
/// Returns `None` if there is no child corresponding to token RPAREN
fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(RPAREN, 0)
}
fn userType(&self) -> Option<Rc<UserTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn parenthesizedUserType(&self) -> Option<Rc<ParenthesizedUserTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}

}

impl<'input> ParenthesizedUserTypeContextAttrs<'input> for ParenthesizedUserTypeContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn parenthesizedUserType(&mut self,)
	-> Result<Rc<ParenthesizedUserTypeContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ParenthesizedUserTypeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 124, RULE_parenthesizedUserType);
        let mut _localctx: Rc<ParenthesizedUserTypeContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1893);
			recog.base.match_token(LPAREN,&mut recog.err_handler)?;

			recog.base.set_state(1897);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(1894);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(1899);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(1902);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 FILE | FIELD | PROPERTY | GET | SET | RECEIVER | PARAM | SETPARAM | DELEGATE |
			 IMPORT | CONSTRUCTOR | BY | COMPANION | INIT | WHERE | CATCH | FINALLY |
			 OUT | DYNAMIC | PUBLIC | PRIVATE | PROTECTED | INTERNAL | ENUM | SEALED |
			 ANNOTATION | DATA | INNER | VALUE | TAILREC | OPERATOR | INLINE | INFIX |
			 EXTERNAL | SUSPEND | OVERRIDE | ABSTRACT | FINAL | OPEN | CONST | LATEINIT |
			 VARARG | NOINLINE | CROSSINLINE | REIFIED | EXPECT | ACTUAL | Identifier 
				=> {
					{
					/*InvokeRule userType*/
					recog.base.set_state(1900);
					recog.userType()?;

					}
				}

			 LPAREN 
				=> {
					{
					/*InvokeRule parenthesizedUserType*/
					recog.base.set_state(1901);
					recog.parenthesizedUserType()?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			recog.base.set_state(1907);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(1904);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(1909);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(1910);
			recog.base.match_token(RPAREN,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- definitelyNonNullableType ----------------
pub type DefinitelyNonNullableTypeContextAll<'input> = DefinitelyNonNullableTypeContext<'input>;


pub type DefinitelyNonNullableTypeContext<'input> = BaseParserRuleContext<'input,DefinitelyNonNullableTypeContextExt<'input>>;

#[derive(Clone)]
pub struct DefinitelyNonNullableTypeContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for DefinitelyNonNullableTypeContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for DefinitelyNonNullableTypeContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_definitelyNonNullableType(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_definitelyNonNullableType(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for DefinitelyNonNullableTypeContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_definitelyNonNullableType(self);
	}
}

impl<'input> CustomRuleContext<'input> for DefinitelyNonNullableTypeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_definitelyNonNullableType }
	//fn type_rule_index() -> usize where Self: Sized { RULE_definitelyNonNullableType }
}
antlr_rust::type_id!{DefinitelyNonNullableTypeContextExt<'a>}

impl<'input> DefinitelyNonNullableTypeContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<DefinitelyNonNullableTypeContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,DefinitelyNonNullableTypeContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait DefinitelyNonNullableTypeContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<DefinitelyNonNullableTypeContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token AMP
/// Returns `None` if there is no child corresponding to token AMP
fn AMP(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(AMP, 0)
}
fn userType_all(&self) ->  Vec<Rc<UserTypeContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn userType(&self, i: usize) -> Option<Rc<UserTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn parenthesizedUserType_all(&self) ->  Vec<Rc<ParenthesizedUserTypeContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn parenthesizedUserType(&self, i: usize) -> Option<Rc<ParenthesizedUserTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn typeModifiers_all(&self) ->  Vec<Rc<TypeModifiersContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn typeModifiers(&self, i: usize) -> Option<Rc<TypeModifiersContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}

}

impl<'input> DefinitelyNonNullableTypeContextAttrs<'input> for DefinitelyNonNullableTypeContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn definitelyNonNullableType(&mut self,)
	-> Result<Rc<DefinitelyNonNullableTypeContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = DefinitelyNonNullableTypeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 126, RULE_definitelyNonNullableType);
        let mut _localctx: Rc<DefinitelyNonNullableTypeContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1913);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(282,&mut recog.base)? {
				x if x == 1=>{
					{
					/*InvokeRule typeModifiers*/
					recog.base.set_state(1912);
					recog.typeModifiers()?;

					}
				}

				_ => {}
			}
			recog.base.set_state(1917);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 FILE | FIELD | PROPERTY | GET | SET | RECEIVER | PARAM | SETPARAM | DELEGATE |
			 IMPORT | CONSTRUCTOR | BY | COMPANION | INIT | WHERE | CATCH | FINALLY |
			 OUT | DYNAMIC | PUBLIC | PRIVATE | PROTECTED | INTERNAL | ENUM | SEALED |
			 ANNOTATION | DATA | INNER | VALUE | TAILREC | OPERATOR | INLINE | INFIX |
			 EXTERNAL | SUSPEND | OVERRIDE | ABSTRACT | FINAL | OPEN | CONST | LATEINIT |
			 VARARG | NOINLINE | CROSSINLINE | REIFIED | EXPECT | ACTUAL | Identifier 
				=> {
					{
					/*InvokeRule userType*/
					recog.base.set_state(1915);
					recog.userType()?;

					}
				}

			 LPAREN 
				=> {
					{
					/*InvokeRule parenthesizedUserType*/
					recog.base.set_state(1916);
					recog.parenthesizedUserType()?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			recog.base.set_state(1922);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(1919);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(1924);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(1925);
			recog.base.match_token(AMP,&mut recog.err_handler)?;

			recog.base.set_state(1929);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(1926);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(1931);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(1933);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(286,&mut recog.base)? {
				x if x == 1=>{
					{
					/*InvokeRule typeModifiers*/
					recog.base.set_state(1932);
					recog.typeModifiers()?;

					}
				}

				_ => {}
			}
			recog.base.set_state(1937);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 FILE | FIELD | PROPERTY | GET | SET | RECEIVER | PARAM | SETPARAM | DELEGATE |
			 IMPORT | CONSTRUCTOR | BY | COMPANION | INIT | WHERE | CATCH | FINALLY |
			 OUT | DYNAMIC | PUBLIC | PRIVATE | PROTECTED | INTERNAL | ENUM | SEALED |
			 ANNOTATION | DATA | INNER | VALUE | TAILREC | OPERATOR | INLINE | INFIX |
			 EXTERNAL | SUSPEND | OVERRIDE | ABSTRACT | FINAL | OPEN | CONST | LATEINIT |
			 VARARG | NOINLINE | CROSSINLINE | REIFIED | EXPECT | ACTUAL | Identifier 
				=> {
					{
					/*InvokeRule userType*/
					recog.base.set_state(1935);
					recog.userType()?;

					}
				}

			 LPAREN 
				=> {
					{
					/*InvokeRule parenthesizedUserType*/
					recog.base.set_state(1936);
					recog.parenthesizedUserType()?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- statements ----------------
pub type StatementsContextAll<'input> = StatementsContext<'input>;


pub type StatementsContext<'input> = BaseParserRuleContext<'input,StatementsContextExt<'input>>;

#[derive(Clone)]
pub struct StatementsContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for StatementsContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for StatementsContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_statements(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_statements(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for StatementsContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_statements(self);
	}
}

impl<'input> CustomRuleContext<'input> for StatementsContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_statements }
	//fn type_rule_index() -> usize where Self: Sized { RULE_statements }
}
antlr_rust::type_id!{StatementsContextExt<'a>}

impl<'input> StatementsContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<StatementsContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,StatementsContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait StatementsContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<StatementsContextExt<'input>>{

fn statement_all(&self) ->  Vec<Rc<StatementContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn statement(&self, i: usize) -> Option<Rc<StatementContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn semis_all(&self) ->  Vec<Rc<SemisContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn semis(&self, i: usize) -> Option<Rc<SemisContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> StatementsContextAttrs<'input> for StatementsContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn statements(&mut self,)
	-> Result<Rc<StatementsContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = StatementsContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 128, RULE_statements);
        let mut _localctx: Rc<StatementsContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1948);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(289,&mut recog.base)? {
				x if x == 1=>{
					{
					/*InvokeRule statement*/
					recog.base.set_state(1939);
					recog.statement()?;

					recog.base.set_state(1945);
					recog.err_handler.sync(&mut recog.base)?;
					_alt = recog.interpreter.adaptive_predict(288,&mut recog.base)?;
					while { _alt!=2 && _alt!=INVALID_ALT } {
						if _alt==1 {
							{
							{
							/*InvokeRule semis*/
							recog.base.set_state(1940);
							recog.semis()?;

							/*InvokeRule statement*/
							recog.base.set_state(1941);
							recog.statement()?;

							}
							} 
						}
						recog.base.set_state(1947);
						recog.err_handler.sync(&mut recog.base)?;
						_alt = recog.interpreter.adaptive_predict(288,&mut recog.base)?;
					}
					}
				}

				_ => {}
			}
			recog.base.set_state(1951);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(290,&mut recog.base)? {
				x if x == 1=>{
					{
					/*InvokeRule semis*/
					recog.base.set_state(1950);
					recog.semis()?;

					}
				}

				_ => {}
			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- statement ----------------
pub type StatementContextAll<'input> = StatementContext<'input>;


pub type StatementContext<'input> = BaseParserRuleContext<'input,StatementContextExt<'input>>;

#[derive(Clone)]
pub struct StatementContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for StatementContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for StatementContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_statement(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_statement(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for StatementContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_statement(self);
	}
}

impl<'input> CustomRuleContext<'input> for StatementContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_statement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}
antlr_rust::type_id!{StatementContextExt<'a>}

impl<'input> StatementContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<StatementContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,StatementContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait StatementContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<StatementContextExt<'input>>{

fn declaration(&self) -> Option<Rc<DeclarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn assignment(&self) -> Option<Rc<AssignmentContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn loopStatement(&self) -> Option<Rc<LoopStatementContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn label_all(&self) ->  Vec<Rc<LabelContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn label(&self, i: usize) -> Option<Rc<LabelContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn annotation_all(&self) ->  Vec<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> StatementContextAttrs<'input> for StatementContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn statement(&mut self,)
	-> Result<Rc<StatementContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = StatementContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 130, RULE_statement);
        let mut _localctx: Rc<StatementContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1957);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(292,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					recog.base.set_state(1955);
					recog.err_handler.sync(&mut recog.base)?;
					match recog.base.input.la(1) {
					 FILE | FIELD | PROPERTY | GET | SET | RECEIVER | PARAM | SETPARAM |
					 DELEGATE | IMPORT | CONSTRUCTOR | BY | COMPANION | INIT | WHERE | CATCH |
					 FINALLY | OUT | DYNAMIC | PUBLIC | PRIVATE | PROTECTED | INTERNAL |
					 ENUM | SEALED | ANNOTATION | DATA | INNER | VALUE | TAILREC | OPERATOR |
					 INLINE | INFIX | EXTERNAL | SUSPEND | OVERRIDE | ABSTRACT | FINAL |
					 OPEN | CONST | LATEINIT | VARARG | NOINLINE | CROSSINLINE | REIFIED |
					 EXPECT | ACTUAL | Identifier 
						=> {
							{
							/*InvokeRule label*/
							recog.base.set_state(1953);
							recog.label()?;

							}
						}

					 AT_NO_WS | AT_PRE_WS 
						=> {
							{
							/*InvokeRule annotation*/
							recog.base.set_state(1954);
							recog.annotation()?;

							}
						}

						_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
					}
					} 
				}
				recog.base.set_state(1959);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(292,&mut recog.base)?;
			}
			recog.base.set_state(1964);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(293,&mut recog.base)? {
				1 =>{
					{
					/*InvokeRule declaration*/
					recog.base.set_state(1960);
					recog.declaration()?;

					}
				}
			,
				2 =>{
					{
					/*InvokeRule assignment*/
					recog.base.set_state(1961);
					recog.assignment()?;

					}
				}
			,
				3 =>{
					{
					/*InvokeRule loopStatement*/
					recog.base.set_state(1962);
					recog.loopStatement()?;

					}
				}
			,
				4 =>{
					{
					/*InvokeRule expression*/
					recog.base.set_state(1963);
					recog.expression()?;

					}
				}

				_ => {}
			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- label ----------------
pub type LabelContextAll<'input> = LabelContext<'input>;


pub type LabelContext<'input> = BaseParserRuleContext<'input,LabelContextExt<'input>>;

#[derive(Clone)]
pub struct LabelContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for LabelContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for LabelContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_label(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_label(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for LabelContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_label(self);
	}
}

impl<'input> CustomRuleContext<'input> for LabelContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_label }
	//fn type_rule_index() -> usize where Self: Sized { RULE_label }
}
antlr_rust::type_id!{LabelContextExt<'a>}

impl<'input> LabelContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<LabelContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,LabelContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait LabelContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<LabelContextExt<'input>>{

fn simpleIdentifier(&self) -> Option<Rc<SimpleIdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token AT_NO_WS
/// Returns `None` if there is no child corresponding to token AT_NO_WS
fn AT_NO_WS(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(AT_NO_WS, 0)
}
/// Retrieves first TerminalNode corresponding to token AT_POST_WS
/// Returns `None` if there is no child corresponding to token AT_POST_WS
fn AT_POST_WS(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(AT_POST_WS, 0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}

}

impl<'input> LabelContextAttrs<'input> for LabelContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn label(&mut self,)
	-> Result<Rc<LabelContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = LabelContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 132, RULE_label);
        let mut _localctx: Rc<LabelContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule simpleIdentifier*/
			recog.base.set_state(1966);
			recog.simpleIdentifier()?;

			recog.base.set_state(1967);
			_la = recog.base.input.la(1);
			if { !(_la==AT_NO_WS || _la==AT_POST_WS) } {
				recog.err_handler.recover_inline(&mut recog.base)?;

			}
			else {
				if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
				recog.err_handler.report_match(&mut recog.base);
				recog.base.consume(&mut recog.err_handler);
			}
			recog.base.set_state(1971);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(294,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					recog.base.set_state(1968);
					recog.base.match_token(NL,&mut recog.err_handler)?;

					}
					} 
				}
				recog.base.set_state(1973);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(294,&mut recog.base)?;
			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- controlStructureBody ----------------
pub type ControlStructureBodyContextAll<'input> = ControlStructureBodyContext<'input>;


pub type ControlStructureBodyContext<'input> = BaseParserRuleContext<'input,ControlStructureBodyContextExt<'input>>;

#[derive(Clone)]
pub struct ControlStructureBodyContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for ControlStructureBodyContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for ControlStructureBodyContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_controlStructureBody(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_controlStructureBody(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for ControlStructureBodyContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_controlStructureBody(self);
	}
}

impl<'input> CustomRuleContext<'input> for ControlStructureBodyContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_controlStructureBody }
	//fn type_rule_index() -> usize where Self: Sized { RULE_controlStructureBody }
}
antlr_rust::type_id!{ControlStructureBodyContextExt<'a>}

impl<'input> ControlStructureBodyContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ControlStructureBodyContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ControlStructureBodyContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ControlStructureBodyContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<ControlStructureBodyContextExt<'input>>{

fn block(&self) -> Option<Rc<BlockContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn statement(&self) -> Option<Rc<StatementContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ControlStructureBodyContextAttrs<'input> for ControlStructureBodyContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn controlStructureBody(&mut self,)
	-> Result<Rc<ControlStructureBodyContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ControlStructureBodyContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 134, RULE_controlStructureBody);
        let mut _localctx: Rc<ControlStructureBodyContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			recog.base.set_state(1976);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(295,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule block*/
					recog.base.set_state(1974);
					recog.block()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule statement*/
					recog.base.set_state(1975);
					recog.statement()?;

					}
				}

				_ => {}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- block ----------------
pub type BlockContextAll<'input> = BlockContext<'input>;


pub type BlockContext<'input> = BaseParserRuleContext<'input,BlockContextExt<'input>>;

#[derive(Clone)]
pub struct BlockContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for BlockContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for BlockContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_block(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_block(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for BlockContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_block(self);
	}
}

impl<'input> CustomRuleContext<'input> for BlockContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_block }
	//fn type_rule_index() -> usize where Self: Sized { RULE_block }
}
antlr_rust::type_id!{BlockContextExt<'a>}

impl<'input> BlockContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<BlockContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,BlockContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait BlockContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<BlockContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token LCURL
/// Returns `None` if there is no child corresponding to token LCURL
fn LCURL(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(LCURL, 0)
}
fn statements(&self) -> Option<Rc<StatementsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token RCURL
/// Returns `None` if there is no child corresponding to token RCURL
fn RCURL(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(RCURL, 0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}

}

impl<'input> BlockContextAttrs<'input> for BlockContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn block(&mut self,)
	-> Result<Rc<BlockContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = BlockContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 136, RULE_block);
        let mut _localctx: Rc<BlockContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1978);
			recog.base.match_token(LCURL,&mut recog.err_handler)?;

			recog.base.set_state(1982);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(296,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					recog.base.set_state(1979);
					recog.base.match_token(NL,&mut recog.err_handler)?;

					}
					} 
				}
				recog.base.set_state(1984);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(296,&mut recog.base)?;
			}
			/*InvokeRule statements*/
			recog.base.set_state(1985);
			recog.statements()?;

			recog.base.set_state(1989);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(1986);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(1991);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(1992);
			recog.base.match_token(RCURL,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- loopStatement ----------------
pub type LoopStatementContextAll<'input> = LoopStatementContext<'input>;


pub type LoopStatementContext<'input> = BaseParserRuleContext<'input,LoopStatementContextExt<'input>>;

#[derive(Clone)]
pub struct LoopStatementContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for LoopStatementContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for LoopStatementContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_loopStatement(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_loopStatement(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for LoopStatementContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_loopStatement(self);
	}
}

impl<'input> CustomRuleContext<'input> for LoopStatementContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_loopStatement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_loopStatement }
}
antlr_rust::type_id!{LoopStatementContextExt<'a>}

impl<'input> LoopStatementContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<LoopStatementContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,LoopStatementContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait LoopStatementContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<LoopStatementContextExt<'input>>{

fn forStatement(&self) -> Option<Rc<ForStatementContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn whileStatement(&self) -> Option<Rc<WhileStatementContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn doWhileStatement(&self) -> Option<Rc<DoWhileStatementContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> LoopStatementContextAttrs<'input> for LoopStatementContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn loopStatement(&mut self,)
	-> Result<Rc<LoopStatementContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = LoopStatementContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 138, RULE_loopStatement);
        let mut _localctx: Rc<LoopStatementContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			recog.base.set_state(1997);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 FOR 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule forStatement*/
					recog.base.set_state(1994);
					recog.forStatement()?;

					}
				}

			 WHILE 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule whileStatement*/
					recog.base.set_state(1995);
					recog.whileStatement()?;

					}
				}

			 DO 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					/*InvokeRule doWhileStatement*/
					recog.base.set_state(1996);
					recog.doWhileStatement()?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- forStatement ----------------
pub type ForStatementContextAll<'input> = ForStatementContext<'input>;


pub type ForStatementContext<'input> = BaseParserRuleContext<'input,ForStatementContextExt<'input>>;

#[derive(Clone)]
pub struct ForStatementContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for ForStatementContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for ForStatementContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_forStatement(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_forStatement(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for ForStatementContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_forStatement(self);
	}
}

impl<'input> CustomRuleContext<'input> for ForStatementContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_forStatement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_forStatement }
}
antlr_rust::type_id!{ForStatementContextExt<'a>}

impl<'input> ForStatementContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ForStatementContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ForStatementContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ForStatementContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<ForStatementContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token FOR
/// Returns `None` if there is no child corresponding to token FOR
fn FOR(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(FOR, 0)
}
/// Retrieves first TerminalNode corresponding to token LPAREN
/// Returns `None` if there is no child corresponding to token LPAREN
fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(LPAREN, 0)
}
/// Retrieves first TerminalNode corresponding to token IN
/// Returns `None` if there is no child corresponding to token IN
fn IN(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(IN, 0)
}
fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token RPAREN
/// Returns `None` if there is no child corresponding to token RPAREN
fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(RPAREN, 0)
}
fn variableDeclaration(&self) -> Option<Rc<VariableDeclarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn multiVariableDeclaration(&self) -> Option<Rc<MultiVariableDeclarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}
fn annotation_all(&self) ->  Vec<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn controlStructureBody(&self) -> Option<Rc<ControlStructureBodyContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ForStatementContextAttrs<'input> for ForStatementContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn forStatement(&mut self,)
	-> Result<Rc<ForStatementContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ForStatementContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 140, RULE_forStatement);
        let mut _localctx: Rc<ForStatementContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1999);
			recog.base.match_token(FOR,&mut recog.err_handler)?;

			recog.base.set_state(2003);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(2000);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(2005);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(2006);
			recog.base.match_token(LPAREN,&mut recog.err_handler)?;

			recog.base.set_state(2010);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(300,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					/*InvokeRule annotation*/
					recog.base.set_state(2007);
					recog.annotation()?;

					}
					} 
				}
				recog.base.set_state(2012);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(300,&mut recog.base)?;
			}
			recog.base.set_state(2015);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 NL | AT_NO_WS | AT_PRE_WS | FILE | FIELD | PROPERTY | GET | SET | RECEIVER |
			 PARAM | SETPARAM | DELEGATE | IMPORT | CONSTRUCTOR | BY | COMPANION |
			 INIT | WHERE | CATCH | FINALLY | OUT | DYNAMIC | PUBLIC | PRIVATE | PROTECTED |
			 INTERNAL | ENUM | SEALED | ANNOTATION | DATA | INNER | VALUE | TAILREC |
			 OPERATOR | INLINE | INFIX | EXTERNAL | SUSPEND | OVERRIDE | ABSTRACT |
			 FINAL | OPEN | CONST | LATEINIT | VARARG | NOINLINE | CROSSINLINE | REIFIED |
			 EXPECT | ACTUAL | Identifier 
				=> {
					{
					/*InvokeRule variableDeclaration*/
					recog.base.set_state(2013);
					recog.variableDeclaration()?;

					}
				}

			 LPAREN 
				=> {
					{
					/*InvokeRule multiVariableDeclaration*/
					recog.base.set_state(2014);
					recog.multiVariableDeclaration()?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			recog.base.set_state(2017);
			recog.base.match_token(IN,&mut recog.err_handler)?;

			/*InvokeRule expression*/
			recog.base.set_state(2018);
			recog.expression()?;

			recog.base.set_state(2019);
			recog.base.match_token(RPAREN,&mut recog.err_handler)?;

			recog.base.set_state(2023);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(302,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					recog.base.set_state(2020);
					recog.base.match_token(NL,&mut recog.err_handler)?;

					}
					} 
				}
				recog.base.set_state(2025);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(302,&mut recog.base)?;
			}
			recog.base.set_state(2027);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(303,&mut recog.base)? {
				x if x == 1=>{
					{
					/*InvokeRule controlStructureBody*/
					recog.base.set_state(2026);
					recog.controlStructureBody()?;

					}
				}

				_ => {}
			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- whileStatement ----------------
pub type WhileStatementContextAll<'input> = WhileStatementContext<'input>;


pub type WhileStatementContext<'input> = BaseParserRuleContext<'input,WhileStatementContextExt<'input>>;

#[derive(Clone)]
pub struct WhileStatementContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for WhileStatementContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for WhileStatementContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_whileStatement(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_whileStatement(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for WhileStatementContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_whileStatement(self);
	}
}

impl<'input> CustomRuleContext<'input> for WhileStatementContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_whileStatement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_whileStatement }
}
antlr_rust::type_id!{WhileStatementContextExt<'a>}

impl<'input> WhileStatementContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<WhileStatementContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,WhileStatementContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait WhileStatementContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<WhileStatementContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token WHILE
/// Returns `None` if there is no child corresponding to token WHILE
fn WHILE(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(WHILE, 0)
}
/// Retrieves first TerminalNode corresponding to token LPAREN
/// Returns `None` if there is no child corresponding to token LPAREN
fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(LPAREN, 0)
}
fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token RPAREN
/// Returns `None` if there is no child corresponding to token RPAREN
fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(RPAREN, 0)
}
fn controlStructureBody(&self) -> Option<Rc<ControlStructureBodyContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token SEMICOLON
/// Returns `None` if there is no child corresponding to token SEMICOLON
fn SEMICOLON(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(SEMICOLON, 0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}

}

impl<'input> WhileStatementContextAttrs<'input> for WhileStatementContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn whileStatement(&mut self,)
	-> Result<Rc<WhileStatementContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = WhileStatementContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 142, RULE_whileStatement);
        let mut _localctx: Rc<WhileStatementContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2029);
			recog.base.match_token(WHILE,&mut recog.err_handler)?;

			recog.base.set_state(2033);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(2030);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(2035);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(2036);
			recog.base.match_token(LPAREN,&mut recog.err_handler)?;

			/*InvokeRule expression*/
			recog.base.set_state(2037);
			recog.expression()?;

			recog.base.set_state(2038);
			recog.base.match_token(RPAREN,&mut recog.err_handler)?;

			recog.base.set_state(2042);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(305,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					recog.base.set_state(2039);
					recog.base.match_token(NL,&mut recog.err_handler)?;

					}
					} 
				}
				recog.base.set_state(2044);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(305,&mut recog.base)?;
			}
			recog.base.set_state(2047);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 NL | LPAREN | LSQUARE | LCURL | ADD | SUB | INCR | DECR | EXCL_WS | EXCL_NO_WS |
			 COLONCOLON | AT_NO_WS | AT_PRE_WS | RETURN_AT | CONTINUE_AT | BREAK_AT |
			 THIS_AT | SUPER_AT | FILE | FIELD | PROPERTY | GET | SET | RECEIVER |
			 PARAM | SETPARAM | DELEGATE | IMPORT | CLASS | INTERFACE | FUN | OBJECT |
			 VAL | VAR | TYPE_ALIAS | CONSTRUCTOR | BY | COMPANION | INIT | THIS |
			 SUPER | WHERE | IF | WHEN | TRY | CATCH | FINALLY | FOR | DO | WHILE |
			 THROW | RETURN | CONTINUE | BREAK | OUT | DYNAMIC | PUBLIC | PRIVATE |
			 PROTECTED | INTERNAL | ENUM | SEALED | ANNOTATION | DATA | INNER | VALUE |
			 TAILREC | OPERATOR | INLINE | INFIX | EXTERNAL | SUSPEND | OVERRIDE |
			 ABSTRACT | FINAL | OPEN | CONST | LATEINIT | VARARG | NOINLINE | CROSSINLINE |
			 REIFIED | EXPECT | ACTUAL | RealLiteral | IntegerLiteral | HexLiteral |
			 BinLiteral | UnsignedLiteral | LongLiteral | BooleanLiteral | NullLiteral |
			 CharacterLiteral | Identifier | QUOTE_OPEN | TRIPLE_QUOTE_OPEN 
				=> {
					{
					/*InvokeRule controlStructureBody*/
					recog.base.set_state(2045);
					recog.controlStructureBody()?;

					}
				}

			 SEMICOLON 
				=> {
					{
					recog.base.set_state(2046);
					recog.base.match_token(SEMICOLON,&mut recog.err_handler)?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- doWhileStatement ----------------
pub type DoWhileStatementContextAll<'input> = DoWhileStatementContext<'input>;


pub type DoWhileStatementContext<'input> = BaseParserRuleContext<'input,DoWhileStatementContextExt<'input>>;

#[derive(Clone)]
pub struct DoWhileStatementContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for DoWhileStatementContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for DoWhileStatementContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_doWhileStatement(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_doWhileStatement(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for DoWhileStatementContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_doWhileStatement(self);
	}
}

impl<'input> CustomRuleContext<'input> for DoWhileStatementContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_doWhileStatement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_doWhileStatement }
}
antlr_rust::type_id!{DoWhileStatementContextExt<'a>}

impl<'input> DoWhileStatementContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<DoWhileStatementContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,DoWhileStatementContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait DoWhileStatementContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<DoWhileStatementContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token DO
/// Returns `None` if there is no child corresponding to token DO
fn DO(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(DO, 0)
}
/// Retrieves first TerminalNode corresponding to token WHILE
/// Returns `None` if there is no child corresponding to token WHILE
fn WHILE(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(WHILE, 0)
}
/// Retrieves first TerminalNode corresponding to token LPAREN
/// Returns `None` if there is no child corresponding to token LPAREN
fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(LPAREN, 0)
}
fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token RPAREN
/// Returns `None` if there is no child corresponding to token RPAREN
fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(RPAREN, 0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}
fn controlStructureBody(&self) -> Option<Rc<ControlStructureBodyContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> DoWhileStatementContextAttrs<'input> for DoWhileStatementContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn doWhileStatement(&mut self,)
	-> Result<Rc<DoWhileStatementContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = DoWhileStatementContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 144, RULE_doWhileStatement);
        let mut _localctx: Rc<DoWhileStatementContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2049);
			recog.base.match_token(DO,&mut recog.err_handler)?;

			recog.base.set_state(2053);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(307,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					recog.base.set_state(2050);
					recog.base.match_token(NL,&mut recog.err_handler)?;

					}
					} 
				}
				recog.base.set_state(2055);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(307,&mut recog.base)?;
			}
			recog.base.set_state(2057);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(308,&mut recog.base)? {
				x if x == 1=>{
					{
					/*InvokeRule controlStructureBody*/
					recog.base.set_state(2056);
					recog.controlStructureBody()?;

					}
				}

				_ => {}
			}
			recog.base.set_state(2062);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(2059);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(2064);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(2065);
			recog.base.match_token(WHILE,&mut recog.err_handler)?;

			recog.base.set_state(2069);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(2066);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(2071);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(2072);
			recog.base.match_token(LPAREN,&mut recog.err_handler)?;

			/*InvokeRule expression*/
			recog.base.set_state(2073);
			recog.expression()?;

			recog.base.set_state(2074);
			recog.base.match_token(RPAREN,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- assignment ----------------
pub type AssignmentContextAll<'input> = AssignmentContext<'input>;


pub type AssignmentContext<'input> = BaseParserRuleContext<'input,AssignmentContextExt<'input>>;

#[derive(Clone)]
pub struct AssignmentContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for AssignmentContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for AssignmentContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_assignment(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_assignment(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for AssignmentContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_assignment(self);
	}
}

impl<'input> CustomRuleContext<'input> for AssignmentContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_assignment }
	//fn type_rule_index() -> usize where Self: Sized { RULE_assignment }
}
antlr_rust::type_id!{AssignmentContextExt<'a>}

impl<'input> AssignmentContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AssignmentContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AssignmentContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AssignmentContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<AssignmentContextExt<'input>>{

fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn directlyAssignableExpression(&self) -> Option<Rc<DirectlyAssignableExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token ASSIGNMENT
/// Returns `None` if there is no child corresponding to token ASSIGNMENT
fn ASSIGNMENT(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(ASSIGNMENT, 0)
}
fn assignableExpression(&self) -> Option<Rc<AssignableExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn assignmentAndOperator(&self) -> Option<Rc<AssignmentAndOperatorContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}

}

impl<'input> AssignmentContextAttrs<'input> for AssignmentContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn assignment(&mut self,)
	-> Result<Rc<AssignmentContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AssignmentContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 146, RULE_assignment);
        let mut _localctx: Rc<AssignmentContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2082);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(311,&mut recog.base)? {
				1 =>{
					{
					/*InvokeRule directlyAssignableExpression*/
					recog.base.set_state(2076);
					recog.directlyAssignableExpression()?;

					recog.base.set_state(2077);
					recog.base.match_token(ASSIGNMENT,&mut recog.err_handler)?;

					}
				}
			,
				2 =>{
					{
					/*InvokeRule assignableExpression*/
					recog.base.set_state(2079);
					recog.assignableExpression()?;

					/*InvokeRule assignmentAndOperator*/
					recog.base.set_state(2080);
					recog.assignmentAndOperator()?;

					}
				}

				_ => {}
			}
			recog.base.set_state(2087);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(312,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					recog.base.set_state(2084);
					recog.base.match_token(NL,&mut recog.err_handler)?;

					}
					} 
				}
				recog.base.set_state(2089);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(312,&mut recog.base)?;
			}
			/*InvokeRule expression*/
			recog.base.set_state(2090);
			recog.expression()?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- semi ----------------
pub type SemiContextAll<'input> = SemiContext<'input>;


pub type SemiContext<'input> = BaseParserRuleContext<'input,SemiContextExt<'input>>;

#[derive(Clone)]
pub struct SemiContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for SemiContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for SemiContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_semi(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_semi(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for SemiContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_semi(self);
	}
}

impl<'input> CustomRuleContext<'input> for SemiContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_semi }
	//fn type_rule_index() -> usize where Self: Sized { RULE_semi }
}
antlr_rust::type_id!{SemiContextExt<'a>}

impl<'input> SemiContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<SemiContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,SemiContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait SemiContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<SemiContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token SEMICOLON
/// Returns `None` if there is no child corresponding to token SEMICOLON
fn SEMICOLON(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(SEMICOLON, 0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}

}

impl<'input> SemiContextAttrs<'input> for SemiContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn semi(&mut self,)
	-> Result<Rc<SemiContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = SemiContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 148, RULE_semi);
        let mut _localctx: Rc<SemiContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2092);
			_la = recog.base.input.la(1);
			if { !(_la==NL || _la==SEMICOLON) } {
				recog.err_handler.recover_inline(&mut recog.base)?;

			}
			else {
				if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
				recog.err_handler.report_match(&mut recog.base);
				recog.base.consume(&mut recog.err_handler);
			}
			recog.base.set_state(2096);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(313,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					recog.base.set_state(2093);
					recog.base.match_token(NL,&mut recog.err_handler)?;

					}
					} 
				}
				recog.base.set_state(2098);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(313,&mut recog.base)?;
			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- semis ----------------
pub type SemisContextAll<'input> = SemisContext<'input>;


pub type SemisContext<'input> = BaseParserRuleContext<'input,SemisContextExt<'input>>;

#[derive(Clone)]
pub struct SemisContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for SemisContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for SemisContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_semis(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_semis(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for SemisContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_semis(self);
	}
}

impl<'input> CustomRuleContext<'input> for SemisContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_semis }
	//fn type_rule_index() -> usize where Self: Sized { RULE_semis }
}
antlr_rust::type_id!{SemisContextExt<'a>}

impl<'input> SemisContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<SemisContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,SemisContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait SemisContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<SemisContextExt<'input>>{

/// Retrieves all `TerminalNode`s corresponding to token SEMICOLON in current rule
fn SEMICOLON_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token SEMICOLON, starting from 0.
/// Returns `None` if number of children corresponding to token SEMICOLON is less or equal than `i`.
fn SEMICOLON(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(SEMICOLON, i)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}

}

impl<'input> SemisContextAttrs<'input> for SemisContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn semis(&mut self,)
	-> Result<Rc<SemisContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = SemisContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 150, RULE_semis);
        let mut _localctx: Rc<SemisContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2100); 
			recog.err_handler.sync(&mut recog.base)?;
			_alt = 1;
			loop {
				match _alt {
				    x if x == 1=>
					{
					{
					recog.base.set_state(2099);
					_la = recog.base.input.la(1);
					if { !(_la==NL || _la==SEMICOLON) } {
						recog.err_handler.recover_inline(&mut recog.base)?;

					}
					else {
						if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
						recog.err_handler.report_match(&mut recog.base);
						recog.base.consume(&mut recog.err_handler);
					}
					}
					}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
				}
				recog.base.set_state(2102); 
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(314,&mut recog.base)?;
				if _alt==2 || _alt==INVALID_ALT { break }
			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- expression ----------------
pub type ExpressionContextAll<'input> = ExpressionContext<'input>;


pub type ExpressionContext<'input> = BaseParserRuleContext<'input,ExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct ExpressionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for ExpressionContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for ExpressionContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_expression(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_expression(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for ExpressionContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_expression(self);
	}
}

impl<'input> CustomRuleContext<'input> for ExpressionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_expression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_expression }
}
antlr_rust::type_id!{ExpressionContextExt<'a>}

impl<'input> ExpressionContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ExpressionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ExpressionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ExpressionContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<ExpressionContextExt<'input>>{

fn disjunction(&self) -> Option<Rc<DisjunctionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ExpressionContextAttrs<'input> for ExpressionContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn expression(&mut self,)
	-> Result<Rc<ExpressionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ExpressionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 152, RULE_expression);
        let mut _localctx: Rc<ExpressionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule disjunction*/
			recog.base.set_state(2104);
			recog.disjunction()?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- disjunction ----------------
pub type DisjunctionContextAll<'input> = DisjunctionContext<'input>;


pub type DisjunctionContext<'input> = BaseParserRuleContext<'input,DisjunctionContextExt<'input>>;

#[derive(Clone)]
pub struct DisjunctionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for DisjunctionContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for DisjunctionContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_disjunction(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_disjunction(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for DisjunctionContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_disjunction(self);
	}
}

impl<'input> CustomRuleContext<'input> for DisjunctionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_disjunction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_disjunction }
}
antlr_rust::type_id!{DisjunctionContextExt<'a>}

impl<'input> DisjunctionContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<DisjunctionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,DisjunctionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait DisjunctionContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<DisjunctionContextExt<'input>>{

fn conjunction_all(&self) ->  Vec<Rc<ConjunctionContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn conjunction(&self, i: usize) -> Option<Rc<ConjunctionContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token DISJ in current rule
fn DISJ_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token DISJ, starting from 0.
/// Returns `None` if number of children corresponding to token DISJ is less or equal than `i`.
fn DISJ(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(DISJ, i)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}

}

impl<'input> DisjunctionContextAttrs<'input> for DisjunctionContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn disjunction(&mut self,)
	-> Result<Rc<DisjunctionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = DisjunctionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 154, RULE_disjunction);
        let mut _localctx: Rc<DisjunctionContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule conjunction*/
			recog.base.set_state(2106);
			recog.conjunction()?;

			recog.base.set_state(2123);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(317,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					recog.base.set_state(2110);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(2107);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(2112);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(2113);
					recog.base.match_token(DISJ,&mut recog.err_handler)?;

					recog.base.set_state(2117);
					recog.err_handler.sync(&mut recog.base)?;
					_alt = recog.interpreter.adaptive_predict(316,&mut recog.base)?;
					while { _alt!=2 && _alt!=INVALID_ALT } {
						if _alt==1 {
							{
							{
							recog.base.set_state(2114);
							recog.base.match_token(NL,&mut recog.err_handler)?;

							}
							} 
						}
						recog.base.set_state(2119);
						recog.err_handler.sync(&mut recog.base)?;
						_alt = recog.interpreter.adaptive_predict(316,&mut recog.base)?;
					}
					/*InvokeRule conjunction*/
					recog.base.set_state(2120);
					recog.conjunction()?;

					}
					} 
				}
				recog.base.set_state(2125);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(317,&mut recog.base)?;
			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- conjunction ----------------
pub type ConjunctionContextAll<'input> = ConjunctionContext<'input>;


pub type ConjunctionContext<'input> = BaseParserRuleContext<'input,ConjunctionContextExt<'input>>;

#[derive(Clone)]
pub struct ConjunctionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for ConjunctionContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for ConjunctionContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_conjunction(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_conjunction(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for ConjunctionContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_conjunction(self);
	}
}

impl<'input> CustomRuleContext<'input> for ConjunctionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_conjunction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_conjunction }
}
antlr_rust::type_id!{ConjunctionContextExt<'a>}

impl<'input> ConjunctionContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ConjunctionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ConjunctionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ConjunctionContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<ConjunctionContextExt<'input>>{

fn equality_all(&self) ->  Vec<Rc<EqualityContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn equality(&self, i: usize) -> Option<Rc<EqualityContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token CONJ in current rule
fn CONJ_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token CONJ, starting from 0.
/// Returns `None` if number of children corresponding to token CONJ is less or equal than `i`.
fn CONJ(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(CONJ, i)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}

}

impl<'input> ConjunctionContextAttrs<'input> for ConjunctionContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn conjunction(&mut self,)
	-> Result<Rc<ConjunctionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ConjunctionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 156, RULE_conjunction);
        let mut _localctx: Rc<ConjunctionContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule equality*/
			recog.base.set_state(2126);
			recog.equality()?;

			recog.base.set_state(2143);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(320,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					recog.base.set_state(2130);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(2127);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(2132);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(2133);
					recog.base.match_token(CONJ,&mut recog.err_handler)?;

					recog.base.set_state(2137);
					recog.err_handler.sync(&mut recog.base)?;
					_alt = recog.interpreter.adaptive_predict(319,&mut recog.base)?;
					while { _alt!=2 && _alt!=INVALID_ALT } {
						if _alt==1 {
							{
							{
							recog.base.set_state(2134);
							recog.base.match_token(NL,&mut recog.err_handler)?;

							}
							} 
						}
						recog.base.set_state(2139);
						recog.err_handler.sync(&mut recog.base)?;
						_alt = recog.interpreter.adaptive_predict(319,&mut recog.base)?;
					}
					/*InvokeRule equality*/
					recog.base.set_state(2140);
					recog.equality()?;

					}
					} 
				}
				recog.base.set_state(2145);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(320,&mut recog.base)?;
			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- equality ----------------
pub type EqualityContextAll<'input> = EqualityContext<'input>;


pub type EqualityContext<'input> = BaseParserRuleContext<'input,EqualityContextExt<'input>>;

#[derive(Clone)]
pub struct EqualityContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for EqualityContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for EqualityContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_equality(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_equality(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for EqualityContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_equality(self);
	}
}

impl<'input> CustomRuleContext<'input> for EqualityContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_equality }
	//fn type_rule_index() -> usize where Self: Sized { RULE_equality }
}
antlr_rust::type_id!{EqualityContextExt<'a>}

impl<'input> EqualityContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<EqualityContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,EqualityContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait EqualityContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<EqualityContextExt<'input>>{

fn comparison_all(&self) ->  Vec<Rc<ComparisonContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn comparison(&self, i: usize) -> Option<Rc<ComparisonContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn equalityOperator_all(&self) ->  Vec<Rc<EqualityOperatorContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn equalityOperator(&self, i: usize) -> Option<Rc<EqualityOperatorContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}

}

impl<'input> EqualityContextAttrs<'input> for EqualityContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn equality(&mut self,)
	-> Result<Rc<EqualityContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = EqualityContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 158, RULE_equality);
        let mut _localctx: Rc<EqualityContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule comparison*/
			recog.base.set_state(2146);
			recog.comparison()?;

			recog.base.set_state(2158);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(322,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					/*InvokeRule equalityOperator*/
					recog.base.set_state(2147);
					recog.equalityOperator()?;

					recog.base.set_state(2151);
					recog.err_handler.sync(&mut recog.base)?;
					_alt = recog.interpreter.adaptive_predict(321,&mut recog.base)?;
					while { _alt!=2 && _alt!=INVALID_ALT } {
						if _alt==1 {
							{
							{
							recog.base.set_state(2148);
							recog.base.match_token(NL,&mut recog.err_handler)?;

							}
							} 
						}
						recog.base.set_state(2153);
						recog.err_handler.sync(&mut recog.base)?;
						_alt = recog.interpreter.adaptive_predict(321,&mut recog.base)?;
					}
					/*InvokeRule comparison*/
					recog.base.set_state(2154);
					recog.comparison()?;

					}
					} 
				}
				recog.base.set_state(2160);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(322,&mut recog.base)?;
			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- comparison ----------------
pub type ComparisonContextAll<'input> = ComparisonContext<'input>;


pub type ComparisonContext<'input> = BaseParserRuleContext<'input,ComparisonContextExt<'input>>;

#[derive(Clone)]
pub struct ComparisonContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for ComparisonContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for ComparisonContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_comparison(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_comparison(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for ComparisonContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_comparison(self);
	}
}

impl<'input> CustomRuleContext<'input> for ComparisonContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_comparison }
	//fn type_rule_index() -> usize where Self: Sized { RULE_comparison }
}
antlr_rust::type_id!{ComparisonContextExt<'a>}

impl<'input> ComparisonContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ComparisonContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ComparisonContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ComparisonContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<ComparisonContextExt<'input>>{

fn genericCallLikeComparison_all(&self) ->  Vec<Rc<GenericCallLikeComparisonContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn genericCallLikeComparison(&self, i: usize) -> Option<Rc<GenericCallLikeComparisonContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn comparisonOperator_all(&self) ->  Vec<Rc<ComparisonOperatorContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn comparisonOperator(&self, i: usize) -> Option<Rc<ComparisonOperatorContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}

}

impl<'input> ComparisonContextAttrs<'input> for ComparisonContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn comparison(&mut self,)
	-> Result<Rc<ComparisonContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ComparisonContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 160, RULE_comparison);
        let mut _localctx: Rc<ComparisonContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule genericCallLikeComparison*/
			recog.base.set_state(2161);
			recog.genericCallLikeComparison()?;

			recog.base.set_state(2173);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(324,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					/*InvokeRule comparisonOperator*/
					recog.base.set_state(2162);
					recog.comparisonOperator()?;

					recog.base.set_state(2166);
					recog.err_handler.sync(&mut recog.base)?;
					_alt = recog.interpreter.adaptive_predict(323,&mut recog.base)?;
					while { _alt!=2 && _alt!=INVALID_ALT } {
						if _alt==1 {
							{
							{
							recog.base.set_state(2163);
							recog.base.match_token(NL,&mut recog.err_handler)?;

							}
							} 
						}
						recog.base.set_state(2168);
						recog.err_handler.sync(&mut recog.base)?;
						_alt = recog.interpreter.adaptive_predict(323,&mut recog.base)?;
					}
					/*InvokeRule genericCallLikeComparison*/
					recog.base.set_state(2169);
					recog.genericCallLikeComparison()?;

					}
					} 
				}
				recog.base.set_state(2175);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(324,&mut recog.base)?;
			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- genericCallLikeComparison ----------------
pub type GenericCallLikeComparisonContextAll<'input> = GenericCallLikeComparisonContext<'input>;


pub type GenericCallLikeComparisonContext<'input> = BaseParserRuleContext<'input,GenericCallLikeComparisonContextExt<'input>>;

#[derive(Clone)]
pub struct GenericCallLikeComparisonContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for GenericCallLikeComparisonContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for GenericCallLikeComparisonContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_genericCallLikeComparison(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_genericCallLikeComparison(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for GenericCallLikeComparisonContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_genericCallLikeComparison(self);
	}
}

impl<'input> CustomRuleContext<'input> for GenericCallLikeComparisonContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_genericCallLikeComparison }
	//fn type_rule_index() -> usize where Self: Sized { RULE_genericCallLikeComparison }
}
antlr_rust::type_id!{GenericCallLikeComparisonContextExt<'a>}

impl<'input> GenericCallLikeComparisonContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<GenericCallLikeComparisonContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,GenericCallLikeComparisonContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait GenericCallLikeComparisonContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<GenericCallLikeComparisonContextExt<'input>>{

fn infixOperation(&self) -> Option<Rc<InfixOperationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn callSuffix_all(&self) ->  Vec<Rc<CallSuffixContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn callSuffix(&self, i: usize) -> Option<Rc<CallSuffixContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> GenericCallLikeComparisonContextAttrs<'input> for GenericCallLikeComparisonContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn genericCallLikeComparison(&mut self,)
	-> Result<Rc<GenericCallLikeComparisonContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = GenericCallLikeComparisonContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 162, RULE_genericCallLikeComparison);
        let mut _localctx: Rc<GenericCallLikeComparisonContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule infixOperation*/
			recog.base.set_state(2176);
			recog.infixOperation()?;

			recog.base.set_state(2180);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(325,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					/*InvokeRule callSuffix*/
					recog.base.set_state(2177);
					recog.callSuffix()?;

					}
					} 
				}
				recog.base.set_state(2182);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(325,&mut recog.base)?;
			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- infixOperation ----------------
pub type InfixOperationContextAll<'input> = InfixOperationContext<'input>;


pub type InfixOperationContext<'input> = BaseParserRuleContext<'input,InfixOperationContextExt<'input>>;

#[derive(Clone)]
pub struct InfixOperationContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for InfixOperationContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for InfixOperationContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_infixOperation(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_infixOperation(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for InfixOperationContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_infixOperation(self);
	}
}

impl<'input> CustomRuleContext<'input> for InfixOperationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_infixOperation }
	//fn type_rule_index() -> usize where Self: Sized { RULE_infixOperation }
}
antlr_rust::type_id!{InfixOperationContextExt<'a>}

impl<'input> InfixOperationContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<InfixOperationContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,InfixOperationContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait InfixOperationContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<InfixOperationContextExt<'input>>{

fn elvisExpression_all(&self) ->  Vec<Rc<ElvisExpressionContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn elvisExpression(&self, i: usize) -> Option<Rc<ElvisExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn inOperator_all(&self) ->  Vec<Rc<InOperatorContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn inOperator(&self, i: usize) -> Option<Rc<InOperatorContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn isOperator_all(&self) ->  Vec<Rc<IsOperatorContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn isOperator(&self, i: usize) -> Option<Rc<IsOperatorContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn type_all(&self) ->  Vec<Rc<TypeContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn type(&self, i: usize) -> Option<Rc<TypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}

}

impl<'input> InfixOperationContextAttrs<'input> for InfixOperationContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn infixOperation(&mut self,)
	-> Result<Rc<InfixOperationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = InfixOperationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 164, RULE_infixOperation);
        let mut _localctx: Rc<InfixOperationContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule elvisExpression*/
			recog.base.set_state(2183);
			recog.elvisExpression()?;

			recog.base.set_state(2204);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(329,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					recog.base.set_state(2202);
					recog.err_handler.sync(&mut recog.base)?;
					match recog.base.input.la(1) {
					 IN | NOT_IN 
						=> {
							{
							/*InvokeRule inOperator*/
							recog.base.set_state(2184);
							recog.inOperator()?;

							recog.base.set_state(2188);
							recog.err_handler.sync(&mut recog.base)?;
							_alt = recog.interpreter.adaptive_predict(326,&mut recog.base)?;
							while { _alt!=2 && _alt!=INVALID_ALT } {
								if _alt==1 {
									{
									{
									recog.base.set_state(2185);
									recog.base.match_token(NL,&mut recog.err_handler)?;

									}
									} 
								}
								recog.base.set_state(2190);
								recog.err_handler.sync(&mut recog.base)?;
								_alt = recog.interpreter.adaptive_predict(326,&mut recog.base)?;
							}
							/*InvokeRule elvisExpression*/
							recog.base.set_state(2191);
							recog.elvisExpression()?;

							}
						}

					 IS | NOT_IS 
						=> {
							{
							/*InvokeRule isOperator*/
							recog.base.set_state(2193);
							recog.isOperator()?;

							recog.base.set_state(2197);
							recog.err_handler.sync(&mut recog.base)?;
							_la = recog.base.input.la(1);
							while _la==NL {
								{
								{
								recog.base.set_state(2194);
								recog.base.match_token(NL,&mut recog.err_handler)?;

								}
								}
								recog.base.set_state(2199);
								recog.err_handler.sync(&mut recog.base)?;
								_la = recog.base.input.la(1);
							}
							/*InvokeRule type*/
							recog.base.set_state(2200);
							recog.type()?;

							}
						}

						_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
					}
					} 
				}
				recog.base.set_state(2206);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(329,&mut recog.base)?;
			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- elvisExpression ----------------
pub type ElvisExpressionContextAll<'input> = ElvisExpressionContext<'input>;


pub type ElvisExpressionContext<'input> = BaseParserRuleContext<'input,ElvisExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct ElvisExpressionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for ElvisExpressionContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for ElvisExpressionContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_elvisExpression(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_elvisExpression(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for ElvisExpressionContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_elvisExpression(self);
	}
}

impl<'input> CustomRuleContext<'input> for ElvisExpressionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_elvisExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_elvisExpression }
}
antlr_rust::type_id!{ElvisExpressionContextExt<'a>}

impl<'input> ElvisExpressionContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ElvisExpressionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ElvisExpressionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ElvisExpressionContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<ElvisExpressionContextExt<'input>>{

fn infixFunctionCall_all(&self) ->  Vec<Rc<InfixFunctionCallContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn infixFunctionCall(&self, i: usize) -> Option<Rc<InfixFunctionCallContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn elvis_all(&self) ->  Vec<Rc<ElvisContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn elvis(&self, i: usize) -> Option<Rc<ElvisContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}

}

impl<'input> ElvisExpressionContextAttrs<'input> for ElvisExpressionContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn elvisExpression(&mut self,)
	-> Result<Rc<ElvisExpressionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ElvisExpressionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 166, RULE_elvisExpression);
        let mut _localctx: Rc<ElvisExpressionContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule infixFunctionCall*/
			recog.base.set_state(2207);
			recog.infixFunctionCall()?;

			recog.base.set_state(2225);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(332,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					recog.base.set_state(2211);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(2208);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(2213);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					/*InvokeRule elvis*/
					recog.base.set_state(2214);
					recog.elvis()?;

					recog.base.set_state(2218);
					recog.err_handler.sync(&mut recog.base)?;
					_alt = recog.interpreter.adaptive_predict(331,&mut recog.base)?;
					while { _alt!=2 && _alt!=INVALID_ALT } {
						if _alt==1 {
							{
							{
							recog.base.set_state(2215);
							recog.base.match_token(NL,&mut recog.err_handler)?;

							}
							} 
						}
						recog.base.set_state(2220);
						recog.err_handler.sync(&mut recog.base)?;
						_alt = recog.interpreter.adaptive_predict(331,&mut recog.base)?;
					}
					/*InvokeRule infixFunctionCall*/
					recog.base.set_state(2221);
					recog.infixFunctionCall()?;

					}
					} 
				}
				recog.base.set_state(2227);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(332,&mut recog.base)?;
			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- elvis ----------------
pub type ElvisContextAll<'input> = ElvisContext<'input>;


pub type ElvisContext<'input> = BaseParserRuleContext<'input,ElvisContextExt<'input>>;

#[derive(Clone)]
pub struct ElvisContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for ElvisContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for ElvisContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_elvis(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_elvis(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for ElvisContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_elvis(self);
	}
}

impl<'input> CustomRuleContext<'input> for ElvisContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_elvis }
	//fn type_rule_index() -> usize where Self: Sized { RULE_elvis }
}
antlr_rust::type_id!{ElvisContextExt<'a>}

impl<'input> ElvisContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ElvisContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ElvisContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ElvisContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<ElvisContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token QUEST_NO_WS
/// Returns `None` if there is no child corresponding to token QUEST_NO_WS
fn QUEST_NO_WS(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(QUEST_NO_WS, 0)
}
/// Retrieves first TerminalNode corresponding to token COLON
/// Returns `None` if there is no child corresponding to token COLON
fn COLON(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(COLON, 0)
}

}

impl<'input> ElvisContextAttrs<'input> for ElvisContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn elvis(&mut self,)
	-> Result<Rc<ElvisContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ElvisContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 168, RULE_elvis);
        let mut _localctx: Rc<ElvisContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2228);
			recog.base.match_token(QUEST_NO_WS,&mut recog.err_handler)?;

			recog.base.set_state(2229);
			recog.base.match_token(COLON,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- infixFunctionCall ----------------
pub type InfixFunctionCallContextAll<'input> = InfixFunctionCallContext<'input>;


pub type InfixFunctionCallContext<'input> = BaseParserRuleContext<'input,InfixFunctionCallContextExt<'input>>;

#[derive(Clone)]
pub struct InfixFunctionCallContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for InfixFunctionCallContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for InfixFunctionCallContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_infixFunctionCall(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_infixFunctionCall(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for InfixFunctionCallContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_infixFunctionCall(self);
	}
}

impl<'input> CustomRuleContext<'input> for InfixFunctionCallContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_infixFunctionCall }
	//fn type_rule_index() -> usize where Self: Sized { RULE_infixFunctionCall }
}
antlr_rust::type_id!{InfixFunctionCallContextExt<'a>}

impl<'input> InfixFunctionCallContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<InfixFunctionCallContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,InfixFunctionCallContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait InfixFunctionCallContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<InfixFunctionCallContextExt<'input>>{

fn rangeExpression_all(&self) ->  Vec<Rc<RangeExpressionContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn rangeExpression(&self, i: usize) -> Option<Rc<RangeExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn simpleIdentifier_all(&self) ->  Vec<Rc<SimpleIdentifierContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn simpleIdentifier(&self, i: usize) -> Option<Rc<SimpleIdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}

}

impl<'input> InfixFunctionCallContextAttrs<'input> for InfixFunctionCallContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn infixFunctionCall(&mut self,)
	-> Result<Rc<InfixFunctionCallContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = InfixFunctionCallContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 170, RULE_infixFunctionCall);
        let mut _localctx: Rc<InfixFunctionCallContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule rangeExpression*/
			recog.base.set_state(2231);
			recog.rangeExpression()?;

			recog.base.set_state(2243);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(334,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					/*InvokeRule simpleIdentifier*/
					recog.base.set_state(2232);
					recog.simpleIdentifier()?;

					recog.base.set_state(2236);
					recog.err_handler.sync(&mut recog.base)?;
					_alt = recog.interpreter.adaptive_predict(333,&mut recog.base)?;
					while { _alt!=2 && _alt!=INVALID_ALT } {
						if _alt==1 {
							{
							{
							recog.base.set_state(2233);
							recog.base.match_token(NL,&mut recog.err_handler)?;

							}
							} 
						}
						recog.base.set_state(2238);
						recog.err_handler.sync(&mut recog.base)?;
						_alt = recog.interpreter.adaptive_predict(333,&mut recog.base)?;
					}
					/*InvokeRule rangeExpression*/
					recog.base.set_state(2239);
					recog.rangeExpression()?;

					}
					} 
				}
				recog.base.set_state(2245);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(334,&mut recog.base)?;
			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- rangeExpression ----------------
pub type RangeExpressionContextAll<'input> = RangeExpressionContext<'input>;


pub type RangeExpressionContext<'input> = BaseParserRuleContext<'input,RangeExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct RangeExpressionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for RangeExpressionContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for RangeExpressionContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_rangeExpression(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_rangeExpression(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for RangeExpressionContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_rangeExpression(self);
	}
}

impl<'input> CustomRuleContext<'input> for RangeExpressionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_rangeExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_rangeExpression }
}
antlr_rust::type_id!{RangeExpressionContextExt<'a>}

impl<'input> RangeExpressionContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<RangeExpressionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,RangeExpressionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait RangeExpressionContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<RangeExpressionContextExt<'input>>{

fn additiveExpression_all(&self) ->  Vec<Rc<AdditiveExpressionContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn additiveExpression(&self, i: usize) -> Option<Rc<AdditiveExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token RANGE in current rule
fn RANGE_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token RANGE, starting from 0.
/// Returns `None` if number of children corresponding to token RANGE is less or equal than `i`.
fn RANGE(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(RANGE, i)
}
/// Retrieves all `TerminalNode`s corresponding to token RANGE_UNTIL in current rule
fn RANGE_UNTIL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token RANGE_UNTIL, starting from 0.
/// Returns `None` if number of children corresponding to token RANGE_UNTIL is less or equal than `i`.
fn RANGE_UNTIL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(RANGE_UNTIL, i)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}

}

impl<'input> RangeExpressionContextAttrs<'input> for RangeExpressionContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn rangeExpression(&mut self,)
	-> Result<Rc<RangeExpressionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = RangeExpressionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 172, RULE_rangeExpression);
        let mut _localctx: Rc<RangeExpressionContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule additiveExpression*/
			recog.base.set_state(2246);
			recog.additiveExpression()?;

			recog.base.set_state(2257);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(336,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					recog.base.set_state(2247);
					_la = recog.base.input.la(1);
					if { !(_la==RANGE || _la==RANGE_UNTIL) } {
						recog.err_handler.recover_inline(&mut recog.base)?;

					}
					else {
						if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
						recog.err_handler.report_match(&mut recog.base);
						recog.base.consume(&mut recog.err_handler);
					}
					recog.base.set_state(2251);
					recog.err_handler.sync(&mut recog.base)?;
					_alt = recog.interpreter.adaptive_predict(335,&mut recog.base)?;
					while { _alt!=2 && _alt!=INVALID_ALT } {
						if _alt==1 {
							{
							{
							recog.base.set_state(2248);
							recog.base.match_token(NL,&mut recog.err_handler)?;

							}
							} 
						}
						recog.base.set_state(2253);
						recog.err_handler.sync(&mut recog.base)?;
						_alt = recog.interpreter.adaptive_predict(335,&mut recog.base)?;
					}
					/*InvokeRule additiveExpression*/
					recog.base.set_state(2254);
					recog.additiveExpression()?;

					}
					} 
				}
				recog.base.set_state(2259);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(336,&mut recog.base)?;
			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- additiveExpression ----------------
pub type AdditiveExpressionContextAll<'input> = AdditiveExpressionContext<'input>;


pub type AdditiveExpressionContext<'input> = BaseParserRuleContext<'input,AdditiveExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct AdditiveExpressionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for AdditiveExpressionContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for AdditiveExpressionContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_additiveExpression(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_additiveExpression(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for AdditiveExpressionContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_additiveExpression(self);
	}
}

impl<'input> CustomRuleContext<'input> for AdditiveExpressionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_additiveExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_additiveExpression }
}
antlr_rust::type_id!{AdditiveExpressionContextExt<'a>}

impl<'input> AdditiveExpressionContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AdditiveExpressionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AdditiveExpressionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AdditiveExpressionContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<AdditiveExpressionContextExt<'input>>{

fn multiplicativeExpression_all(&self) ->  Vec<Rc<MultiplicativeExpressionContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn multiplicativeExpression(&self, i: usize) -> Option<Rc<MultiplicativeExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn additiveOperator_all(&self) ->  Vec<Rc<AdditiveOperatorContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn additiveOperator(&self, i: usize) -> Option<Rc<AdditiveOperatorContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}

}

impl<'input> AdditiveExpressionContextAttrs<'input> for AdditiveExpressionContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn additiveExpression(&mut self,)
	-> Result<Rc<AdditiveExpressionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AdditiveExpressionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 174, RULE_additiveExpression);
        let mut _localctx: Rc<AdditiveExpressionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule multiplicativeExpression*/
			recog.base.set_state(2260);
			recog.multiplicativeExpression()?;

			recog.base.set_state(2272);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(338,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					/*InvokeRule additiveOperator*/
					recog.base.set_state(2261);
					recog.additiveOperator()?;

					recog.base.set_state(2265);
					recog.err_handler.sync(&mut recog.base)?;
					_alt = recog.interpreter.adaptive_predict(337,&mut recog.base)?;
					while { _alt!=2 && _alt!=INVALID_ALT } {
						if _alt==1 {
							{
							{
							recog.base.set_state(2262);
							recog.base.match_token(NL,&mut recog.err_handler)?;

							}
							} 
						}
						recog.base.set_state(2267);
						recog.err_handler.sync(&mut recog.base)?;
						_alt = recog.interpreter.adaptive_predict(337,&mut recog.base)?;
					}
					/*InvokeRule multiplicativeExpression*/
					recog.base.set_state(2268);
					recog.multiplicativeExpression()?;

					}
					} 
				}
				recog.base.set_state(2274);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(338,&mut recog.base)?;
			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- multiplicativeExpression ----------------
pub type MultiplicativeExpressionContextAll<'input> = MultiplicativeExpressionContext<'input>;


pub type MultiplicativeExpressionContext<'input> = BaseParserRuleContext<'input,MultiplicativeExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct MultiplicativeExpressionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for MultiplicativeExpressionContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for MultiplicativeExpressionContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_multiplicativeExpression(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_multiplicativeExpression(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for MultiplicativeExpressionContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_multiplicativeExpression(self);
	}
}

impl<'input> CustomRuleContext<'input> for MultiplicativeExpressionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_multiplicativeExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_multiplicativeExpression }
}
antlr_rust::type_id!{MultiplicativeExpressionContextExt<'a>}

impl<'input> MultiplicativeExpressionContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<MultiplicativeExpressionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,MultiplicativeExpressionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait MultiplicativeExpressionContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<MultiplicativeExpressionContextExt<'input>>{

fn asExpression_all(&self) ->  Vec<Rc<AsExpressionContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn asExpression(&self, i: usize) -> Option<Rc<AsExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn multiplicativeOperator_all(&self) ->  Vec<Rc<MultiplicativeOperatorContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn multiplicativeOperator(&self, i: usize) -> Option<Rc<MultiplicativeOperatorContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}

}

impl<'input> MultiplicativeExpressionContextAttrs<'input> for MultiplicativeExpressionContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn multiplicativeExpression(&mut self,)
	-> Result<Rc<MultiplicativeExpressionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = MultiplicativeExpressionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 176, RULE_multiplicativeExpression);
        let mut _localctx: Rc<MultiplicativeExpressionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule asExpression*/
			recog.base.set_state(2275);
			recog.asExpression()?;

			recog.base.set_state(2287);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(340,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					/*InvokeRule multiplicativeOperator*/
					recog.base.set_state(2276);
					recog.multiplicativeOperator()?;

					recog.base.set_state(2280);
					recog.err_handler.sync(&mut recog.base)?;
					_alt = recog.interpreter.adaptive_predict(339,&mut recog.base)?;
					while { _alt!=2 && _alt!=INVALID_ALT } {
						if _alt==1 {
							{
							{
							recog.base.set_state(2277);
							recog.base.match_token(NL,&mut recog.err_handler)?;

							}
							} 
						}
						recog.base.set_state(2282);
						recog.err_handler.sync(&mut recog.base)?;
						_alt = recog.interpreter.adaptive_predict(339,&mut recog.base)?;
					}
					/*InvokeRule asExpression*/
					recog.base.set_state(2283);
					recog.asExpression()?;

					}
					} 
				}
				recog.base.set_state(2289);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(340,&mut recog.base)?;
			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- asExpression ----------------
pub type AsExpressionContextAll<'input> = AsExpressionContext<'input>;


pub type AsExpressionContext<'input> = BaseParserRuleContext<'input,AsExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct AsExpressionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for AsExpressionContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for AsExpressionContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_asExpression(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_asExpression(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for AsExpressionContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_asExpression(self);
	}
}

impl<'input> CustomRuleContext<'input> for AsExpressionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_asExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_asExpression }
}
antlr_rust::type_id!{AsExpressionContextExt<'a>}

impl<'input> AsExpressionContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AsExpressionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AsExpressionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AsExpressionContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<AsExpressionContextExt<'input>>{

fn prefixUnaryExpression(&self) -> Option<Rc<PrefixUnaryExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn asOperator_all(&self) ->  Vec<Rc<AsOperatorContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn asOperator(&self, i: usize) -> Option<Rc<AsOperatorContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn type_all(&self) ->  Vec<Rc<TypeContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn type(&self, i: usize) -> Option<Rc<TypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}

}

impl<'input> AsExpressionContextAttrs<'input> for AsExpressionContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn asExpression(&mut self,)
	-> Result<Rc<AsExpressionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AsExpressionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 178, RULE_asExpression);
        let mut _localctx: Rc<AsExpressionContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule prefixUnaryExpression*/
			recog.base.set_state(2290);
			recog.prefixUnaryExpression()?;

			recog.base.set_state(2308);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(343,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					recog.base.set_state(2294);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(2291);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(2296);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					/*InvokeRule asOperator*/
					recog.base.set_state(2297);
					recog.asOperator()?;

					recog.base.set_state(2301);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(2298);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(2303);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					/*InvokeRule type*/
					recog.base.set_state(2304);
					recog.type()?;

					}
					} 
				}
				recog.base.set_state(2310);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(343,&mut recog.base)?;
			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- prefixUnaryExpression ----------------
pub type PrefixUnaryExpressionContextAll<'input> = PrefixUnaryExpressionContext<'input>;


pub type PrefixUnaryExpressionContext<'input> = BaseParserRuleContext<'input,PrefixUnaryExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct PrefixUnaryExpressionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for PrefixUnaryExpressionContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for PrefixUnaryExpressionContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_prefixUnaryExpression(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_prefixUnaryExpression(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for PrefixUnaryExpressionContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_prefixUnaryExpression(self);
	}
}

impl<'input> CustomRuleContext<'input> for PrefixUnaryExpressionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_prefixUnaryExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_prefixUnaryExpression }
}
antlr_rust::type_id!{PrefixUnaryExpressionContextExt<'a>}

impl<'input> PrefixUnaryExpressionContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<PrefixUnaryExpressionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,PrefixUnaryExpressionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait PrefixUnaryExpressionContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<PrefixUnaryExpressionContextExt<'input>>{

fn postfixUnaryExpression(&self) -> Option<Rc<PostfixUnaryExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn unaryPrefix_all(&self) ->  Vec<Rc<UnaryPrefixContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn unaryPrefix(&self, i: usize) -> Option<Rc<UnaryPrefixContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> PrefixUnaryExpressionContextAttrs<'input> for PrefixUnaryExpressionContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn prefixUnaryExpression(&mut self,)
	-> Result<Rc<PrefixUnaryExpressionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = PrefixUnaryExpressionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 180, RULE_prefixUnaryExpression);
        let mut _localctx: Rc<PrefixUnaryExpressionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2314);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(344,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					/*InvokeRule unaryPrefix*/
					recog.base.set_state(2311);
					recog.unaryPrefix()?;

					}
					} 
				}
				recog.base.set_state(2316);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(344,&mut recog.base)?;
			}
			/*InvokeRule postfixUnaryExpression*/
			recog.base.set_state(2317);
			recog.postfixUnaryExpression()?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- unaryPrefix ----------------
pub type UnaryPrefixContextAll<'input> = UnaryPrefixContext<'input>;


pub type UnaryPrefixContext<'input> = BaseParserRuleContext<'input,UnaryPrefixContextExt<'input>>;

#[derive(Clone)]
pub struct UnaryPrefixContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for UnaryPrefixContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for UnaryPrefixContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_unaryPrefix(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_unaryPrefix(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for UnaryPrefixContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_unaryPrefix(self);
	}
}

impl<'input> CustomRuleContext<'input> for UnaryPrefixContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_unaryPrefix }
	//fn type_rule_index() -> usize where Self: Sized { RULE_unaryPrefix }
}
antlr_rust::type_id!{UnaryPrefixContextExt<'a>}

impl<'input> UnaryPrefixContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<UnaryPrefixContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,UnaryPrefixContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait UnaryPrefixContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<UnaryPrefixContextExt<'input>>{

fn annotation(&self) -> Option<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn label(&self) -> Option<Rc<LabelContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn prefixUnaryOperator(&self) -> Option<Rc<PrefixUnaryOperatorContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}

}

impl<'input> UnaryPrefixContextAttrs<'input> for UnaryPrefixContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn unaryPrefix(&mut self,)
	-> Result<Rc<UnaryPrefixContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = UnaryPrefixContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 182, RULE_unaryPrefix);
        let mut _localctx: Rc<UnaryPrefixContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			let mut _alt: isize;
			recog.base.set_state(2328);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 AT_NO_WS | AT_PRE_WS 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule annotation*/
					recog.base.set_state(2319);
					recog.annotation()?;

					}
				}

			 FILE | FIELD | PROPERTY | GET | SET | RECEIVER | PARAM | SETPARAM | DELEGATE |
			 IMPORT | CONSTRUCTOR | BY | COMPANION | INIT | WHERE | CATCH | FINALLY |
			 OUT | DYNAMIC | PUBLIC | PRIVATE | PROTECTED | INTERNAL | ENUM | SEALED |
			 ANNOTATION | DATA | INNER | VALUE | TAILREC | OPERATOR | INLINE | INFIX |
			 EXTERNAL | SUSPEND | OVERRIDE | ABSTRACT | FINAL | OPEN | CONST | LATEINIT |
			 VARARG | NOINLINE | CROSSINLINE | REIFIED | EXPECT | ACTUAL | Identifier 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule label*/
					recog.base.set_state(2320);
					recog.label()?;

					}
				}

			 ADD | SUB | INCR | DECR | EXCL_WS | EXCL_NO_WS 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					/*InvokeRule prefixUnaryOperator*/
					recog.base.set_state(2321);
					recog.prefixUnaryOperator()?;

					recog.base.set_state(2325);
					recog.err_handler.sync(&mut recog.base)?;
					_alt = recog.interpreter.adaptive_predict(345,&mut recog.base)?;
					while { _alt!=2 && _alt!=INVALID_ALT } {
						if _alt==1 {
							{
							{
							recog.base.set_state(2322);
							recog.base.match_token(NL,&mut recog.err_handler)?;

							}
							} 
						}
						recog.base.set_state(2327);
						recog.err_handler.sync(&mut recog.base)?;
						_alt = recog.interpreter.adaptive_predict(345,&mut recog.base)?;
					}
					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- postfixUnaryExpression ----------------
pub type PostfixUnaryExpressionContextAll<'input> = PostfixUnaryExpressionContext<'input>;


pub type PostfixUnaryExpressionContext<'input> = BaseParserRuleContext<'input,PostfixUnaryExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct PostfixUnaryExpressionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for PostfixUnaryExpressionContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for PostfixUnaryExpressionContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_postfixUnaryExpression(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_postfixUnaryExpression(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for PostfixUnaryExpressionContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_postfixUnaryExpression(self);
	}
}

impl<'input> CustomRuleContext<'input> for PostfixUnaryExpressionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_postfixUnaryExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_postfixUnaryExpression }
}
antlr_rust::type_id!{PostfixUnaryExpressionContextExt<'a>}

impl<'input> PostfixUnaryExpressionContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<PostfixUnaryExpressionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,PostfixUnaryExpressionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait PostfixUnaryExpressionContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<PostfixUnaryExpressionContextExt<'input>>{

fn primaryExpression(&self) -> Option<Rc<PrimaryExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn postfixUnarySuffix_all(&self) ->  Vec<Rc<PostfixUnarySuffixContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn postfixUnarySuffix(&self, i: usize) -> Option<Rc<PostfixUnarySuffixContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> PostfixUnaryExpressionContextAttrs<'input> for PostfixUnaryExpressionContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn postfixUnaryExpression(&mut self,)
	-> Result<Rc<PostfixUnaryExpressionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = PostfixUnaryExpressionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 184, RULE_postfixUnaryExpression);
        let mut _localctx: Rc<PostfixUnaryExpressionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule primaryExpression*/
			recog.base.set_state(2330);
			recog.primaryExpression()?;

			recog.base.set_state(2334);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(347,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					/*InvokeRule postfixUnarySuffix*/
					recog.base.set_state(2331);
					recog.postfixUnarySuffix()?;

					}
					} 
				}
				recog.base.set_state(2336);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(347,&mut recog.base)?;
			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- postfixUnarySuffix ----------------
pub type PostfixUnarySuffixContextAll<'input> = PostfixUnarySuffixContext<'input>;


pub type PostfixUnarySuffixContext<'input> = BaseParserRuleContext<'input,PostfixUnarySuffixContextExt<'input>>;

#[derive(Clone)]
pub struct PostfixUnarySuffixContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for PostfixUnarySuffixContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for PostfixUnarySuffixContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_postfixUnarySuffix(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_postfixUnarySuffix(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for PostfixUnarySuffixContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_postfixUnarySuffix(self);
	}
}

impl<'input> CustomRuleContext<'input> for PostfixUnarySuffixContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_postfixUnarySuffix }
	//fn type_rule_index() -> usize where Self: Sized { RULE_postfixUnarySuffix }
}
antlr_rust::type_id!{PostfixUnarySuffixContextExt<'a>}

impl<'input> PostfixUnarySuffixContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<PostfixUnarySuffixContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,PostfixUnarySuffixContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait PostfixUnarySuffixContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<PostfixUnarySuffixContextExt<'input>>{

fn postfixUnaryOperator(&self) -> Option<Rc<PostfixUnaryOperatorContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn typeArguments(&self) -> Option<Rc<TypeArgumentsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn callSuffix(&self) -> Option<Rc<CallSuffixContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn indexingSuffix(&self) -> Option<Rc<IndexingSuffixContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn navigationSuffix(&self) -> Option<Rc<NavigationSuffixContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> PostfixUnarySuffixContextAttrs<'input> for PostfixUnarySuffixContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn postfixUnarySuffix(&mut self,)
	-> Result<Rc<PostfixUnarySuffixContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = PostfixUnarySuffixContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 186, RULE_postfixUnarySuffix);
        let mut _localctx: Rc<PostfixUnarySuffixContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			recog.base.set_state(2342);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(348,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule postfixUnaryOperator*/
					recog.base.set_state(2337);
					recog.postfixUnaryOperator()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule typeArguments*/
					recog.base.set_state(2338);
					recog.typeArguments()?;

					}
				}
			,
				3 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					/*InvokeRule callSuffix*/
					recog.base.set_state(2339);
					recog.callSuffix()?;

					}
				}
			,
				4 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 4);
					recog.base.enter_outer_alt(None, 4);
					{
					/*InvokeRule indexingSuffix*/
					recog.base.set_state(2340);
					recog.indexingSuffix()?;

					}
				}
			,
				5 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 5);
					recog.base.enter_outer_alt(None, 5);
					{
					/*InvokeRule navigationSuffix*/
					recog.base.set_state(2341);
					recog.navigationSuffix()?;

					}
				}

				_ => {}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- directlyAssignableExpression ----------------
pub type DirectlyAssignableExpressionContextAll<'input> = DirectlyAssignableExpressionContext<'input>;


pub type DirectlyAssignableExpressionContext<'input> = BaseParserRuleContext<'input,DirectlyAssignableExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct DirectlyAssignableExpressionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for DirectlyAssignableExpressionContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for DirectlyAssignableExpressionContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_directlyAssignableExpression(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_directlyAssignableExpression(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for DirectlyAssignableExpressionContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_directlyAssignableExpression(self);
	}
}

impl<'input> CustomRuleContext<'input> for DirectlyAssignableExpressionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_directlyAssignableExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_directlyAssignableExpression }
}
antlr_rust::type_id!{DirectlyAssignableExpressionContextExt<'a>}

impl<'input> DirectlyAssignableExpressionContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<DirectlyAssignableExpressionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,DirectlyAssignableExpressionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait DirectlyAssignableExpressionContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<DirectlyAssignableExpressionContextExt<'input>>{

fn postfixUnaryExpression(&self) -> Option<Rc<PostfixUnaryExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn assignableSuffix(&self) -> Option<Rc<AssignableSuffixContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn simpleIdentifier(&self) -> Option<Rc<SimpleIdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn parenthesizedDirectlyAssignableExpression(&self) -> Option<Rc<ParenthesizedDirectlyAssignableExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> DirectlyAssignableExpressionContextAttrs<'input> for DirectlyAssignableExpressionContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn directlyAssignableExpression(&mut self,)
	-> Result<Rc<DirectlyAssignableExpressionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = DirectlyAssignableExpressionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 188, RULE_directlyAssignableExpression);
        let mut _localctx: Rc<DirectlyAssignableExpressionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			recog.base.set_state(2349);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(349,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule postfixUnaryExpression*/
					recog.base.set_state(2344);
					recog.postfixUnaryExpression()?;

					/*InvokeRule assignableSuffix*/
					recog.base.set_state(2345);
					recog.assignableSuffix()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule simpleIdentifier*/
					recog.base.set_state(2347);
					recog.simpleIdentifier()?;

					}
				}
			,
				3 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					/*InvokeRule parenthesizedDirectlyAssignableExpression*/
					recog.base.set_state(2348);
					recog.parenthesizedDirectlyAssignableExpression()?;

					}
				}

				_ => {}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- parenthesizedDirectlyAssignableExpression ----------------
pub type ParenthesizedDirectlyAssignableExpressionContextAll<'input> = ParenthesizedDirectlyAssignableExpressionContext<'input>;


pub type ParenthesizedDirectlyAssignableExpressionContext<'input> = BaseParserRuleContext<'input,ParenthesizedDirectlyAssignableExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct ParenthesizedDirectlyAssignableExpressionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for ParenthesizedDirectlyAssignableExpressionContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for ParenthesizedDirectlyAssignableExpressionContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_parenthesizedDirectlyAssignableExpression(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_parenthesizedDirectlyAssignableExpression(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for ParenthesizedDirectlyAssignableExpressionContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_parenthesizedDirectlyAssignableExpression(self);
	}
}

impl<'input> CustomRuleContext<'input> for ParenthesizedDirectlyAssignableExpressionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_parenthesizedDirectlyAssignableExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_parenthesizedDirectlyAssignableExpression }
}
antlr_rust::type_id!{ParenthesizedDirectlyAssignableExpressionContextExt<'a>}

impl<'input> ParenthesizedDirectlyAssignableExpressionContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ParenthesizedDirectlyAssignableExpressionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ParenthesizedDirectlyAssignableExpressionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ParenthesizedDirectlyAssignableExpressionContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<ParenthesizedDirectlyAssignableExpressionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token LPAREN
/// Returns `None` if there is no child corresponding to token LPAREN
fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(LPAREN, 0)
}
fn directlyAssignableExpression(&self) -> Option<Rc<DirectlyAssignableExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token RPAREN
/// Returns `None` if there is no child corresponding to token RPAREN
fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(RPAREN, 0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}

}

impl<'input> ParenthesizedDirectlyAssignableExpressionContextAttrs<'input> for ParenthesizedDirectlyAssignableExpressionContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn parenthesizedDirectlyAssignableExpression(&mut self,)
	-> Result<Rc<ParenthesizedDirectlyAssignableExpressionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ParenthesizedDirectlyAssignableExpressionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 190, RULE_parenthesizedDirectlyAssignableExpression);
        let mut _localctx: Rc<ParenthesizedDirectlyAssignableExpressionContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2351);
			recog.base.match_token(LPAREN,&mut recog.err_handler)?;

			recog.base.set_state(2355);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(350,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					recog.base.set_state(2352);
					recog.base.match_token(NL,&mut recog.err_handler)?;

					}
					} 
				}
				recog.base.set_state(2357);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(350,&mut recog.base)?;
			}
			/*InvokeRule directlyAssignableExpression*/
			recog.base.set_state(2358);
			recog.directlyAssignableExpression()?;

			recog.base.set_state(2362);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(2359);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(2364);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(2365);
			recog.base.match_token(RPAREN,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- assignableExpression ----------------
pub type AssignableExpressionContextAll<'input> = AssignableExpressionContext<'input>;


pub type AssignableExpressionContext<'input> = BaseParserRuleContext<'input,AssignableExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct AssignableExpressionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for AssignableExpressionContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for AssignableExpressionContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_assignableExpression(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_assignableExpression(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for AssignableExpressionContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_assignableExpression(self);
	}
}

impl<'input> CustomRuleContext<'input> for AssignableExpressionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_assignableExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_assignableExpression }
}
antlr_rust::type_id!{AssignableExpressionContextExt<'a>}

impl<'input> AssignableExpressionContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AssignableExpressionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AssignableExpressionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AssignableExpressionContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<AssignableExpressionContextExt<'input>>{

fn prefixUnaryExpression(&self) -> Option<Rc<PrefixUnaryExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn parenthesizedAssignableExpression(&self) -> Option<Rc<ParenthesizedAssignableExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> AssignableExpressionContextAttrs<'input> for AssignableExpressionContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn assignableExpression(&mut self,)
	-> Result<Rc<AssignableExpressionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AssignableExpressionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 192, RULE_assignableExpression);
        let mut _localctx: Rc<AssignableExpressionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			recog.base.set_state(2369);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(352,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule prefixUnaryExpression*/
					recog.base.set_state(2367);
					recog.prefixUnaryExpression()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule parenthesizedAssignableExpression*/
					recog.base.set_state(2368);
					recog.parenthesizedAssignableExpression()?;

					}
				}

				_ => {}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- parenthesizedAssignableExpression ----------------
pub type ParenthesizedAssignableExpressionContextAll<'input> = ParenthesizedAssignableExpressionContext<'input>;


pub type ParenthesizedAssignableExpressionContext<'input> = BaseParserRuleContext<'input,ParenthesizedAssignableExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct ParenthesizedAssignableExpressionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for ParenthesizedAssignableExpressionContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for ParenthesizedAssignableExpressionContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_parenthesizedAssignableExpression(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_parenthesizedAssignableExpression(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for ParenthesizedAssignableExpressionContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_parenthesizedAssignableExpression(self);
	}
}

impl<'input> CustomRuleContext<'input> for ParenthesizedAssignableExpressionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_parenthesizedAssignableExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_parenthesizedAssignableExpression }
}
antlr_rust::type_id!{ParenthesizedAssignableExpressionContextExt<'a>}

impl<'input> ParenthesizedAssignableExpressionContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ParenthesizedAssignableExpressionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ParenthesizedAssignableExpressionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ParenthesizedAssignableExpressionContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<ParenthesizedAssignableExpressionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token LPAREN
/// Returns `None` if there is no child corresponding to token LPAREN
fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(LPAREN, 0)
}
fn assignableExpression(&self) -> Option<Rc<AssignableExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token RPAREN
/// Returns `None` if there is no child corresponding to token RPAREN
fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(RPAREN, 0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}

}

impl<'input> ParenthesizedAssignableExpressionContextAttrs<'input> for ParenthesizedAssignableExpressionContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn parenthesizedAssignableExpression(&mut self,)
	-> Result<Rc<ParenthesizedAssignableExpressionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ParenthesizedAssignableExpressionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 194, RULE_parenthesizedAssignableExpression);
        let mut _localctx: Rc<ParenthesizedAssignableExpressionContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2371);
			recog.base.match_token(LPAREN,&mut recog.err_handler)?;

			recog.base.set_state(2375);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(353,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					recog.base.set_state(2372);
					recog.base.match_token(NL,&mut recog.err_handler)?;

					}
					} 
				}
				recog.base.set_state(2377);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(353,&mut recog.base)?;
			}
			/*InvokeRule assignableExpression*/
			recog.base.set_state(2378);
			recog.assignableExpression()?;

			recog.base.set_state(2382);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(2379);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(2384);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(2385);
			recog.base.match_token(RPAREN,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- assignableSuffix ----------------
pub type AssignableSuffixContextAll<'input> = AssignableSuffixContext<'input>;


pub type AssignableSuffixContext<'input> = BaseParserRuleContext<'input,AssignableSuffixContextExt<'input>>;

#[derive(Clone)]
pub struct AssignableSuffixContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for AssignableSuffixContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for AssignableSuffixContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_assignableSuffix(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_assignableSuffix(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for AssignableSuffixContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_assignableSuffix(self);
	}
}

impl<'input> CustomRuleContext<'input> for AssignableSuffixContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_assignableSuffix }
	//fn type_rule_index() -> usize where Self: Sized { RULE_assignableSuffix }
}
antlr_rust::type_id!{AssignableSuffixContextExt<'a>}

impl<'input> AssignableSuffixContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AssignableSuffixContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AssignableSuffixContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AssignableSuffixContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<AssignableSuffixContextExt<'input>>{

fn typeArguments(&self) -> Option<Rc<TypeArgumentsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn indexingSuffix(&self) -> Option<Rc<IndexingSuffixContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn navigationSuffix(&self) -> Option<Rc<NavigationSuffixContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> AssignableSuffixContextAttrs<'input> for AssignableSuffixContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn assignableSuffix(&mut self,)
	-> Result<Rc<AssignableSuffixContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AssignableSuffixContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 196, RULE_assignableSuffix);
        let mut _localctx: Rc<AssignableSuffixContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			recog.base.set_state(2390);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 LANGLE 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule typeArguments*/
					recog.base.set_state(2387);
					recog.typeArguments()?;

					}
				}

			 LSQUARE 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule indexingSuffix*/
					recog.base.set_state(2388);
					recog.indexingSuffix()?;

					}
				}

			 NL | DOT | COLONCOLON | QUEST_NO_WS 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					/*InvokeRule navigationSuffix*/
					recog.base.set_state(2389);
					recog.navigationSuffix()?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- indexingSuffix ----------------
pub type IndexingSuffixContextAll<'input> = IndexingSuffixContext<'input>;


pub type IndexingSuffixContext<'input> = BaseParserRuleContext<'input,IndexingSuffixContextExt<'input>>;

#[derive(Clone)]
pub struct IndexingSuffixContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for IndexingSuffixContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for IndexingSuffixContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_indexingSuffix(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_indexingSuffix(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for IndexingSuffixContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_indexingSuffix(self);
	}
}

impl<'input> CustomRuleContext<'input> for IndexingSuffixContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_indexingSuffix }
	//fn type_rule_index() -> usize where Self: Sized { RULE_indexingSuffix }
}
antlr_rust::type_id!{IndexingSuffixContextExt<'a>}

impl<'input> IndexingSuffixContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<IndexingSuffixContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,IndexingSuffixContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait IndexingSuffixContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<IndexingSuffixContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token LSQUARE
/// Returns `None` if there is no child corresponding to token LSQUARE
fn LSQUARE(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(LSQUARE, 0)
}
fn expression_all(&self) ->  Vec<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn expression(&self, i: usize) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves first TerminalNode corresponding to token RSQUARE
/// Returns `None` if there is no child corresponding to token RSQUARE
fn RSQUARE(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(RSQUARE, 0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}

}

impl<'input> IndexingSuffixContextAttrs<'input> for IndexingSuffixContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn indexingSuffix(&mut self,)
	-> Result<Rc<IndexingSuffixContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = IndexingSuffixContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 198, RULE_indexingSuffix);
        let mut _localctx: Rc<IndexingSuffixContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2392);
			recog.base.match_token(LSQUARE,&mut recog.err_handler)?;

			recog.base.set_state(2396);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(356,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					recog.base.set_state(2393);
					recog.base.match_token(NL,&mut recog.err_handler)?;

					}
					} 
				}
				recog.base.set_state(2398);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(356,&mut recog.base)?;
			}
			/*InvokeRule expression*/
			recog.base.set_state(2399);
			recog.expression()?;

			recog.base.set_state(2416);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(359,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					recog.base.set_state(2403);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(2400);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(2405);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(2406);
					recog.base.match_token(COMMA,&mut recog.err_handler)?;

					recog.base.set_state(2410);
					recog.err_handler.sync(&mut recog.base)?;
					_alt = recog.interpreter.adaptive_predict(358,&mut recog.base)?;
					while { _alt!=2 && _alt!=INVALID_ALT } {
						if _alt==1 {
							{
							{
							recog.base.set_state(2407);
							recog.base.match_token(NL,&mut recog.err_handler)?;

							}
							} 
						}
						recog.base.set_state(2412);
						recog.err_handler.sync(&mut recog.base)?;
						_alt = recog.interpreter.adaptive_predict(358,&mut recog.base)?;
					}
					/*InvokeRule expression*/
					recog.base.set_state(2413);
					recog.expression()?;

					}
					} 
				}
				recog.base.set_state(2418);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(359,&mut recog.base)?;
			}
			recog.base.set_state(2426);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(361,&mut recog.base)? {
				x if x == 1=>{
					{
					recog.base.set_state(2422);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(2419);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(2424);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(2425);
					recog.base.match_token(COMMA,&mut recog.err_handler)?;

					}
				}

				_ => {}
			}
			recog.base.set_state(2431);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(2428);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(2433);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(2434);
			recog.base.match_token(RSQUARE,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- navigationSuffix ----------------
pub type NavigationSuffixContextAll<'input> = NavigationSuffixContext<'input>;


pub type NavigationSuffixContext<'input> = BaseParserRuleContext<'input,NavigationSuffixContextExt<'input>>;

#[derive(Clone)]
pub struct NavigationSuffixContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for NavigationSuffixContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for NavigationSuffixContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_navigationSuffix(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_navigationSuffix(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for NavigationSuffixContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_navigationSuffix(self);
	}
}

impl<'input> CustomRuleContext<'input> for NavigationSuffixContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_navigationSuffix }
	//fn type_rule_index() -> usize where Self: Sized { RULE_navigationSuffix }
}
antlr_rust::type_id!{NavigationSuffixContextExt<'a>}

impl<'input> NavigationSuffixContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<NavigationSuffixContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,NavigationSuffixContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait NavigationSuffixContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<NavigationSuffixContextExt<'input>>{

fn memberAccessOperator(&self) -> Option<Rc<MemberAccessOperatorContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn simpleIdentifier(&self) -> Option<Rc<SimpleIdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn parenthesizedExpression(&self) -> Option<Rc<ParenthesizedExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token CLASS
/// Returns `None` if there is no child corresponding to token CLASS
fn CLASS(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(CLASS, 0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}

}

impl<'input> NavigationSuffixContextAttrs<'input> for NavigationSuffixContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn navigationSuffix(&mut self,)
	-> Result<Rc<NavigationSuffixContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = NavigationSuffixContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 200, RULE_navigationSuffix);
        let mut _localctx: Rc<NavigationSuffixContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule memberAccessOperator*/
			recog.base.set_state(2436);
			recog.memberAccessOperator()?;

			recog.base.set_state(2440);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(2437);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(2442);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(2446);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 FILE | FIELD | PROPERTY | GET | SET | RECEIVER | PARAM | SETPARAM | DELEGATE |
			 IMPORT | CONSTRUCTOR | BY | COMPANION | INIT | WHERE | CATCH | FINALLY |
			 OUT | DYNAMIC | PUBLIC | PRIVATE | PROTECTED | INTERNAL | ENUM | SEALED |
			 ANNOTATION | DATA | INNER | VALUE | TAILREC | OPERATOR | INLINE | INFIX |
			 EXTERNAL | SUSPEND | OVERRIDE | ABSTRACT | FINAL | OPEN | CONST | LATEINIT |
			 VARARG | NOINLINE | CROSSINLINE | REIFIED | EXPECT | ACTUAL | Identifier 
				=> {
					{
					/*InvokeRule simpleIdentifier*/
					recog.base.set_state(2443);
					recog.simpleIdentifier()?;

					}
				}

			 LPAREN 
				=> {
					{
					/*InvokeRule parenthesizedExpression*/
					recog.base.set_state(2444);
					recog.parenthesizedExpression()?;

					}
				}

			 CLASS 
				=> {
					{
					recog.base.set_state(2445);
					recog.base.match_token(CLASS,&mut recog.err_handler)?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- callSuffix ----------------
pub type CallSuffixContextAll<'input> = CallSuffixContext<'input>;


pub type CallSuffixContext<'input> = BaseParserRuleContext<'input,CallSuffixContextExt<'input>>;

#[derive(Clone)]
pub struct CallSuffixContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for CallSuffixContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for CallSuffixContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_callSuffix(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_callSuffix(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for CallSuffixContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_callSuffix(self);
	}
}

impl<'input> CustomRuleContext<'input> for CallSuffixContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_callSuffix }
	//fn type_rule_index() -> usize where Self: Sized { RULE_callSuffix }
}
antlr_rust::type_id!{CallSuffixContextExt<'a>}

impl<'input> CallSuffixContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<CallSuffixContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,CallSuffixContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait CallSuffixContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<CallSuffixContextExt<'input>>{

fn annotatedLambda(&self) -> Option<Rc<AnnotatedLambdaContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn valueArguments(&self) -> Option<Rc<ValueArgumentsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn typeArguments(&self) -> Option<Rc<TypeArgumentsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> CallSuffixContextAttrs<'input> for CallSuffixContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn callSuffix(&mut self,)
	-> Result<Rc<CallSuffixContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = CallSuffixContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 202, RULE_callSuffix);
        let mut _localctx: Rc<CallSuffixContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2449);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==LANGLE {
				{
				/*InvokeRule typeArguments*/
				recog.base.set_state(2448);
				recog.typeArguments()?;

				}
			}

			recog.base.set_state(2456);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(367,&mut recog.base)? {
				1 =>{
					{
					recog.base.set_state(2452);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==LPAREN {
						{
						/*InvokeRule valueArguments*/
						recog.base.set_state(2451);
						recog.valueArguments()?;

						}
					}

					/*InvokeRule annotatedLambda*/
					recog.base.set_state(2454);
					recog.annotatedLambda()?;

					}
				}
			,
				2 =>{
					{
					/*InvokeRule valueArguments*/
					recog.base.set_state(2455);
					recog.valueArguments()?;

					}
				}

				_ => {}
			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- annotatedLambda ----------------
pub type AnnotatedLambdaContextAll<'input> = AnnotatedLambdaContext<'input>;


pub type AnnotatedLambdaContext<'input> = BaseParserRuleContext<'input,AnnotatedLambdaContextExt<'input>>;

#[derive(Clone)]
pub struct AnnotatedLambdaContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for AnnotatedLambdaContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for AnnotatedLambdaContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_annotatedLambda(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_annotatedLambda(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for AnnotatedLambdaContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_annotatedLambda(self);
	}
}

impl<'input> CustomRuleContext<'input> for AnnotatedLambdaContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_annotatedLambda }
	//fn type_rule_index() -> usize where Self: Sized { RULE_annotatedLambda }
}
antlr_rust::type_id!{AnnotatedLambdaContextExt<'a>}

impl<'input> AnnotatedLambdaContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AnnotatedLambdaContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AnnotatedLambdaContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AnnotatedLambdaContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<AnnotatedLambdaContextExt<'input>>{

fn lambdaLiteral(&self) -> Option<Rc<LambdaLiteralContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn annotation_all(&self) ->  Vec<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn label(&self) -> Option<Rc<LabelContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}

}

impl<'input> AnnotatedLambdaContextAttrs<'input> for AnnotatedLambdaContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn annotatedLambda(&mut self,)
	-> Result<Rc<AnnotatedLambdaContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AnnotatedLambdaContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 204, RULE_annotatedLambda);
        let mut _localctx: Rc<AnnotatedLambdaContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2461);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==AT_NO_WS || _la==AT_PRE_WS {
				{
				{
				/*InvokeRule annotation*/
				recog.base.set_state(2458);
				recog.annotation()?;

				}
				}
				recog.base.set_state(2463);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(2465);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if ((((_la - 63)) & !0x3f) == 0 && ((1usize << (_la - 63)) & ((1usize << (FILE - 63)) | (1usize << (FIELD - 63)) | (1usize << (PROPERTY - 63)) | (1usize << (GET - 63)) | (1usize << (SET - 63)) | (1usize << (RECEIVER - 63)) | (1usize << (PARAM - 63)) | (1usize << (SETPARAM - 63)) | (1usize << (DELEGATE - 63)) | (1usize << (IMPORT - 63)) | (1usize << (CONSTRUCTOR - 63)) | (1usize << (BY - 63)) | (1usize << (COMPANION - 63)) | (1usize << (INIT - 63)) | (1usize << (WHERE - 63)) | (1usize << (CATCH - 63)) | (1usize << (FINALLY - 63)) | (1usize << (OUT - 63)) | (1usize << (DYNAMIC - 63)) | (1usize << (PUBLIC - 63)) | (1usize << (PRIVATE - 63)) | (1usize << (PROTECTED - 63)) | (1usize << (INTERNAL - 63)) | (1usize << (ENUM - 63)) | (1usize << (SEALED - 63)) | (1usize << (ANNOTATION - 63)) | (1usize << (DATA - 63)) | (1usize << (INNER - 63)) | (1usize << (VALUE - 63)) | (1usize << (TAILREC - 63)) | (1usize << (OPERATOR - 63)) | (1usize << (INLINE - 63)) | (1usize << (INFIX - 63)) | (1usize << (EXTERNAL - 63)) | (1usize << (SUSPEND - 63)) | (1usize << (OVERRIDE - 63)) | (1usize << (ABSTRACT - 63)))) != 0) || ((((_la - 127)) & !0x3f) == 0 && ((1usize << (_la - 127)) & ((1usize << (FINAL - 127)) | (1usize << (OPEN - 127)) | (1usize << (CONST - 127)) | (1usize << (LATEINIT - 127)) | (1usize << (VARARG - 127)) | (1usize << (NOINLINE - 127)) | (1usize << (CROSSINLINE - 127)) | (1usize << (REIFIED - 127)) | (1usize << (EXPECT - 127)) | (1usize << (ACTUAL - 127)) | (1usize << (Identifier - 127)))) != 0) {
				{
				/*InvokeRule label*/
				recog.base.set_state(2464);
				recog.label()?;

				}
			}

			recog.base.set_state(2470);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(2467);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(2472);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			/*InvokeRule lambdaLiteral*/
			recog.base.set_state(2473);
			recog.lambdaLiteral()?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- typeArguments ----------------
pub type TypeArgumentsContextAll<'input> = TypeArgumentsContext<'input>;


pub type TypeArgumentsContext<'input> = BaseParserRuleContext<'input,TypeArgumentsContextExt<'input>>;

#[derive(Clone)]
pub struct TypeArgumentsContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for TypeArgumentsContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for TypeArgumentsContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_typeArguments(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_typeArguments(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for TypeArgumentsContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_typeArguments(self);
	}
}

impl<'input> CustomRuleContext<'input> for TypeArgumentsContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_typeArguments }
	//fn type_rule_index() -> usize where Self: Sized { RULE_typeArguments }
}
antlr_rust::type_id!{TypeArgumentsContextExt<'a>}

impl<'input> TypeArgumentsContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<TypeArgumentsContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,TypeArgumentsContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait TypeArgumentsContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<TypeArgumentsContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token LANGLE
/// Returns `None` if there is no child corresponding to token LANGLE
fn LANGLE(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(LANGLE, 0)
}
fn typeProjection_all(&self) ->  Vec<Rc<TypeProjectionContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn typeProjection(&self, i: usize) -> Option<Rc<TypeProjectionContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves first TerminalNode corresponding to token RANGLE
/// Returns `None` if there is no child corresponding to token RANGLE
fn RANGLE(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(RANGLE, 0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}

}

impl<'input> TypeArgumentsContextAttrs<'input> for TypeArgumentsContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn typeArguments(&mut self,)
	-> Result<Rc<TypeArgumentsContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = TypeArgumentsContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 206, RULE_typeArguments);
        let mut _localctx: Rc<TypeArgumentsContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2475);
			recog.base.match_token(LANGLE,&mut recog.err_handler)?;

			recog.base.set_state(2479);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(2476);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(2481);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			/*InvokeRule typeProjection*/
			recog.base.set_state(2482);
			recog.typeProjection()?;

			recog.base.set_state(2499);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(374,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					recog.base.set_state(2486);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(2483);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(2488);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(2489);
					recog.base.match_token(COMMA,&mut recog.err_handler)?;

					recog.base.set_state(2493);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(2490);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(2495);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					/*InvokeRule typeProjection*/
					recog.base.set_state(2496);
					recog.typeProjection()?;

					}
					} 
				}
				recog.base.set_state(2501);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(374,&mut recog.base)?;
			}
			recog.base.set_state(2509);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(376,&mut recog.base)? {
				x if x == 1=>{
					{
					recog.base.set_state(2505);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(2502);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(2507);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(2508);
					recog.base.match_token(COMMA,&mut recog.err_handler)?;

					}
				}

				_ => {}
			}
			recog.base.set_state(2514);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(2511);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(2516);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(2517);
			recog.base.match_token(RANGLE,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- valueArguments ----------------
pub type ValueArgumentsContextAll<'input> = ValueArgumentsContext<'input>;


pub type ValueArgumentsContext<'input> = BaseParserRuleContext<'input,ValueArgumentsContextExt<'input>>;

#[derive(Clone)]
pub struct ValueArgumentsContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for ValueArgumentsContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for ValueArgumentsContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_valueArguments(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_valueArguments(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for ValueArgumentsContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_valueArguments(self);
	}
}

impl<'input> CustomRuleContext<'input> for ValueArgumentsContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_valueArguments }
	//fn type_rule_index() -> usize where Self: Sized { RULE_valueArguments }
}
antlr_rust::type_id!{ValueArgumentsContextExt<'a>}

impl<'input> ValueArgumentsContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ValueArgumentsContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ValueArgumentsContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ValueArgumentsContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<ValueArgumentsContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token LPAREN
/// Returns `None` if there is no child corresponding to token LPAREN
fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(LPAREN, 0)
}
/// Retrieves first TerminalNode corresponding to token RPAREN
/// Returns `None` if there is no child corresponding to token RPAREN
fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(RPAREN, 0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}
fn valueArgument_all(&self) ->  Vec<Rc<ValueArgumentContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn valueArgument(&self, i: usize) -> Option<Rc<ValueArgumentContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}

}

impl<'input> ValueArgumentsContextAttrs<'input> for ValueArgumentsContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn valueArguments(&mut self,)
	-> Result<Rc<ValueArgumentsContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ValueArgumentsContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 208, RULE_valueArguments);
        let mut _localctx: Rc<ValueArgumentsContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2519);
			recog.base.match_token(LPAREN,&mut recog.err_handler)?;

			recog.base.set_state(2523);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(378,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					recog.base.set_state(2520);
					recog.base.match_token(NL,&mut recog.err_handler)?;

					}
					} 
				}
				recog.base.set_state(2525);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(378,&mut recog.base)?;
			}
			recog.base.set_state(2561);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << NL) | (1usize << LPAREN) | (1usize << LSQUARE) | (1usize << LCURL) | (1usize << MULT) | (1usize << ADD) | (1usize << SUB) | (1usize << INCR) | (1usize << DECR) | (1usize << EXCL_WS) | (1usize << EXCL_NO_WS) | (1usize << COLONCOLON) | (1usize << AT_NO_WS) | (1usize << AT_PRE_WS) | (1usize << RETURN_AT) | (1usize << CONTINUE_AT) | (1usize << BREAK_AT) | (1usize << THIS_AT) | (1usize << SUPER_AT) | (1usize << FILE))) != 0) || ((((_la - 64)) & !0x3f) == 0 && ((1usize << (_la - 64)) & ((1usize << (FIELD - 64)) | (1usize << (PROPERTY - 64)) | (1usize << (GET - 64)) | (1usize << (SET - 64)) | (1usize << (RECEIVER - 64)) | (1usize << (PARAM - 64)) | (1usize << (SETPARAM - 64)) | (1usize << (DELEGATE - 64)) | (1usize << (IMPORT - 64)) | (1usize << (FUN - 64)) | (1usize << (OBJECT - 64)) | (1usize << (CONSTRUCTOR - 64)) | (1usize << (BY - 64)) | (1usize << (COMPANION - 64)) | (1usize << (INIT - 64)) | (1usize << (THIS - 64)) | (1usize << (SUPER - 64)) | (1usize << (WHERE - 64)) | (1usize << (IF - 64)) | (1usize << (WHEN - 64)) | (1usize << (TRY - 64)) | (1usize << (CATCH - 64)) | (1usize << (FINALLY - 64)) | (1usize << (THROW - 64)) | (1usize << (RETURN - 64)) | (1usize << (CONTINUE - 64)) | (1usize << (BREAK - 64)) | (1usize << (OUT - 64)) | (1usize << (DYNAMIC - 64)) | (1usize << (PUBLIC - 64)) | (1usize << (PRIVATE - 64)) | (1usize << (PROTECTED - 64)) | (1usize << (INTERNAL - 64)) | (1usize << (ENUM - 64)) | (1usize << (SEALED - 64)) | (1usize << (ANNOTATION - 64)) | (1usize << (DATA - 64)) | (1usize << (INNER - 64)) | (1usize << (VALUE - 64)) | (1usize << (TAILREC - 64)) | (1usize << (OPERATOR - 64)) | (1usize << (INLINE - 64)) | (1usize << (INFIX - 64)) | (1usize << (EXTERNAL - 64)) | (1usize << (SUSPEND - 64)) | (1usize << (OVERRIDE - 64)) | (1usize << (ABSTRACT - 64)) | (1usize << (FINAL - 64)))) != 0) || ((((_la - 128)) & !0x3f) == 0 && ((1usize << (_la - 128)) & ((1usize << (OPEN - 128)) | (1usize << (CONST - 128)) | (1usize << (LATEINIT - 128)) | (1usize << (VARARG - 128)) | (1usize << (NOINLINE - 128)) | (1usize << (CROSSINLINE - 128)) | (1usize << (REIFIED - 128)) | (1usize << (EXPECT - 128)) | (1usize << (ACTUAL - 128)) | (1usize << (RealLiteral - 128)) | (1usize << (IntegerLiteral - 128)) | (1usize << (HexLiteral - 128)) | (1usize << (BinLiteral - 128)) | (1usize << (UnsignedLiteral - 128)) | (1usize << (LongLiteral - 128)) | (1usize << (BooleanLiteral - 128)) | (1usize << (NullLiteral - 128)) | (1usize << (CharacterLiteral - 128)) | (1usize << (Identifier - 128)) | (1usize << (QUOTE_OPEN - 128)) | (1usize << (TRIPLE_QUOTE_OPEN - 128)))) != 0) {
				{
				/*InvokeRule valueArgument*/
				recog.base.set_state(2526);
				recog.valueArgument()?;

				recog.base.set_state(2543);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(381,&mut recog.base)?;
				while { _alt!=2 && _alt!=INVALID_ALT } {
					if _alt==1 {
						{
						{
						recog.base.set_state(2530);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
						while _la==NL {
							{
							{
							recog.base.set_state(2527);
							recog.base.match_token(NL,&mut recog.err_handler)?;

							}
							}
							recog.base.set_state(2532);
							recog.err_handler.sync(&mut recog.base)?;
							_la = recog.base.input.la(1);
						}
						recog.base.set_state(2533);
						recog.base.match_token(COMMA,&mut recog.err_handler)?;

						recog.base.set_state(2537);
						recog.err_handler.sync(&mut recog.base)?;
						_alt = recog.interpreter.adaptive_predict(380,&mut recog.base)?;
						while { _alt!=2 && _alt!=INVALID_ALT } {
							if _alt==1 {
								{
								{
								recog.base.set_state(2534);
								recog.base.match_token(NL,&mut recog.err_handler)?;

								}
								} 
							}
							recog.base.set_state(2539);
							recog.err_handler.sync(&mut recog.base)?;
							_alt = recog.interpreter.adaptive_predict(380,&mut recog.base)?;
						}
						/*InvokeRule valueArgument*/
						recog.base.set_state(2540);
						recog.valueArgument()?;

						}
						} 
					}
					recog.base.set_state(2545);
					recog.err_handler.sync(&mut recog.base)?;
					_alt = recog.interpreter.adaptive_predict(381,&mut recog.base)?;
				}
				recog.base.set_state(2553);
				recog.err_handler.sync(&mut recog.base)?;
				match  recog.interpreter.adaptive_predict(383,&mut recog.base)? {
					x if x == 1=>{
						{
						recog.base.set_state(2549);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
						while _la==NL {
							{
							{
							recog.base.set_state(2546);
							recog.base.match_token(NL,&mut recog.err_handler)?;

							}
							}
							recog.base.set_state(2551);
							recog.err_handler.sync(&mut recog.base)?;
							_la = recog.base.input.la(1);
						}
						recog.base.set_state(2552);
						recog.base.match_token(COMMA,&mut recog.err_handler)?;

						}
					}

					_ => {}
				}
				recog.base.set_state(2558);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
				while _la==NL {
					{
					{
					recog.base.set_state(2555);
					recog.base.match_token(NL,&mut recog.err_handler)?;

					}
					}
					recog.base.set_state(2560);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
				}
				}
			}

			recog.base.set_state(2563);
			recog.base.match_token(RPAREN,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- valueArgument ----------------
pub type ValueArgumentContextAll<'input> = ValueArgumentContext<'input>;


pub type ValueArgumentContext<'input> = BaseParserRuleContext<'input,ValueArgumentContextExt<'input>>;

#[derive(Clone)]
pub struct ValueArgumentContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for ValueArgumentContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for ValueArgumentContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_valueArgument(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_valueArgument(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for ValueArgumentContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_valueArgument(self);
	}
}

impl<'input> CustomRuleContext<'input> for ValueArgumentContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_valueArgument }
	//fn type_rule_index() -> usize where Self: Sized { RULE_valueArgument }
}
antlr_rust::type_id!{ValueArgumentContextExt<'a>}

impl<'input> ValueArgumentContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ValueArgumentContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ValueArgumentContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ValueArgumentContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<ValueArgumentContextExt<'input>>{

fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn annotation(&self) -> Option<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}
fn simpleIdentifier(&self) -> Option<Rc<SimpleIdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token ASSIGNMENT
/// Returns `None` if there is no child corresponding to token ASSIGNMENT
fn ASSIGNMENT(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(ASSIGNMENT, 0)
}
/// Retrieves first TerminalNode corresponding to token MULT
/// Returns `None` if there is no child corresponding to token MULT
fn MULT(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(MULT, 0)
}

}

impl<'input> ValueArgumentContextAttrs<'input> for ValueArgumentContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn valueArgument(&mut self,)
	-> Result<Rc<ValueArgumentContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ValueArgumentContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 210, RULE_valueArgument);
        let mut _localctx: Rc<ValueArgumentContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2566);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(386,&mut recog.base)? {
				x if x == 1=>{
					{
					/*InvokeRule annotation*/
					recog.base.set_state(2565);
					recog.annotation()?;

					}
				}

				_ => {}
			}
			recog.base.set_state(2571);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(387,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					recog.base.set_state(2568);
					recog.base.match_token(NL,&mut recog.err_handler)?;

					}
					} 
				}
				recog.base.set_state(2573);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(387,&mut recog.base)?;
			}
			recog.base.set_state(2588);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(390,&mut recog.base)? {
				x if x == 1=>{
					{
					/*InvokeRule simpleIdentifier*/
					recog.base.set_state(2574);
					recog.simpleIdentifier()?;

					recog.base.set_state(2578);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(2575);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(2580);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(2581);
					recog.base.match_token(ASSIGNMENT,&mut recog.err_handler)?;

					recog.base.set_state(2585);
					recog.err_handler.sync(&mut recog.base)?;
					_alt = recog.interpreter.adaptive_predict(389,&mut recog.base)?;
					while { _alt!=2 && _alt!=INVALID_ALT } {
						if _alt==1 {
							{
							{
							recog.base.set_state(2582);
							recog.base.match_token(NL,&mut recog.err_handler)?;

							}
							} 
						}
						recog.base.set_state(2587);
						recog.err_handler.sync(&mut recog.base)?;
						_alt = recog.interpreter.adaptive_predict(389,&mut recog.base)?;
					}
					}
				}

				_ => {}
			}
			recog.base.set_state(2591);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==MULT {
				{
				recog.base.set_state(2590);
				recog.base.match_token(MULT,&mut recog.err_handler)?;

				}
			}

			recog.base.set_state(2596);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(392,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					recog.base.set_state(2593);
					recog.base.match_token(NL,&mut recog.err_handler)?;

					}
					} 
				}
				recog.base.set_state(2598);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(392,&mut recog.base)?;
			}
			/*InvokeRule expression*/
			recog.base.set_state(2599);
			recog.expression()?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- primaryExpression ----------------
pub type PrimaryExpressionContextAll<'input> = PrimaryExpressionContext<'input>;


pub type PrimaryExpressionContext<'input> = BaseParserRuleContext<'input,PrimaryExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct PrimaryExpressionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for PrimaryExpressionContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for PrimaryExpressionContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_primaryExpression(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_primaryExpression(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for PrimaryExpressionContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_primaryExpression(self);
	}
}

impl<'input> CustomRuleContext<'input> for PrimaryExpressionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_primaryExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_primaryExpression }
}
antlr_rust::type_id!{PrimaryExpressionContextExt<'a>}

impl<'input> PrimaryExpressionContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<PrimaryExpressionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,PrimaryExpressionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait PrimaryExpressionContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<PrimaryExpressionContextExt<'input>>{

fn parenthesizedExpression(&self) -> Option<Rc<ParenthesizedExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn simpleIdentifier(&self) -> Option<Rc<SimpleIdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn literalConstant(&self) -> Option<Rc<LiteralConstantContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn stringLiteral(&self) -> Option<Rc<StringLiteralContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn callableReference(&self) -> Option<Rc<CallableReferenceContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn functionLiteral(&self) -> Option<Rc<FunctionLiteralContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn objectLiteral(&self) -> Option<Rc<ObjectLiteralContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn collectionLiteral(&self) -> Option<Rc<CollectionLiteralContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn thisExpression(&self) -> Option<Rc<ThisExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn superExpression(&self) -> Option<Rc<SuperExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn ifExpression(&self) -> Option<Rc<IfExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn whenExpression(&self) -> Option<Rc<WhenExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn tryExpression(&self) -> Option<Rc<TryExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn jumpExpression(&self) -> Option<Rc<JumpExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> PrimaryExpressionContextAttrs<'input> for PrimaryExpressionContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn primaryExpression(&mut self,)
	-> Result<Rc<PrimaryExpressionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = PrimaryExpressionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 212, RULE_primaryExpression);
        let mut _localctx: Rc<PrimaryExpressionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			recog.base.set_state(2615);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(393,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule parenthesizedExpression*/
					recog.base.set_state(2601);
					recog.parenthesizedExpression()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule simpleIdentifier*/
					recog.base.set_state(2602);
					recog.simpleIdentifier()?;

					}
				}
			,
				3 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					/*InvokeRule literalConstant*/
					recog.base.set_state(2603);
					recog.literalConstant()?;

					}
				}
			,
				4 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 4);
					recog.base.enter_outer_alt(None, 4);
					{
					/*InvokeRule stringLiteral*/
					recog.base.set_state(2604);
					recog.stringLiteral()?;

					}
				}
			,
				5 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 5);
					recog.base.enter_outer_alt(None, 5);
					{
					/*InvokeRule callableReference*/
					recog.base.set_state(2605);
					recog.callableReference()?;

					}
				}
			,
				6 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 6);
					recog.base.enter_outer_alt(None, 6);
					{
					/*InvokeRule functionLiteral*/
					recog.base.set_state(2606);
					recog.functionLiteral()?;

					}
				}
			,
				7 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 7);
					recog.base.enter_outer_alt(None, 7);
					{
					/*InvokeRule objectLiteral*/
					recog.base.set_state(2607);
					recog.objectLiteral()?;

					}
				}
			,
				8 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 8);
					recog.base.enter_outer_alt(None, 8);
					{
					/*InvokeRule collectionLiteral*/
					recog.base.set_state(2608);
					recog.collectionLiteral()?;

					}
				}
			,
				9 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 9);
					recog.base.enter_outer_alt(None, 9);
					{
					/*InvokeRule thisExpression*/
					recog.base.set_state(2609);
					recog.thisExpression()?;

					}
				}
			,
				10 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 10);
					recog.base.enter_outer_alt(None, 10);
					{
					/*InvokeRule superExpression*/
					recog.base.set_state(2610);
					recog.superExpression()?;

					}
				}
			,
				11 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 11);
					recog.base.enter_outer_alt(None, 11);
					{
					/*InvokeRule ifExpression*/
					recog.base.set_state(2611);
					recog.ifExpression()?;

					}
				}
			,
				12 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 12);
					recog.base.enter_outer_alt(None, 12);
					{
					/*InvokeRule whenExpression*/
					recog.base.set_state(2612);
					recog.whenExpression()?;

					}
				}
			,
				13 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 13);
					recog.base.enter_outer_alt(None, 13);
					{
					/*InvokeRule tryExpression*/
					recog.base.set_state(2613);
					recog.tryExpression()?;

					}
				}
			,
				14 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 14);
					recog.base.enter_outer_alt(None, 14);
					{
					/*InvokeRule jumpExpression*/
					recog.base.set_state(2614);
					recog.jumpExpression()?;

					}
				}

				_ => {}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- parenthesizedExpression ----------------
pub type ParenthesizedExpressionContextAll<'input> = ParenthesizedExpressionContext<'input>;


pub type ParenthesizedExpressionContext<'input> = BaseParserRuleContext<'input,ParenthesizedExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct ParenthesizedExpressionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for ParenthesizedExpressionContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for ParenthesizedExpressionContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_parenthesizedExpression(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_parenthesizedExpression(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for ParenthesizedExpressionContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_parenthesizedExpression(self);
	}
}

impl<'input> CustomRuleContext<'input> for ParenthesizedExpressionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_parenthesizedExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_parenthesizedExpression }
}
antlr_rust::type_id!{ParenthesizedExpressionContextExt<'a>}

impl<'input> ParenthesizedExpressionContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ParenthesizedExpressionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ParenthesizedExpressionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ParenthesizedExpressionContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<ParenthesizedExpressionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token LPAREN
/// Returns `None` if there is no child corresponding to token LPAREN
fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(LPAREN, 0)
}
fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token RPAREN
/// Returns `None` if there is no child corresponding to token RPAREN
fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(RPAREN, 0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}

}

impl<'input> ParenthesizedExpressionContextAttrs<'input> for ParenthesizedExpressionContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn parenthesizedExpression(&mut self,)
	-> Result<Rc<ParenthesizedExpressionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ParenthesizedExpressionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 214, RULE_parenthesizedExpression);
        let mut _localctx: Rc<ParenthesizedExpressionContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2617);
			recog.base.match_token(LPAREN,&mut recog.err_handler)?;

			recog.base.set_state(2621);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(394,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					recog.base.set_state(2618);
					recog.base.match_token(NL,&mut recog.err_handler)?;

					}
					} 
				}
				recog.base.set_state(2623);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(394,&mut recog.base)?;
			}
			/*InvokeRule expression*/
			recog.base.set_state(2624);
			recog.expression()?;

			recog.base.set_state(2628);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(2625);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(2630);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(2631);
			recog.base.match_token(RPAREN,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- collectionLiteral ----------------
pub type CollectionLiteralContextAll<'input> = CollectionLiteralContext<'input>;


pub type CollectionLiteralContext<'input> = BaseParserRuleContext<'input,CollectionLiteralContextExt<'input>>;

#[derive(Clone)]
pub struct CollectionLiteralContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for CollectionLiteralContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for CollectionLiteralContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_collectionLiteral(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_collectionLiteral(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for CollectionLiteralContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_collectionLiteral(self);
	}
}

impl<'input> CustomRuleContext<'input> for CollectionLiteralContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_collectionLiteral }
	//fn type_rule_index() -> usize where Self: Sized { RULE_collectionLiteral }
}
antlr_rust::type_id!{CollectionLiteralContextExt<'a>}

impl<'input> CollectionLiteralContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<CollectionLiteralContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,CollectionLiteralContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait CollectionLiteralContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<CollectionLiteralContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token LSQUARE
/// Returns `None` if there is no child corresponding to token LSQUARE
fn LSQUARE(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(LSQUARE, 0)
}
/// Retrieves first TerminalNode corresponding to token RSQUARE
/// Returns `None` if there is no child corresponding to token RSQUARE
fn RSQUARE(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(RSQUARE, 0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}
fn expression_all(&self) ->  Vec<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn expression(&self, i: usize) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}

}

impl<'input> CollectionLiteralContextAttrs<'input> for CollectionLiteralContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn collectionLiteral(&mut self,)
	-> Result<Rc<CollectionLiteralContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = CollectionLiteralContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 216, RULE_collectionLiteral);
        let mut _localctx: Rc<CollectionLiteralContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2633);
			recog.base.match_token(LSQUARE,&mut recog.err_handler)?;

			recog.base.set_state(2637);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(396,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					recog.base.set_state(2634);
					recog.base.match_token(NL,&mut recog.err_handler)?;

					}
					} 
				}
				recog.base.set_state(2639);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(396,&mut recog.base)?;
			}
			recog.base.set_state(2675);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << NL) | (1usize << LPAREN) | (1usize << LSQUARE) | (1usize << LCURL) | (1usize << ADD) | (1usize << SUB) | (1usize << INCR) | (1usize << DECR) | (1usize << EXCL_WS) | (1usize << EXCL_NO_WS) | (1usize << COLONCOLON) | (1usize << AT_NO_WS) | (1usize << AT_PRE_WS) | (1usize << RETURN_AT) | (1usize << CONTINUE_AT) | (1usize << BREAK_AT) | (1usize << THIS_AT) | (1usize << SUPER_AT) | (1usize << FILE))) != 0) || ((((_la - 64)) & !0x3f) == 0 && ((1usize << (_la - 64)) & ((1usize << (FIELD - 64)) | (1usize << (PROPERTY - 64)) | (1usize << (GET - 64)) | (1usize << (SET - 64)) | (1usize << (RECEIVER - 64)) | (1usize << (PARAM - 64)) | (1usize << (SETPARAM - 64)) | (1usize << (DELEGATE - 64)) | (1usize << (IMPORT - 64)) | (1usize << (FUN - 64)) | (1usize << (OBJECT - 64)) | (1usize << (CONSTRUCTOR - 64)) | (1usize << (BY - 64)) | (1usize << (COMPANION - 64)) | (1usize << (INIT - 64)) | (1usize << (THIS - 64)) | (1usize << (SUPER - 64)) | (1usize << (WHERE - 64)) | (1usize << (IF - 64)) | (1usize << (WHEN - 64)) | (1usize << (TRY - 64)) | (1usize << (CATCH - 64)) | (1usize << (FINALLY - 64)) | (1usize << (THROW - 64)) | (1usize << (RETURN - 64)) | (1usize << (CONTINUE - 64)) | (1usize << (BREAK - 64)) | (1usize << (OUT - 64)) | (1usize << (DYNAMIC - 64)) | (1usize << (PUBLIC - 64)) | (1usize << (PRIVATE - 64)) | (1usize << (PROTECTED - 64)) | (1usize << (INTERNAL - 64)) | (1usize << (ENUM - 64)) | (1usize << (SEALED - 64)) | (1usize << (ANNOTATION - 64)) | (1usize << (DATA - 64)) | (1usize << (INNER - 64)) | (1usize << (VALUE - 64)) | (1usize << (TAILREC - 64)) | (1usize << (OPERATOR - 64)) | (1usize << (INLINE - 64)) | (1usize << (INFIX - 64)) | (1usize << (EXTERNAL - 64)) | (1usize << (SUSPEND - 64)) | (1usize << (OVERRIDE - 64)) | (1usize << (ABSTRACT - 64)) | (1usize << (FINAL - 64)))) != 0) || ((((_la - 128)) & !0x3f) == 0 && ((1usize << (_la - 128)) & ((1usize << (OPEN - 128)) | (1usize << (CONST - 128)) | (1usize << (LATEINIT - 128)) | (1usize << (VARARG - 128)) | (1usize << (NOINLINE - 128)) | (1usize << (CROSSINLINE - 128)) | (1usize << (REIFIED - 128)) | (1usize << (EXPECT - 128)) | (1usize << (ACTUAL - 128)) | (1usize << (RealLiteral - 128)) | (1usize << (IntegerLiteral - 128)) | (1usize << (HexLiteral - 128)) | (1usize << (BinLiteral - 128)) | (1usize << (UnsignedLiteral - 128)) | (1usize << (LongLiteral - 128)) | (1usize << (BooleanLiteral - 128)) | (1usize << (NullLiteral - 128)) | (1usize << (CharacterLiteral - 128)) | (1usize << (Identifier - 128)) | (1usize << (QUOTE_OPEN - 128)) | (1usize << (TRIPLE_QUOTE_OPEN - 128)))) != 0) {
				{
				/*InvokeRule expression*/
				recog.base.set_state(2640);
				recog.expression()?;

				recog.base.set_state(2657);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(399,&mut recog.base)?;
				while { _alt!=2 && _alt!=INVALID_ALT } {
					if _alt==1 {
						{
						{
						recog.base.set_state(2644);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
						while _la==NL {
							{
							{
							recog.base.set_state(2641);
							recog.base.match_token(NL,&mut recog.err_handler)?;

							}
							}
							recog.base.set_state(2646);
							recog.err_handler.sync(&mut recog.base)?;
							_la = recog.base.input.la(1);
						}
						recog.base.set_state(2647);
						recog.base.match_token(COMMA,&mut recog.err_handler)?;

						recog.base.set_state(2651);
						recog.err_handler.sync(&mut recog.base)?;
						_alt = recog.interpreter.adaptive_predict(398,&mut recog.base)?;
						while { _alt!=2 && _alt!=INVALID_ALT } {
							if _alt==1 {
								{
								{
								recog.base.set_state(2648);
								recog.base.match_token(NL,&mut recog.err_handler)?;

								}
								} 
							}
							recog.base.set_state(2653);
							recog.err_handler.sync(&mut recog.base)?;
							_alt = recog.interpreter.adaptive_predict(398,&mut recog.base)?;
						}
						/*InvokeRule expression*/
						recog.base.set_state(2654);
						recog.expression()?;

						}
						} 
					}
					recog.base.set_state(2659);
					recog.err_handler.sync(&mut recog.base)?;
					_alt = recog.interpreter.adaptive_predict(399,&mut recog.base)?;
				}
				recog.base.set_state(2667);
				recog.err_handler.sync(&mut recog.base)?;
				match  recog.interpreter.adaptive_predict(401,&mut recog.base)? {
					x if x == 1=>{
						{
						recog.base.set_state(2663);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
						while _la==NL {
							{
							{
							recog.base.set_state(2660);
							recog.base.match_token(NL,&mut recog.err_handler)?;

							}
							}
							recog.base.set_state(2665);
							recog.err_handler.sync(&mut recog.base)?;
							_la = recog.base.input.la(1);
						}
						recog.base.set_state(2666);
						recog.base.match_token(COMMA,&mut recog.err_handler)?;

						}
					}

					_ => {}
				}
				recog.base.set_state(2672);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
				while _la==NL {
					{
					{
					recog.base.set_state(2669);
					recog.base.match_token(NL,&mut recog.err_handler)?;

					}
					}
					recog.base.set_state(2674);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
				}
				}
			}

			recog.base.set_state(2677);
			recog.base.match_token(RSQUARE,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- literalConstant ----------------
pub type LiteralConstantContextAll<'input> = LiteralConstantContext<'input>;


pub type LiteralConstantContext<'input> = BaseParserRuleContext<'input,LiteralConstantContextExt<'input>>;

#[derive(Clone)]
pub struct LiteralConstantContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for LiteralConstantContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for LiteralConstantContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_literalConstant(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_literalConstant(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for LiteralConstantContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_literalConstant(self);
	}
}

impl<'input> CustomRuleContext<'input> for LiteralConstantContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_literalConstant }
	//fn type_rule_index() -> usize where Self: Sized { RULE_literalConstant }
}
antlr_rust::type_id!{LiteralConstantContextExt<'a>}

impl<'input> LiteralConstantContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<LiteralConstantContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,LiteralConstantContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait LiteralConstantContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<LiteralConstantContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token BooleanLiteral
/// Returns `None` if there is no child corresponding to token BooleanLiteral
fn BooleanLiteral(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(BooleanLiteral, 0)
}
/// Retrieves first TerminalNode corresponding to token IntegerLiteral
/// Returns `None` if there is no child corresponding to token IntegerLiteral
fn IntegerLiteral(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(IntegerLiteral, 0)
}
/// Retrieves first TerminalNode corresponding to token HexLiteral
/// Returns `None` if there is no child corresponding to token HexLiteral
fn HexLiteral(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(HexLiteral, 0)
}
/// Retrieves first TerminalNode corresponding to token BinLiteral
/// Returns `None` if there is no child corresponding to token BinLiteral
fn BinLiteral(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(BinLiteral, 0)
}
/// Retrieves first TerminalNode corresponding to token CharacterLiteral
/// Returns `None` if there is no child corresponding to token CharacterLiteral
fn CharacterLiteral(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(CharacterLiteral, 0)
}
/// Retrieves first TerminalNode corresponding to token RealLiteral
/// Returns `None` if there is no child corresponding to token RealLiteral
fn RealLiteral(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(RealLiteral, 0)
}
/// Retrieves first TerminalNode corresponding to token NullLiteral
/// Returns `None` if there is no child corresponding to token NullLiteral
fn NullLiteral(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NullLiteral, 0)
}
/// Retrieves first TerminalNode corresponding to token LongLiteral
/// Returns `None` if there is no child corresponding to token LongLiteral
fn LongLiteral(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(LongLiteral, 0)
}
/// Retrieves first TerminalNode corresponding to token UnsignedLiteral
/// Returns `None` if there is no child corresponding to token UnsignedLiteral
fn UnsignedLiteral(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(UnsignedLiteral, 0)
}

}

impl<'input> LiteralConstantContextAttrs<'input> for LiteralConstantContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn literalConstant(&mut self,)
	-> Result<Rc<LiteralConstantContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = LiteralConstantContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 218, RULE_literalConstant);
        let mut _localctx: Rc<LiteralConstantContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2679);
			_la = recog.base.input.la(1);
			if { !(((((_la - 137)) & !0x3f) == 0 && ((1usize << (_la - 137)) & ((1usize << (RealLiteral - 137)) | (1usize << (IntegerLiteral - 137)) | (1usize << (HexLiteral - 137)) | (1usize << (BinLiteral - 137)) | (1usize << (UnsignedLiteral - 137)) | (1usize << (LongLiteral - 137)) | (1usize << (BooleanLiteral - 137)) | (1usize << (NullLiteral - 137)) | (1usize << (CharacterLiteral - 137)))) != 0)) } {
				recog.err_handler.recover_inline(&mut recog.base)?;

			}
			else {
				if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
				recog.err_handler.report_match(&mut recog.base);
				recog.base.consume(&mut recog.err_handler);
			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- stringLiteral ----------------
pub type StringLiteralContextAll<'input> = StringLiteralContext<'input>;


pub type StringLiteralContext<'input> = BaseParserRuleContext<'input,StringLiteralContextExt<'input>>;

#[derive(Clone)]
pub struct StringLiteralContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for StringLiteralContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for StringLiteralContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_stringLiteral(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_stringLiteral(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for StringLiteralContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_stringLiteral(self);
	}
}

impl<'input> CustomRuleContext<'input> for StringLiteralContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_stringLiteral }
	//fn type_rule_index() -> usize where Self: Sized { RULE_stringLiteral }
}
antlr_rust::type_id!{StringLiteralContextExt<'a>}

impl<'input> StringLiteralContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<StringLiteralContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,StringLiteralContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait StringLiteralContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<StringLiteralContextExt<'input>>{

fn lineStringLiteral(&self) -> Option<Rc<LineStringLiteralContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn multiLineStringLiteral(&self) -> Option<Rc<MultiLineStringLiteralContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> StringLiteralContextAttrs<'input> for StringLiteralContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn stringLiteral(&mut self,)
	-> Result<Rc<StringLiteralContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = StringLiteralContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 220, RULE_stringLiteral);
        let mut _localctx: Rc<StringLiteralContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			recog.base.set_state(2683);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 QUOTE_OPEN 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule lineStringLiteral*/
					recog.base.set_state(2681);
					recog.lineStringLiteral()?;

					}
				}

			 TRIPLE_QUOTE_OPEN 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule multiLineStringLiteral*/
					recog.base.set_state(2682);
					recog.multiLineStringLiteral()?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- lineStringLiteral ----------------
pub type LineStringLiteralContextAll<'input> = LineStringLiteralContext<'input>;


pub type LineStringLiteralContext<'input> = BaseParserRuleContext<'input,LineStringLiteralContextExt<'input>>;

#[derive(Clone)]
pub struct LineStringLiteralContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for LineStringLiteralContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for LineStringLiteralContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_lineStringLiteral(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_lineStringLiteral(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for LineStringLiteralContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_lineStringLiteral(self);
	}
}

impl<'input> CustomRuleContext<'input> for LineStringLiteralContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_lineStringLiteral }
	//fn type_rule_index() -> usize where Self: Sized { RULE_lineStringLiteral }
}
antlr_rust::type_id!{LineStringLiteralContextExt<'a>}

impl<'input> LineStringLiteralContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<LineStringLiteralContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,LineStringLiteralContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait LineStringLiteralContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<LineStringLiteralContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token QUOTE_OPEN
/// Returns `None` if there is no child corresponding to token QUOTE_OPEN
fn QUOTE_OPEN(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(QUOTE_OPEN, 0)
}
/// Retrieves first TerminalNode corresponding to token QUOTE_CLOSE
/// Returns `None` if there is no child corresponding to token QUOTE_CLOSE
fn QUOTE_CLOSE(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(QUOTE_CLOSE, 0)
}
fn lineStringContent_all(&self) ->  Vec<Rc<LineStringContentContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn lineStringContent(&self, i: usize) -> Option<Rc<LineStringContentContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn lineStringExpression_all(&self) ->  Vec<Rc<LineStringExpressionContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn lineStringExpression(&self, i: usize) -> Option<Rc<LineStringExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> LineStringLiteralContextAttrs<'input> for LineStringLiteralContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn lineStringLiteral(&mut self,)
	-> Result<Rc<LineStringLiteralContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = LineStringLiteralContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 222, RULE_lineStringLiteral);
        let mut _localctx: Rc<LineStringLiteralContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2685);
			recog.base.match_token(QUOTE_OPEN,&mut recog.err_handler)?;

			recog.base.set_state(2690);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while ((((_la - 161)) & !0x3f) == 0 && ((1usize << (_la - 161)) & ((1usize << (LineStrRef - 161)) | (1usize << (LineStrText - 161)) | (1usize << (LineStrEscapedChar - 161)) | (1usize << (LineStrExprStart - 161)))) != 0) {
				{
				recog.base.set_state(2688);
				recog.err_handler.sync(&mut recog.base)?;
				match recog.base.input.la(1) {
				 LineStrRef | LineStrText | LineStrEscapedChar 
					=> {
						{
						/*InvokeRule lineStringContent*/
						recog.base.set_state(2686);
						recog.lineStringContent()?;

						}
					}

				 LineStrExprStart 
					=> {
						{
						/*InvokeRule lineStringExpression*/
						recog.base.set_state(2687);
						recog.lineStringExpression()?;

						}
					}

					_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
				}
				}
				recog.base.set_state(2692);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(2693);
			recog.base.match_token(QUOTE_CLOSE,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- multiLineStringLiteral ----------------
pub type MultiLineStringLiteralContextAll<'input> = MultiLineStringLiteralContext<'input>;


pub type MultiLineStringLiteralContext<'input> = BaseParserRuleContext<'input,MultiLineStringLiteralContextExt<'input>>;

#[derive(Clone)]
pub struct MultiLineStringLiteralContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for MultiLineStringLiteralContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for MultiLineStringLiteralContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_multiLineStringLiteral(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_multiLineStringLiteral(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for MultiLineStringLiteralContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_multiLineStringLiteral(self);
	}
}

impl<'input> CustomRuleContext<'input> for MultiLineStringLiteralContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_multiLineStringLiteral }
	//fn type_rule_index() -> usize where Self: Sized { RULE_multiLineStringLiteral }
}
antlr_rust::type_id!{MultiLineStringLiteralContextExt<'a>}

impl<'input> MultiLineStringLiteralContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<MultiLineStringLiteralContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,MultiLineStringLiteralContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait MultiLineStringLiteralContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<MultiLineStringLiteralContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token TRIPLE_QUOTE_OPEN
/// Returns `None` if there is no child corresponding to token TRIPLE_QUOTE_OPEN
fn TRIPLE_QUOTE_OPEN(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(TRIPLE_QUOTE_OPEN, 0)
}
/// Retrieves first TerminalNode corresponding to token TRIPLE_QUOTE_CLOSE
/// Returns `None` if there is no child corresponding to token TRIPLE_QUOTE_CLOSE
fn TRIPLE_QUOTE_CLOSE(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(TRIPLE_QUOTE_CLOSE, 0)
}
fn multiLineStringContent_all(&self) ->  Vec<Rc<MultiLineStringContentContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn multiLineStringContent(&self, i: usize) -> Option<Rc<MultiLineStringContentContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn multiLineStringExpression_all(&self) ->  Vec<Rc<MultiLineStringExpressionContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn multiLineStringExpression(&self, i: usize) -> Option<Rc<MultiLineStringExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token MultiLineStringQuote in current rule
fn MultiLineStringQuote_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token MultiLineStringQuote, starting from 0.
/// Returns `None` if number of children corresponding to token MultiLineStringQuote is less or equal than `i`.
fn MultiLineStringQuote(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(MultiLineStringQuote, i)
}

}

impl<'input> MultiLineStringLiteralContextAttrs<'input> for MultiLineStringLiteralContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn multiLineStringLiteral(&mut self,)
	-> Result<Rc<MultiLineStringLiteralContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = MultiLineStringLiteralContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 224, RULE_multiLineStringLiteral);
        let mut _localctx: Rc<MultiLineStringLiteralContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2695);
			recog.base.match_token(TRIPLE_QUOTE_OPEN,&mut recog.err_handler)?;

			recog.base.set_state(2701);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while ((((_la - 166)) & !0x3f) == 0 && ((1usize << (_la - 166)) & ((1usize << (MultiLineStringQuote - 166)) | (1usize << (MultiLineStrRef - 166)) | (1usize << (MultiLineStrText - 166)) | (1usize << (MultiLineStrExprStart - 166)))) != 0) {
				{
				recog.base.set_state(2699);
				recog.err_handler.sync(&mut recog.base)?;
				match  recog.interpreter.adaptive_predict(407,&mut recog.base)? {
					1 =>{
						{
						/*InvokeRule multiLineStringContent*/
						recog.base.set_state(2696);
						recog.multiLineStringContent()?;

						}
					}
				,
					2 =>{
						{
						/*InvokeRule multiLineStringExpression*/
						recog.base.set_state(2697);
						recog.multiLineStringExpression()?;

						}
					}
				,
					3 =>{
						{
						recog.base.set_state(2698);
						recog.base.match_token(MultiLineStringQuote,&mut recog.err_handler)?;

						}
					}

					_ => {}
				}
				}
				recog.base.set_state(2703);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(2704);
			recog.base.match_token(TRIPLE_QUOTE_CLOSE,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- lineStringContent ----------------
pub type LineStringContentContextAll<'input> = LineStringContentContext<'input>;


pub type LineStringContentContext<'input> = BaseParserRuleContext<'input,LineStringContentContextExt<'input>>;

#[derive(Clone)]
pub struct LineStringContentContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for LineStringContentContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for LineStringContentContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_lineStringContent(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_lineStringContent(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for LineStringContentContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_lineStringContent(self);
	}
}

impl<'input> CustomRuleContext<'input> for LineStringContentContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_lineStringContent }
	//fn type_rule_index() -> usize where Self: Sized { RULE_lineStringContent }
}
antlr_rust::type_id!{LineStringContentContextExt<'a>}

impl<'input> LineStringContentContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<LineStringContentContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,LineStringContentContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait LineStringContentContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<LineStringContentContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token LineStrText
/// Returns `None` if there is no child corresponding to token LineStrText
fn LineStrText(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(LineStrText, 0)
}
/// Retrieves first TerminalNode corresponding to token LineStrEscapedChar
/// Returns `None` if there is no child corresponding to token LineStrEscapedChar
fn LineStrEscapedChar(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(LineStrEscapedChar, 0)
}
/// Retrieves first TerminalNode corresponding to token LineStrRef
/// Returns `None` if there is no child corresponding to token LineStrRef
fn LineStrRef(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(LineStrRef, 0)
}

}

impl<'input> LineStringContentContextAttrs<'input> for LineStringContentContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn lineStringContent(&mut self,)
	-> Result<Rc<LineStringContentContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = LineStringContentContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 226, RULE_lineStringContent);
        let mut _localctx: Rc<LineStringContentContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2706);
			_la = recog.base.input.la(1);
			if { !(((((_la - 161)) & !0x3f) == 0 && ((1usize << (_la - 161)) & ((1usize << (LineStrRef - 161)) | (1usize << (LineStrText - 161)) | (1usize << (LineStrEscapedChar - 161)))) != 0)) } {
				recog.err_handler.recover_inline(&mut recog.base)?;

			}
			else {
				if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
				recog.err_handler.report_match(&mut recog.base);
				recog.base.consume(&mut recog.err_handler);
			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- lineStringExpression ----------------
pub type LineStringExpressionContextAll<'input> = LineStringExpressionContext<'input>;


pub type LineStringExpressionContext<'input> = BaseParserRuleContext<'input,LineStringExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct LineStringExpressionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for LineStringExpressionContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for LineStringExpressionContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_lineStringExpression(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_lineStringExpression(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for LineStringExpressionContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_lineStringExpression(self);
	}
}

impl<'input> CustomRuleContext<'input> for LineStringExpressionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_lineStringExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_lineStringExpression }
}
antlr_rust::type_id!{LineStringExpressionContextExt<'a>}

impl<'input> LineStringExpressionContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<LineStringExpressionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,LineStringExpressionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait LineStringExpressionContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<LineStringExpressionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token LineStrExprStart
/// Returns `None` if there is no child corresponding to token LineStrExprStart
fn LineStrExprStart(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(LineStrExprStart, 0)
}
fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token RCURL
/// Returns `None` if there is no child corresponding to token RCURL
fn RCURL(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(RCURL, 0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}

}

impl<'input> LineStringExpressionContextAttrs<'input> for LineStringExpressionContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn lineStringExpression(&mut self,)
	-> Result<Rc<LineStringExpressionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = LineStringExpressionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 228, RULE_lineStringExpression);
        let mut _localctx: Rc<LineStringExpressionContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2708);
			recog.base.match_token(LineStrExprStart,&mut recog.err_handler)?;

			recog.base.set_state(2712);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(409,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					recog.base.set_state(2709);
					recog.base.match_token(NL,&mut recog.err_handler)?;

					}
					} 
				}
				recog.base.set_state(2714);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(409,&mut recog.base)?;
			}
			/*InvokeRule expression*/
			recog.base.set_state(2715);
			recog.expression()?;

			recog.base.set_state(2719);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(2716);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(2721);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(2722);
			recog.base.match_token(RCURL,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- multiLineStringContent ----------------
pub type MultiLineStringContentContextAll<'input> = MultiLineStringContentContext<'input>;


pub type MultiLineStringContentContext<'input> = BaseParserRuleContext<'input,MultiLineStringContentContextExt<'input>>;

#[derive(Clone)]
pub struct MultiLineStringContentContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for MultiLineStringContentContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for MultiLineStringContentContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_multiLineStringContent(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_multiLineStringContent(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for MultiLineStringContentContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_multiLineStringContent(self);
	}
}

impl<'input> CustomRuleContext<'input> for MultiLineStringContentContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_multiLineStringContent }
	//fn type_rule_index() -> usize where Self: Sized { RULE_multiLineStringContent }
}
antlr_rust::type_id!{MultiLineStringContentContextExt<'a>}

impl<'input> MultiLineStringContentContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<MultiLineStringContentContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,MultiLineStringContentContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait MultiLineStringContentContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<MultiLineStringContentContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token MultiLineStrText
/// Returns `None` if there is no child corresponding to token MultiLineStrText
fn MultiLineStrText(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(MultiLineStrText, 0)
}
/// Retrieves first TerminalNode corresponding to token MultiLineStringQuote
/// Returns `None` if there is no child corresponding to token MultiLineStringQuote
fn MultiLineStringQuote(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(MultiLineStringQuote, 0)
}
/// Retrieves first TerminalNode corresponding to token MultiLineStrRef
/// Returns `None` if there is no child corresponding to token MultiLineStrRef
fn MultiLineStrRef(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(MultiLineStrRef, 0)
}

}

impl<'input> MultiLineStringContentContextAttrs<'input> for MultiLineStringContentContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn multiLineStringContent(&mut self,)
	-> Result<Rc<MultiLineStringContentContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = MultiLineStringContentContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 230, RULE_multiLineStringContent);
        let mut _localctx: Rc<MultiLineStringContentContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2724);
			_la = recog.base.input.la(1);
			if { !(((((_la - 166)) & !0x3f) == 0 && ((1usize << (_la - 166)) & ((1usize << (MultiLineStringQuote - 166)) | (1usize << (MultiLineStrRef - 166)) | (1usize << (MultiLineStrText - 166)))) != 0)) } {
				recog.err_handler.recover_inline(&mut recog.base)?;

			}
			else {
				if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
				recog.err_handler.report_match(&mut recog.base);
				recog.base.consume(&mut recog.err_handler);
			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- multiLineStringExpression ----------------
pub type MultiLineStringExpressionContextAll<'input> = MultiLineStringExpressionContext<'input>;


pub type MultiLineStringExpressionContext<'input> = BaseParserRuleContext<'input,MultiLineStringExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct MultiLineStringExpressionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for MultiLineStringExpressionContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for MultiLineStringExpressionContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_multiLineStringExpression(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_multiLineStringExpression(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for MultiLineStringExpressionContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_multiLineStringExpression(self);
	}
}

impl<'input> CustomRuleContext<'input> for MultiLineStringExpressionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_multiLineStringExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_multiLineStringExpression }
}
antlr_rust::type_id!{MultiLineStringExpressionContextExt<'a>}

impl<'input> MultiLineStringExpressionContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<MultiLineStringExpressionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,MultiLineStringExpressionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait MultiLineStringExpressionContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<MultiLineStringExpressionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token MultiLineStrExprStart
/// Returns `None` if there is no child corresponding to token MultiLineStrExprStart
fn MultiLineStrExprStart(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(MultiLineStrExprStart, 0)
}
fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token RCURL
/// Returns `None` if there is no child corresponding to token RCURL
fn RCURL(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(RCURL, 0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}

}

impl<'input> MultiLineStringExpressionContextAttrs<'input> for MultiLineStringExpressionContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn multiLineStringExpression(&mut self,)
	-> Result<Rc<MultiLineStringExpressionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = MultiLineStringExpressionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 232, RULE_multiLineStringExpression);
        let mut _localctx: Rc<MultiLineStringExpressionContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2726);
			recog.base.match_token(MultiLineStrExprStart,&mut recog.err_handler)?;

			recog.base.set_state(2730);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(411,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					recog.base.set_state(2727);
					recog.base.match_token(NL,&mut recog.err_handler)?;

					}
					} 
				}
				recog.base.set_state(2732);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(411,&mut recog.base)?;
			}
			/*InvokeRule expression*/
			recog.base.set_state(2733);
			recog.expression()?;

			recog.base.set_state(2737);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(2734);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(2739);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(2740);
			recog.base.match_token(RCURL,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- lambdaLiteral ----------------
pub type LambdaLiteralContextAll<'input> = LambdaLiteralContext<'input>;


pub type LambdaLiteralContext<'input> = BaseParserRuleContext<'input,LambdaLiteralContextExt<'input>>;

#[derive(Clone)]
pub struct LambdaLiteralContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for LambdaLiteralContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for LambdaLiteralContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_lambdaLiteral(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_lambdaLiteral(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for LambdaLiteralContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_lambdaLiteral(self);
	}
}

impl<'input> CustomRuleContext<'input> for LambdaLiteralContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_lambdaLiteral }
	//fn type_rule_index() -> usize where Self: Sized { RULE_lambdaLiteral }
}
antlr_rust::type_id!{LambdaLiteralContextExt<'a>}

impl<'input> LambdaLiteralContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<LambdaLiteralContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,LambdaLiteralContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait LambdaLiteralContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<LambdaLiteralContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token LCURL
/// Returns `None` if there is no child corresponding to token LCURL
fn LCURL(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(LCURL, 0)
}
fn statements(&self) -> Option<Rc<StatementsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token RCURL
/// Returns `None` if there is no child corresponding to token RCURL
fn RCURL(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(RCURL, 0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}
/// Retrieves first TerminalNode corresponding to token ARROW
/// Returns `None` if there is no child corresponding to token ARROW
fn ARROW(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(ARROW, 0)
}
fn lambdaParameters(&self) -> Option<Rc<LambdaParametersContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> LambdaLiteralContextAttrs<'input> for LambdaLiteralContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn lambdaLiteral(&mut self,)
	-> Result<Rc<LambdaLiteralContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = LambdaLiteralContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 234, RULE_lambdaLiteral);
        let mut _localctx: Rc<LambdaLiteralContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2742);
			recog.base.match_token(LCURL,&mut recog.err_handler)?;

			recog.base.set_state(2746);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(413,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					recog.base.set_state(2743);
					recog.base.match_token(NL,&mut recog.err_handler)?;

					}
					} 
				}
				recog.base.set_state(2748);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(413,&mut recog.base)?;
			}
			recog.base.set_state(2765);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(417,&mut recog.base)? {
				x if x == 1=>{
					{
					recog.base.set_state(2750);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(414,&mut recog.base)? {
						x if x == 1=>{
							{
							/*InvokeRule lambdaParameters*/
							recog.base.set_state(2749);
							recog.lambdaParameters()?;

							}
						}

						_ => {}
					}
					recog.base.set_state(2755);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(2752);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(2757);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(2758);
					recog.base.match_token(ARROW,&mut recog.err_handler)?;

					recog.base.set_state(2762);
					recog.err_handler.sync(&mut recog.base)?;
					_alt = recog.interpreter.adaptive_predict(416,&mut recog.base)?;
					while { _alt!=2 && _alt!=INVALID_ALT } {
						if _alt==1 {
							{
							{
							recog.base.set_state(2759);
							recog.base.match_token(NL,&mut recog.err_handler)?;

							}
							} 
						}
						recog.base.set_state(2764);
						recog.err_handler.sync(&mut recog.base)?;
						_alt = recog.interpreter.adaptive_predict(416,&mut recog.base)?;
					}
					}
				}

				_ => {}
			}
			/*InvokeRule statements*/
			recog.base.set_state(2767);
			recog.statements()?;

			recog.base.set_state(2771);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(2768);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(2773);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(2774);
			recog.base.match_token(RCURL,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- lambdaParameters ----------------
pub type LambdaParametersContextAll<'input> = LambdaParametersContext<'input>;


pub type LambdaParametersContext<'input> = BaseParserRuleContext<'input,LambdaParametersContextExt<'input>>;

#[derive(Clone)]
pub struct LambdaParametersContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for LambdaParametersContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for LambdaParametersContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_lambdaParameters(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_lambdaParameters(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for LambdaParametersContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_lambdaParameters(self);
	}
}

impl<'input> CustomRuleContext<'input> for LambdaParametersContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_lambdaParameters }
	//fn type_rule_index() -> usize where Self: Sized { RULE_lambdaParameters }
}
antlr_rust::type_id!{LambdaParametersContextExt<'a>}

impl<'input> LambdaParametersContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<LambdaParametersContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,LambdaParametersContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait LambdaParametersContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<LambdaParametersContextExt<'input>>{

fn lambdaParameter_all(&self) ->  Vec<Rc<LambdaParameterContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn lambdaParameter(&self, i: usize) -> Option<Rc<LambdaParameterContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}

}

impl<'input> LambdaParametersContextAttrs<'input> for LambdaParametersContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn lambdaParameters(&mut self,)
	-> Result<Rc<LambdaParametersContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = LambdaParametersContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 236, RULE_lambdaParameters);
        let mut _localctx: Rc<LambdaParametersContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule lambdaParameter*/
			recog.base.set_state(2776);
			recog.lambdaParameter()?;

			recog.base.set_state(2793);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(421,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					recog.base.set_state(2780);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(2777);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(2782);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(2783);
					recog.base.match_token(COMMA,&mut recog.err_handler)?;

					recog.base.set_state(2787);
					recog.err_handler.sync(&mut recog.base)?;
					_alt = recog.interpreter.adaptive_predict(420,&mut recog.base)?;
					while { _alt!=2 && _alt!=INVALID_ALT } {
						if _alt==1 {
							{
							{
							recog.base.set_state(2784);
							recog.base.match_token(NL,&mut recog.err_handler)?;

							}
							} 
						}
						recog.base.set_state(2789);
						recog.err_handler.sync(&mut recog.base)?;
						_alt = recog.interpreter.adaptive_predict(420,&mut recog.base)?;
					}
					/*InvokeRule lambdaParameter*/
					recog.base.set_state(2790);
					recog.lambdaParameter()?;

					}
					} 
				}
				recog.base.set_state(2795);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(421,&mut recog.base)?;
			}
			recog.base.set_state(2803);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(423,&mut recog.base)? {
				x if x == 1=>{
					{
					recog.base.set_state(2799);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(2796);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(2801);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(2802);
					recog.base.match_token(COMMA,&mut recog.err_handler)?;

					}
				}

				_ => {}
			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- lambdaParameter ----------------
pub type LambdaParameterContextAll<'input> = LambdaParameterContext<'input>;


pub type LambdaParameterContext<'input> = BaseParserRuleContext<'input,LambdaParameterContextExt<'input>>;

#[derive(Clone)]
pub struct LambdaParameterContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for LambdaParameterContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for LambdaParameterContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_lambdaParameter(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_lambdaParameter(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for LambdaParameterContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_lambdaParameter(self);
	}
}

impl<'input> CustomRuleContext<'input> for LambdaParameterContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_lambdaParameter }
	//fn type_rule_index() -> usize where Self: Sized { RULE_lambdaParameter }
}
antlr_rust::type_id!{LambdaParameterContextExt<'a>}

impl<'input> LambdaParameterContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<LambdaParameterContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,LambdaParameterContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait LambdaParameterContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<LambdaParameterContextExt<'input>>{

fn variableDeclaration(&self) -> Option<Rc<VariableDeclarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn multiVariableDeclaration(&self) -> Option<Rc<MultiVariableDeclarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COLON
/// Returns `None` if there is no child corresponding to token COLON
fn COLON(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(COLON, 0)
}
fn type(&self) -> Option<Rc<TypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}

}

impl<'input> LambdaParameterContextAttrs<'input> for LambdaParameterContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn lambdaParameter(&mut self,)
	-> Result<Rc<LambdaParameterContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = LambdaParameterContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 238, RULE_lambdaParameter);
        let mut _localctx: Rc<LambdaParameterContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			recog.base.set_state(2823);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 NL | AT_NO_WS | AT_PRE_WS | FILE | FIELD | PROPERTY | GET | SET | RECEIVER |
			 PARAM | SETPARAM | DELEGATE | IMPORT | CONSTRUCTOR | BY | COMPANION |
			 INIT | WHERE | CATCH | FINALLY | OUT | DYNAMIC | PUBLIC | PRIVATE | PROTECTED |
			 INTERNAL | ENUM | SEALED | ANNOTATION | DATA | INNER | VALUE | TAILREC |
			 OPERATOR | INLINE | INFIX | EXTERNAL | SUSPEND | OVERRIDE | ABSTRACT |
			 FINAL | OPEN | CONST | LATEINIT | VARARG | NOINLINE | CROSSINLINE | REIFIED |
			 EXPECT | ACTUAL | Identifier 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule variableDeclaration*/
					recog.base.set_state(2805);
					recog.variableDeclaration()?;

					}
				}

			 LPAREN 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule multiVariableDeclaration*/
					recog.base.set_state(2806);
					recog.multiVariableDeclaration()?;

					recog.base.set_state(2821);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(426,&mut recog.base)? {
						x if x == 1=>{
							{
							recog.base.set_state(2810);
							recog.err_handler.sync(&mut recog.base)?;
							_la = recog.base.input.la(1);
							while _la==NL {
								{
								{
								recog.base.set_state(2807);
								recog.base.match_token(NL,&mut recog.err_handler)?;

								}
								}
								recog.base.set_state(2812);
								recog.err_handler.sync(&mut recog.base)?;
								_la = recog.base.input.la(1);
							}
							recog.base.set_state(2813);
							recog.base.match_token(COLON,&mut recog.err_handler)?;

							recog.base.set_state(2817);
							recog.err_handler.sync(&mut recog.base)?;
							_la = recog.base.input.la(1);
							while _la==NL {
								{
								{
								recog.base.set_state(2814);
								recog.base.match_token(NL,&mut recog.err_handler)?;

								}
								}
								recog.base.set_state(2819);
								recog.err_handler.sync(&mut recog.base)?;
								_la = recog.base.input.la(1);
							}
							/*InvokeRule type*/
							recog.base.set_state(2820);
							recog.type()?;

							}
						}

						_ => {}
					}
					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- anonymousFunction ----------------
pub type AnonymousFunctionContextAll<'input> = AnonymousFunctionContext<'input>;


pub type AnonymousFunctionContext<'input> = BaseParserRuleContext<'input,AnonymousFunctionContextExt<'input>>;

#[derive(Clone)]
pub struct AnonymousFunctionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for AnonymousFunctionContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for AnonymousFunctionContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_anonymousFunction(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_anonymousFunction(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for AnonymousFunctionContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_anonymousFunction(self);
	}
}

impl<'input> CustomRuleContext<'input> for AnonymousFunctionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_anonymousFunction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_anonymousFunction }
}
antlr_rust::type_id!{AnonymousFunctionContextExt<'a>}

impl<'input> AnonymousFunctionContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AnonymousFunctionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AnonymousFunctionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AnonymousFunctionContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<AnonymousFunctionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token FUN
/// Returns `None` if there is no child corresponding to token FUN
fn FUN(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(FUN, 0)
}
fn parametersWithOptionalType(&self) -> Option<Rc<ParametersWithOptionalTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token SUSPEND
/// Returns `None` if there is no child corresponding to token SUSPEND
fn SUSPEND(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(SUSPEND, 0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}
fn type_all(&self) ->  Vec<Rc<TypeContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn type(&self, i: usize) -> Option<Rc<TypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves first TerminalNode corresponding to token DOT
/// Returns `None` if there is no child corresponding to token DOT
fn DOT(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(DOT, 0)
}
/// Retrieves first TerminalNode corresponding to token COLON
/// Returns `None` if there is no child corresponding to token COLON
fn COLON(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(COLON, 0)
}
fn typeConstraints(&self) -> Option<Rc<TypeConstraintsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn functionBody(&self) -> Option<Rc<FunctionBodyContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> AnonymousFunctionContextAttrs<'input> for AnonymousFunctionContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn anonymousFunction(&mut self,)
	-> Result<Rc<AnonymousFunctionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AnonymousFunctionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 240, RULE_anonymousFunction);
        let mut _localctx: Rc<AnonymousFunctionContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2826);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==SUSPEND {
				{
				recog.base.set_state(2825);
				recog.base.match_token(SUSPEND,&mut recog.err_handler)?;

				}
			}

			recog.base.set_state(2831);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(2828);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(2833);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(2834);
			recog.base.match_token(FUN,&mut recog.err_handler)?;

			recog.base.set_state(2850);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(432,&mut recog.base)? {
				x if x == 1=>{
					{
					recog.base.set_state(2838);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(2835);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(2840);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					/*InvokeRule type*/
					recog.base.set_state(2841);
					recog.type()?;

					recog.base.set_state(2845);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(2842);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(2847);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(2848);
					recog.base.match_token(DOT,&mut recog.err_handler)?;

					}
				}

				_ => {}
			}
			recog.base.set_state(2855);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(2852);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(2857);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			/*InvokeRule parametersWithOptionalType*/
			recog.base.set_state(2858);
			recog.parametersWithOptionalType()?;

			recog.base.set_state(2873);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(436,&mut recog.base)? {
				x if x == 1=>{
					{
					recog.base.set_state(2862);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(2859);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(2864);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(2865);
					recog.base.match_token(COLON,&mut recog.err_handler)?;

					recog.base.set_state(2869);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(2866);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(2871);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					/*InvokeRule type*/
					recog.base.set_state(2872);
					recog.type()?;

					}
				}

				_ => {}
			}
			recog.base.set_state(2882);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(438,&mut recog.base)? {
				x if x == 1=>{
					{
					recog.base.set_state(2878);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(2875);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(2880);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					/*InvokeRule typeConstraints*/
					recog.base.set_state(2881);
					recog.typeConstraints()?;

					}
				}

				_ => {}
			}
			recog.base.set_state(2891);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(440,&mut recog.base)? {
				x if x == 1=>{
					{
					recog.base.set_state(2887);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(2884);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(2889);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					/*InvokeRule functionBody*/
					recog.base.set_state(2890);
					recog.functionBody()?;

					}
				}

				_ => {}
			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- functionLiteral ----------------
pub type FunctionLiteralContextAll<'input> = FunctionLiteralContext<'input>;


pub type FunctionLiteralContext<'input> = BaseParserRuleContext<'input,FunctionLiteralContextExt<'input>>;

#[derive(Clone)]
pub struct FunctionLiteralContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for FunctionLiteralContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for FunctionLiteralContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_functionLiteral(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_functionLiteral(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for FunctionLiteralContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_functionLiteral(self);
	}
}

impl<'input> CustomRuleContext<'input> for FunctionLiteralContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_functionLiteral }
	//fn type_rule_index() -> usize where Self: Sized { RULE_functionLiteral }
}
antlr_rust::type_id!{FunctionLiteralContextExt<'a>}

impl<'input> FunctionLiteralContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<FunctionLiteralContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,FunctionLiteralContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait FunctionLiteralContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<FunctionLiteralContextExt<'input>>{

fn lambdaLiteral(&self) -> Option<Rc<LambdaLiteralContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn anonymousFunction(&self) -> Option<Rc<AnonymousFunctionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> FunctionLiteralContextAttrs<'input> for FunctionLiteralContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn functionLiteral(&mut self,)
	-> Result<Rc<FunctionLiteralContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = FunctionLiteralContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 242, RULE_functionLiteral);
        let mut _localctx: Rc<FunctionLiteralContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			recog.base.set_state(2895);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 LCURL 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule lambdaLiteral*/
					recog.base.set_state(2893);
					recog.lambdaLiteral()?;

					}
				}

			 NL | FUN | SUSPEND 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule anonymousFunction*/
					recog.base.set_state(2894);
					recog.anonymousFunction()?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- objectLiteral ----------------
pub type ObjectLiteralContextAll<'input> = ObjectLiteralContext<'input>;


pub type ObjectLiteralContext<'input> = BaseParserRuleContext<'input,ObjectLiteralContextExt<'input>>;

#[derive(Clone)]
pub struct ObjectLiteralContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for ObjectLiteralContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for ObjectLiteralContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_objectLiteral(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_objectLiteral(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for ObjectLiteralContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_objectLiteral(self);
	}
}

impl<'input> CustomRuleContext<'input> for ObjectLiteralContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_objectLiteral }
	//fn type_rule_index() -> usize where Self: Sized { RULE_objectLiteral }
}
antlr_rust::type_id!{ObjectLiteralContextExt<'a>}

impl<'input> ObjectLiteralContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ObjectLiteralContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ObjectLiteralContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ObjectLiteralContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<ObjectLiteralContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OBJECT
/// Returns `None` if there is no child corresponding to token OBJECT
fn OBJECT(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(OBJECT, 0)
}
/// Retrieves first TerminalNode corresponding to token DATA
/// Returns `None` if there is no child corresponding to token DATA
fn DATA(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(DATA, 0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}
/// Retrieves first TerminalNode corresponding to token COLON
/// Returns `None` if there is no child corresponding to token COLON
fn COLON(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(COLON, 0)
}
fn delegationSpecifiers(&self) -> Option<Rc<DelegationSpecifiersContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn classBody(&self) -> Option<Rc<ClassBodyContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ObjectLiteralContextAttrs<'input> for ObjectLiteralContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn objectLiteral(&mut self,)
	-> Result<Rc<ObjectLiteralContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ObjectLiteralContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 244, RULE_objectLiteral);
        let mut _localctx: Rc<ObjectLiteralContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2898);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==DATA {
				{
				recog.base.set_state(2897);
				recog.base.match_token(DATA,&mut recog.err_handler)?;

				}
			}

			recog.base.set_state(2903);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(2900);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(2905);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(2906);
			recog.base.match_token(OBJECT,&mut recog.err_handler)?;

			recog.base.set_state(2927);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(447,&mut recog.base)? {
				x if x == 1=>{
					{
					recog.base.set_state(2910);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(2907);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(2912);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(2913);
					recog.base.match_token(COLON,&mut recog.err_handler)?;

					recog.base.set_state(2917);
					recog.err_handler.sync(&mut recog.base)?;
					_alt = recog.interpreter.adaptive_predict(445,&mut recog.base)?;
					while { _alt!=2 && _alt!=INVALID_ALT } {
						if _alt==1 {
							{
							{
							recog.base.set_state(2914);
							recog.base.match_token(NL,&mut recog.err_handler)?;

							}
							} 
						}
						recog.base.set_state(2919);
						recog.err_handler.sync(&mut recog.base)?;
						_alt = recog.interpreter.adaptive_predict(445,&mut recog.base)?;
					}
					/*InvokeRule delegationSpecifiers*/
					recog.base.set_state(2920);
					recog.delegationSpecifiers()?;

					recog.base.set_state(2924);
					recog.err_handler.sync(&mut recog.base)?;
					_alt = recog.interpreter.adaptive_predict(446,&mut recog.base)?;
					while { _alt!=2 && _alt!=INVALID_ALT } {
						if _alt==1 {
							{
							{
							recog.base.set_state(2921);
							recog.base.match_token(NL,&mut recog.err_handler)?;

							}
							} 
						}
						recog.base.set_state(2926);
						recog.err_handler.sync(&mut recog.base)?;
						_alt = recog.interpreter.adaptive_predict(446,&mut recog.base)?;
					}
					}
				}

				_ => {}
			}
			recog.base.set_state(2936);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(449,&mut recog.base)? {
				x if x == 1=>{
					{
					recog.base.set_state(2932);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(2929);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(2934);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					/*InvokeRule classBody*/
					recog.base.set_state(2935);
					recog.classBody()?;

					}
				}

				_ => {}
			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- thisExpression ----------------
pub type ThisExpressionContextAll<'input> = ThisExpressionContext<'input>;


pub type ThisExpressionContext<'input> = BaseParserRuleContext<'input,ThisExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct ThisExpressionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for ThisExpressionContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for ThisExpressionContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_thisExpression(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_thisExpression(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for ThisExpressionContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_thisExpression(self);
	}
}

impl<'input> CustomRuleContext<'input> for ThisExpressionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_thisExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_thisExpression }
}
antlr_rust::type_id!{ThisExpressionContextExt<'a>}

impl<'input> ThisExpressionContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ThisExpressionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ThisExpressionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ThisExpressionContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<ThisExpressionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token THIS
/// Returns `None` if there is no child corresponding to token THIS
fn THIS(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(THIS, 0)
}
/// Retrieves first TerminalNode corresponding to token THIS_AT
/// Returns `None` if there is no child corresponding to token THIS_AT
fn THIS_AT(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(THIS_AT, 0)
}

}

impl<'input> ThisExpressionContextAttrs<'input> for ThisExpressionContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn thisExpression(&mut self,)
	-> Result<Rc<ThisExpressionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ThisExpressionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 246, RULE_thisExpression);
        let mut _localctx: Rc<ThisExpressionContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2938);
			_la = recog.base.input.la(1);
			if { !(_la==THIS_AT || _la==THIS) } {
				recog.err_handler.recover_inline(&mut recog.base)?;

			}
			else {
				if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
				recog.err_handler.report_match(&mut recog.base);
				recog.base.consume(&mut recog.err_handler);
			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- superExpression ----------------
pub type SuperExpressionContextAll<'input> = SuperExpressionContext<'input>;


pub type SuperExpressionContext<'input> = BaseParserRuleContext<'input,SuperExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct SuperExpressionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for SuperExpressionContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for SuperExpressionContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_superExpression(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_superExpression(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for SuperExpressionContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_superExpression(self);
	}
}

impl<'input> CustomRuleContext<'input> for SuperExpressionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_superExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_superExpression }
}
antlr_rust::type_id!{SuperExpressionContextExt<'a>}

impl<'input> SuperExpressionContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<SuperExpressionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,SuperExpressionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait SuperExpressionContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<SuperExpressionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token SUPER
/// Returns `None` if there is no child corresponding to token SUPER
fn SUPER(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(SUPER, 0)
}
/// Retrieves first TerminalNode corresponding to token LANGLE
/// Returns `None` if there is no child corresponding to token LANGLE
fn LANGLE(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(LANGLE, 0)
}
fn type(&self) -> Option<Rc<TypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token RANGLE
/// Returns `None` if there is no child corresponding to token RANGLE
fn RANGLE(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(RANGLE, 0)
}
/// Retrieves first TerminalNode corresponding to token AT_NO_WS
/// Returns `None` if there is no child corresponding to token AT_NO_WS
fn AT_NO_WS(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(AT_NO_WS, 0)
}
fn simpleIdentifier(&self) -> Option<Rc<SimpleIdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}
/// Retrieves first TerminalNode corresponding to token SUPER_AT
/// Returns `None` if there is no child corresponding to token SUPER_AT
fn SUPER_AT(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(SUPER_AT, 0)
}

}

impl<'input> SuperExpressionContextAttrs<'input> for SuperExpressionContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn superExpression(&mut self,)
	-> Result<Rc<SuperExpressionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = SuperExpressionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 248, RULE_superExpression);
        let mut _localctx: Rc<SuperExpressionContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			recog.base.set_state(2964);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 SUPER 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					recog.base.set_state(2940);
					recog.base.match_token(SUPER,&mut recog.err_handler)?;

					recog.base.set_state(2957);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(452,&mut recog.base)? {
						x if x == 1=>{
							{
							recog.base.set_state(2941);
							recog.base.match_token(LANGLE,&mut recog.err_handler)?;

							recog.base.set_state(2945);
							recog.err_handler.sync(&mut recog.base)?;
							_la = recog.base.input.la(1);
							while _la==NL {
								{
								{
								recog.base.set_state(2942);
								recog.base.match_token(NL,&mut recog.err_handler)?;

								}
								}
								recog.base.set_state(2947);
								recog.err_handler.sync(&mut recog.base)?;
								_la = recog.base.input.la(1);
							}
							/*InvokeRule type*/
							recog.base.set_state(2948);
							recog.type()?;

							recog.base.set_state(2952);
							recog.err_handler.sync(&mut recog.base)?;
							_la = recog.base.input.la(1);
							while _la==NL {
								{
								{
								recog.base.set_state(2949);
								recog.base.match_token(NL,&mut recog.err_handler)?;

								}
								}
								recog.base.set_state(2954);
								recog.err_handler.sync(&mut recog.base)?;
								_la = recog.base.input.la(1);
							}
							recog.base.set_state(2955);
							recog.base.match_token(RANGLE,&mut recog.err_handler)?;

							}
						}

						_ => {}
					}
					recog.base.set_state(2961);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(453,&mut recog.base)? {
						x if x == 1=>{
							{
							recog.base.set_state(2959);
							recog.base.match_token(AT_NO_WS,&mut recog.err_handler)?;

							/*InvokeRule simpleIdentifier*/
							recog.base.set_state(2960);
							recog.simpleIdentifier()?;

							}
						}

						_ => {}
					}
					}
				}

			 SUPER_AT 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(2963);
					recog.base.match_token(SUPER_AT,&mut recog.err_handler)?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- ifExpression ----------------
pub type IfExpressionContextAll<'input> = IfExpressionContext<'input>;


pub type IfExpressionContext<'input> = BaseParserRuleContext<'input,IfExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct IfExpressionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for IfExpressionContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for IfExpressionContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_ifExpression(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_ifExpression(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for IfExpressionContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_ifExpression(self);
	}
}

impl<'input> CustomRuleContext<'input> for IfExpressionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_ifExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_ifExpression }
}
antlr_rust::type_id!{IfExpressionContextExt<'a>}

impl<'input> IfExpressionContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<IfExpressionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,IfExpressionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait IfExpressionContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<IfExpressionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token IF
/// Returns `None` if there is no child corresponding to token IF
fn IF(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(IF, 0)
}
/// Retrieves first TerminalNode corresponding to token LPAREN
/// Returns `None` if there is no child corresponding to token LPAREN
fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(LPAREN, 0)
}
fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token RPAREN
/// Returns `None` if there is no child corresponding to token RPAREN
fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(RPAREN, 0)
}
fn controlStructureBody_all(&self) ->  Vec<Rc<ControlStructureBodyContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn controlStructureBody(&self, i: usize) -> Option<Rc<ControlStructureBodyContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves first TerminalNode corresponding to token ELSE
/// Returns `None` if there is no child corresponding to token ELSE
fn ELSE(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(ELSE, 0)
}
/// Retrieves all `TerminalNode`s corresponding to token SEMICOLON in current rule
fn SEMICOLON_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token SEMICOLON, starting from 0.
/// Returns `None` if number of children corresponding to token SEMICOLON is less or equal than `i`.
fn SEMICOLON(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(SEMICOLON, i)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}

}

impl<'input> IfExpressionContextAttrs<'input> for IfExpressionContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn ifExpression(&mut self,)
	-> Result<Rc<IfExpressionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = IfExpressionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 250, RULE_ifExpression);
        let mut _localctx: Rc<IfExpressionContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2966);
			recog.base.match_token(IF,&mut recog.err_handler)?;

			recog.base.set_state(2970);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(2967);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(2972);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(2973);
			recog.base.match_token(LPAREN,&mut recog.err_handler)?;

			recog.base.set_state(2977);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(456,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					recog.base.set_state(2974);
					recog.base.match_token(NL,&mut recog.err_handler)?;

					}
					} 
				}
				recog.base.set_state(2979);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(456,&mut recog.base)?;
			}
			/*InvokeRule expression*/
			recog.base.set_state(2980);
			recog.expression()?;

			recog.base.set_state(2984);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(2981);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(2986);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(2987);
			recog.base.match_token(RPAREN,&mut recog.err_handler)?;

			recog.base.set_state(2991);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(458,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					recog.base.set_state(2988);
					recog.base.match_token(NL,&mut recog.err_handler)?;

					}
					} 
				}
				recog.base.set_state(2993);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(458,&mut recog.base)?;
			}
			recog.base.set_state(3025);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(465,&mut recog.base)? {
				1 =>{
					{
					/*InvokeRule controlStructureBody*/
					recog.base.set_state(2994);
					recog.controlStructureBody()?;

					}
				}
			,
				2 =>{
					{
					recog.base.set_state(2996);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(459,&mut recog.base)? {
						x if x == 1=>{
							{
							/*InvokeRule controlStructureBody*/
							recog.base.set_state(2995);
							recog.controlStructureBody()?;

							}
						}

						_ => {}
					}
					recog.base.set_state(3001);
					recog.err_handler.sync(&mut recog.base)?;
					_alt = recog.interpreter.adaptive_predict(460,&mut recog.base)?;
					while { _alt!=2 && _alt!=INVALID_ALT } {
						if _alt==1 {
							{
							{
							recog.base.set_state(2998);
							recog.base.match_token(NL,&mut recog.err_handler)?;

							}
							} 
						}
						recog.base.set_state(3003);
						recog.err_handler.sync(&mut recog.base)?;
						_alt = recog.interpreter.adaptive_predict(460,&mut recog.base)?;
					}
					recog.base.set_state(3005);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==SEMICOLON {
						{
						recog.base.set_state(3004);
						recog.base.match_token(SEMICOLON,&mut recog.err_handler)?;

						}
					}

					recog.base.set_state(3010);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(3007);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(3012);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(3013);
					recog.base.match_token(ELSE,&mut recog.err_handler)?;

					recog.base.set_state(3017);
					recog.err_handler.sync(&mut recog.base)?;
					_alt = recog.interpreter.adaptive_predict(463,&mut recog.base)?;
					while { _alt!=2 && _alt!=INVALID_ALT } {
						if _alt==1 {
							{
							{
							recog.base.set_state(3014);
							recog.base.match_token(NL,&mut recog.err_handler)?;

							}
							} 
						}
						recog.base.set_state(3019);
						recog.err_handler.sync(&mut recog.base)?;
						_alt = recog.interpreter.adaptive_predict(463,&mut recog.base)?;
					}
					recog.base.set_state(3022);
					recog.err_handler.sync(&mut recog.base)?;
					match recog.base.input.la(1) {
					 NL | LPAREN | LSQUARE | LCURL | ADD | SUB | INCR | DECR | EXCL_WS |
					 EXCL_NO_WS | COLONCOLON | AT_NO_WS | AT_PRE_WS | RETURN_AT | CONTINUE_AT |
					 BREAK_AT | THIS_AT | SUPER_AT | FILE | FIELD | PROPERTY | GET | SET |
					 RECEIVER | PARAM | SETPARAM | DELEGATE | IMPORT | CLASS | INTERFACE |
					 FUN | OBJECT | VAL | VAR | TYPE_ALIAS | CONSTRUCTOR | BY | COMPANION |
					 INIT | THIS | SUPER | WHERE | IF | WHEN | TRY | CATCH | FINALLY | FOR |
					 DO | WHILE | THROW | RETURN | CONTINUE | BREAK | OUT | DYNAMIC | PUBLIC |
					 PRIVATE | PROTECTED | INTERNAL | ENUM | SEALED | ANNOTATION | DATA |
					 INNER | VALUE | TAILREC | OPERATOR | INLINE | INFIX | EXTERNAL | SUSPEND |
					 OVERRIDE | ABSTRACT | FINAL | OPEN | CONST | LATEINIT | VARARG | NOINLINE |
					 CROSSINLINE | REIFIED | EXPECT | ACTUAL | RealLiteral | IntegerLiteral |
					 HexLiteral | BinLiteral | UnsignedLiteral | LongLiteral | BooleanLiteral |
					 NullLiteral | CharacterLiteral | Identifier | QUOTE_OPEN | TRIPLE_QUOTE_OPEN 
						=> {
							{
							/*InvokeRule controlStructureBody*/
							recog.base.set_state(3020);
							recog.controlStructureBody()?;

							}
						}

					 SEMICOLON 
						=> {
							{
							recog.base.set_state(3021);
							recog.base.match_token(SEMICOLON,&mut recog.err_handler)?;

							}
						}

						_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
					}
					}
				}
			,
				3 =>{
					{
					recog.base.set_state(3024);
					recog.base.match_token(SEMICOLON,&mut recog.err_handler)?;

					}
				}

				_ => {}
			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- whenSubject ----------------
pub type WhenSubjectContextAll<'input> = WhenSubjectContext<'input>;


pub type WhenSubjectContext<'input> = BaseParserRuleContext<'input,WhenSubjectContextExt<'input>>;

#[derive(Clone)]
pub struct WhenSubjectContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for WhenSubjectContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for WhenSubjectContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_whenSubject(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_whenSubject(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for WhenSubjectContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_whenSubject(self);
	}
}

impl<'input> CustomRuleContext<'input> for WhenSubjectContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_whenSubject }
	//fn type_rule_index() -> usize where Self: Sized { RULE_whenSubject }
}
antlr_rust::type_id!{WhenSubjectContextExt<'a>}

impl<'input> WhenSubjectContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<WhenSubjectContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,WhenSubjectContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait WhenSubjectContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<WhenSubjectContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token LPAREN
/// Returns `None` if there is no child corresponding to token LPAREN
fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(LPAREN, 0)
}
fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token RPAREN
/// Returns `None` if there is no child corresponding to token RPAREN
fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(RPAREN, 0)
}
/// Retrieves first TerminalNode corresponding to token VAL
/// Returns `None` if there is no child corresponding to token VAL
fn VAL(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(VAL, 0)
}
fn variableDeclaration(&self) -> Option<Rc<VariableDeclarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token ASSIGNMENT
/// Returns `None` if there is no child corresponding to token ASSIGNMENT
fn ASSIGNMENT(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(ASSIGNMENT, 0)
}
fn annotation_all(&self) ->  Vec<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}

}

impl<'input> WhenSubjectContextAttrs<'input> for WhenSubjectContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn whenSubject(&mut self,)
	-> Result<Rc<WhenSubjectContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = WhenSubjectContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 252, RULE_whenSubject);
        let mut _localctx: Rc<WhenSubjectContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(3027);
			recog.base.match_token(LPAREN,&mut recog.err_handler)?;

			recog.base.set_state(3061);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(471,&mut recog.base)? {
				x if x == 1=>{
					{
					recog.base.set_state(3031);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==AT_NO_WS || _la==AT_PRE_WS {
						{
						{
						/*InvokeRule annotation*/
						recog.base.set_state(3028);
						recog.annotation()?;

						}
						}
						recog.base.set_state(3033);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(3037);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(3034);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(3039);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(3040);
					recog.base.match_token(VAL,&mut recog.err_handler)?;

					recog.base.set_state(3044);
					recog.err_handler.sync(&mut recog.base)?;
					_alt = recog.interpreter.adaptive_predict(468,&mut recog.base)?;
					while { _alt!=2 && _alt!=INVALID_ALT } {
						if _alt==1 {
							{
							{
							recog.base.set_state(3041);
							recog.base.match_token(NL,&mut recog.err_handler)?;

							}
							} 
						}
						recog.base.set_state(3046);
						recog.err_handler.sync(&mut recog.base)?;
						_alt = recog.interpreter.adaptive_predict(468,&mut recog.base)?;
					}
					/*InvokeRule variableDeclaration*/
					recog.base.set_state(3047);
					recog.variableDeclaration()?;

					recog.base.set_state(3051);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(3048);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(3053);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(3054);
					recog.base.match_token(ASSIGNMENT,&mut recog.err_handler)?;

					recog.base.set_state(3058);
					recog.err_handler.sync(&mut recog.base)?;
					_alt = recog.interpreter.adaptive_predict(470,&mut recog.base)?;
					while { _alt!=2 && _alt!=INVALID_ALT } {
						if _alt==1 {
							{
							{
							recog.base.set_state(3055);
							recog.base.match_token(NL,&mut recog.err_handler)?;

							}
							} 
						}
						recog.base.set_state(3060);
						recog.err_handler.sync(&mut recog.base)?;
						_alt = recog.interpreter.adaptive_predict(470,&mut recog.base)?;
					}
					}
				}

				_ => {}
			}
			/*InvokeRule expression*/
			recog.base.set_state(3063);
			recog.expression()?;

			recog.base.set_state(3064);
			recog.base.match_token(RPAREN,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- whenExpression ----------------
pub type WhenExpressionContextAll<'input> = WhenExpressionContext<'input>;


pub type WhenExpressionContext<'input> = BaseParserRuleContext<'input,WhenExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct WhenExpressionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for WhenExpressionContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for WhenExpressionContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_whenExpression(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_whenExpression(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for WhenExpressionContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_whenExpression(self);
	}
}

impl<'input> CustomRuleContext<'input> for WhenExpressionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_whenExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_whenExpression }
}
antlr_rust::type_id!{WhenExpressionContextExt<'a>}

impl<'input> WhenExpressionContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<WhenExpressionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,WhenExpressionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait WhenExpressionContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<WhenExpressionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token WHEN
/// Returns `None` if there is no child corresponding to token WHEN
fn WHEN(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(WHEN, 0)
}
/// Retrieves first TerminalNode corresponding to token LCURL
/// Returns `None` if there is no child corresponding to token LCURL
fn LCURL(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(LCURL, 0)
}
/// Retrieves first TerminalNode corresponding to token RCURL
/// Returns `None` if there is no child corresponding to token RCURL
fn RCURL(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(RCURL, 0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}
fn whenSubject(&self) -> Option<Rc<WhenSubjectContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn whenEntry_all(&self) ->  Vec<Rc<WhenEntryContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn whenEntry(&self, i: usize) -> Option<Rc<WhenEntryContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> WhenExpressionContextAttrs<'input> for WhenExpressionContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn whenExpression(&mut self,)
	-> Result<Rc<WhenExpressionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = WhenExpressionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 254, RULE_whenExpression);
        let mut _localctx: Rc<WhenExpressionContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(3066);
			recog.base.match_token(WHEN,&mut recog.err_handler)?;

			recog.base.set_state(3070);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(472,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					recog.base.set_state(3067);
					recog.base.match_token(NL,&mut recog.err_handler)?;

					}
					} 
				}
				recog.base.set_state(3072);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(472,&mut recog.base)?;
			}
			recog.base.set_state(3074);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==LPAREN {
				{
				/*InvokeRule whenSubject*/
				recog.base.set_state(3073);
				recog.whenSubject()?;

				}
			}

			recog.base.set_state(3079);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(3076);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(3081);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(3082);
			recog.base.match_token(LCURL,&mut recog.err_handler)?;

			recog.base.set_state(3086);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(475,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					recog.base.set_state(3083);
					recog.base.match_token(NL,&mut recog.err_handler)?;

					}
					} 
				}
				recog.base.set_state(3088);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(475,&mut recog.base)?;
			}
			recog.base.set_state(3098);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(477,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					/*InvokeRule whenEntry*/
					recog.base.set_state(3089);
					recog.whenEntry()?;

					recog.base.set_state(3093);
					recog.err_handler.sync(&mut recog.base)?;
					_alt = recog.interpreter.adaptive_predict(476,&mut recog.base)?;
					while { _alt!=2 && _alt!=INVALID_ALT } {
						if _alt==1 {
							{
							{
							recog.base.set_state(3090);
							recog.base.match_token(NL,&mut recog.err_handler)?;

							}
							} 
						}
						recog.base.set_state(3095);
						recog.err_handler.sync(&mut recog.base)?;
						_alt = recog.interpreter.adaptive_predict(476,&mut recog.base)?;
					}
					}
					} 
				}
				recog.base.set_state(3100);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(477,&mut recog.base)?;
			}
			recog.base.set_state(3104);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(3101);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(3106);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(3107);
			recog.base.match_token(RCURL,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- whenEntry ----------------
pub type WhenEntryContextAll<'input> = WhenEntryContext<'input>;


pub type WhenEntryContext<'input> = BaseParserRuleContext<'input,WhenEntryContextExt<'input>>;

#[derive(Clone)]
pub struct WhenEntryContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for WhenEntryContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for WhenEntryContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_whenEntry(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_whenEntry(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for WhenEntryContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_whenEntry(self);
	}
}

impl<'input> CustomRuleContext<'input> for WhenEntryContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_whenEntry }
	//fn type_rule_index() -> usize where Self: Sized { RULE_whenEntry }
}
antlr_rust::type_id!{WhenEntryContextExt<'a>}

impl<'input> WhenEntryContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<WhenEntryContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,WhenEntryContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait WhenEntryContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<WhenEntryContextExt<'input>>{

fn whenCondition_all(&self) ->  Vec<Rc<WhenConditionContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn whenCondition(&self, i: usize) -> Option<Rc<WhenConditionContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves first TerminalNode corresponding to token ARROW
/// Returns `None` if there is no child corresponding to token ARROW
fn ARROW(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(ARROW, 0)
}
fn controlStructureBody(&self) -> Option<Rc<ControlStructureBodyContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}
fn semi(&self) -> Option<Rc<SemiContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token ELSE
/// Returns `None` if there is no child corresponding to token ELSE
fn ELSE(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(ELSE, 0)
}

}

impl<'input> WhenEntryContextAttrs<'input> for WhenEntryContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn whenEntry(&mut self,)
	-> Result<Rc<WhenEntryContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = WhenEntryContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 256, RULE_whenEntry);
        let mut _localctx: Rc<WhenEntryContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			let mut _alt: isize;
			recog.base.set_state(3173);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 NL | LPAREN | LSQUARE | LCURL | ADD | SUB | INCR | DECR | EXCL_WS | EXCL_NO_WS |
			 COLONCOLON | AT_NO_WS | AT_PRE_WS | RETURN_AT | CONTINUE_AT | BREAK_AT |
			 THIS_AT | SUPER_AT | FILE | FIELD | PROPERTY | GET | SET | RECEIVER |
			 PARAM | SETPARAM | DELEGATE | IMPORT | FUN | OBJECT | CONSTRUCTOR | BY |
			 COMPANION | INIT | THIS | SUPER | WHERE | IF | WHEN | TRY | CATCH | FINALLY |
			 THROW | RETURN | CONTINUE | BREAK | IS | IN | NOT_IS | NOT_IN | OUT |
			 DYNAMIC | PUBLIC | PRIVATE | PROTECTED | INTERNAL | ENUM | SEALED | ANNOTATION |
			 DATA | INNER | VALUE | TAILREC | OPERATOR | INLINE | INFIX | EXTERNAL |
			 SUSPEND | OVERRIDE | ABSTRACT | FINAL | OPEN | CONST | LATEINIT | VARARG |
			 NOINLINE | CROSSINLINE | REIFIED | EXPECT | ACTUAL | RealLiteral | IntegerLiteral |
			 HexLiteral | BinLiteral | UnsignedLiteral | LongLiteral | BooleanLiteral |
			 NullLiteral | CharacterLiteral | Identifier | QUOTE_OPEN | TRIPLE_QUOTE_OPEN 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule whenCondition*/
					recog.base.set_state(3109);
					recog.whenCondition()?;

					recog.base.set_state(3126);
					recog.err_handler.sync(&mut recog.base)?;
					_alt = recog.interpreter.adaptive_predict(481,&mut recog.base)?;
					while { _alt!=2 && _alt!=INVALID_ALT } {
						if _alt==1 {
							{
							{
							recog.base.set_state(3113);
							recog.err_handler.sync(&mut recog.base)?;
							_la = recog.base.input.la(1);
							while _la==NL {
								{
								{
								recog.base.set_state(3110);
								recog.base.match_token(NL,&mut recog.err_handler)?;

								}
								}
								recog.base.set_state(3115);
								recog.err_handler.sync(&mut recog.base)?;
								_la = recog.base.input.la(1);
							}
							recog.base.set_state(3116);
							recog.base.match_token(COMMA,&mut recog.err_handler)?;

							recog.base.set_state(3120);
							recog.err_handler.sync(&mut recog.base)?;
							_alt = recog.interpreter.adaptive_predict(480,&mut recog.base)?;
							while { _alt!=2 && _alt!=INVALID_ALT } {
								if _alt==1 {
									{
									{
									recog.base.set_state(3117);
									recog.base.match_token(NL,&mut recog.err_handler)?;

									}
									} 
								}
								recog.base.set_state(3122);
								recog.err_handler.sync(&mut recog.base)?;
								_alt = recog.interpreter.adaptive_predict(480,&mut recog.base)?;
							}
							/*InvokeRule whenCondition*/
							recog.base.set_state(3123);
							recog.whenCondition()?;

							}
							} 
						}
						recog.base.set_state(3128);
						recog.err_handler.sync(&mut recog.base)?;
						_alt = recog.interpreter.adaptive_predict(481,&mut recog.base)?;
					}
					recog.base.set_state(3136);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(483,&mut recog.base)? {
						x if x == 1=>{
							{
							recog.base.set_state(3132);
							recog.err_handler.sync(&mut recog.base)?;
							_la = recog.base.input.la(1);
							while _la==NL {
								{
								{
								recog.base.set_state(3129);
								recog.base.match_token(NL,&mut recog.err_handler)?;

								}
								}
								recog.base.set_state(3134);
								recog.err_handler.sync(&mut recog.base)?;
								_la = recog.base.input.la(1);
							}
							recog.base.set_state(3135);
							recog.base.match_token(COMMA,&mut recog.err_handler)?;

							}
						}

						_ => {}
					}
					recog.base.set_state(3141);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(3138);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(3143);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(3144);
					recog.base.match_token(ARROW,&mut recog.err_handler)?;

					recog.base.set_state(3148);
					recog.err_handler.sync(&mut recog.base)?;
					_alt = recog.interpreter.adaptive_predict(485,&mut recog.base)?;
					while { _alt!=2 && _alt!=INVALID_ALT } {
						if _alt==1 {
							{
							{
							recog.base.set_state(3145);
							recog.base.match_token(NL,&mut recog.err_handler)?;

							}
							} 
						}
						recog.base.set_state(3150);
						recog.err_handler.sync(&mut recog.base)?;
						_alt = recog.interpreter.adaptive_predict(485,&mut recog.base)?;
					}
					/*InvokeRule controlStructureBody*/
					recog.base.set_state(3151);
					recog.controlStructureBody()?;

					recog.base.set_state(3153);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(486,&mut recog.base)? {
						x if x == 1=>{
							{
							/*InvokeRule semi*/
							recog.base.set_state(3152);
							recog.semi()?;

							}
						}

						_ => {}
					}
					}
				}

			 ELSE 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(3155);
					recog.base.match_token(ELSE,&mut recog.err_handler)?;

					recog.base.set_state(3159);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(3156);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(3161);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(3162);
					recog.base.match_token(ARROW,&mut recog.err_handler)?;

					recog.base.set_state(3166);
					recog.err_handler.sync(&mut recog.base)?;
					_alt = recog.interpreter.adaptive_predict(488,&mut recog.base)?;
					while { _alt!=2 && _alt!=INVALID_ALT } {
						if _alt==1 {
							{
							{
							recog.base.set_state(3163);
							recog.base.match_token(NL,&mut recog.err_handler)?;

							}
							} 
						}
						recog.base.set_state(3168);
						recog.err_handler.sync(&mut recog.base)?;
						_alt = recog.interpreter.adaptive_predict(488,&mut recog.base)?;
					}
					/*InvokeRule controlStructureBody*/
					recog.base.set_state(3169);
					recog.controlStructureBody()?;

					recog.base.set_state(3171);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(489,&mut recog.base)? {
						x if x == 1=>{
							{
							/*InvokeRule semi*/
							recog.base.set_state(3170);
							recog.semi()?;

							}
						}

						_ => {}
					}
					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- whenCondition ----------------
pub type WhenConditionContextAll<'input> = WhenConditionContext<'input>;


pub type WhenConditionContext<'input> = BaseParserRuleContext<'input,WhenConditionContextExt<'input>>;

#[derive(Clone)]
pub struct WhenConditionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for WhenConditionContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for WhenConditionContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_whenCondition(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_whenCondition(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for WhenConditionContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_whenCondition(self);
	}
}

impl<'input> CustomRuleContext<'input> for WhenConditionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_whenCondition }
	//fn type_rule_index() -> usize where Self: Sized { RULE_whenCondition }
}
antlr_rust::type_id!{WhenConditionContextExt<'a>}

impl<'input> WhenConditionContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<WhenConditionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,WhenConditionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait WhenConditionContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<WhenConditionContextExt<'input>>{

fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn rangeTest(&self) -> Option<Rc<RangeTestContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn typeTest(&self) -> Option<Rc<TypeTestContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> WhenConditionContextAttrs<'input> for WhenConditionContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn whenCondition(&mut self,)
	-> Result<Rc<WhenConditionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = WhenConditionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 258, RULE_whenCondition);
        let mut _localctx: Rc<WhenConditionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			recog.base.set_state(3178);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 NL | LPAREN | LSQUARE | LCURL | ADD | SUB | INCR | DECR | EXCL_WS | EXCL_NO_WS |
			 COLONCOLON | AT_NO_WS | AT_PRE_WS | RETURN_AT | CONTINUE_AT | BREAK_AT |
			 THIS_AT | SUPER_AT | FILE | FIELD | PROPERTY | GET | SET | RECEIVER |
			 PARAM | SETPARAM | DELEGATE | IMPORT | FUN | OBJECT | CONSTRUCTOR | BY |
			 COMPANION | INIT | THIS | SUPER | WHERE | IF | WHEN | TRY | CATCH | FINALLY |
			 THROW | RETURN | CONTINUE | BREAK | OUT | DYNAMIC | PUBLIC | PRIVATE |
			 PROTECTED | INTERNAL | ENUM | SEALED | ANNOTATION | DATA | INNER | VALUE |
			 TAILREC | OPERATOR | INLINE | INFIX | EXTERNAL | SUSPEND | OVERRIDE |
			 ABSTRACT | FINAL | OPEN | CONST | LATEINIT | VARARG | NOINLINE | CROSSINLINE |
			 REIFIED | EXPECT | ACTUAL | RealLiteral | IntegerLiteral | HexLiteral |
			 BinLiteral | UnsignedLiteral | LongLiteral | BooleanLiteral | NullLiteral |
			 CharacterLiteral | Identifier | QUOTE_OPEN | TRIPLE_QUOTE_OPEN 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule expression*/
					recog.base.set_state(3175);
					recog.expression()?;

					}
				}

			 IN | NOT_IN 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule rangeTest*/
					recog.base.set_state(3176);
					recog.rangeTest()?;

					}
				}

			 IS | NOT_IS 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					/*InvokeRule typeTest*/
					recog.base.set_state(3177);
					recog.typeTest()?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- rangeTest ----------------
pub type RangeTestContextAll<'input> = RangeTestContext<'input>;


pub type RangeTestContext<'input> = BaseParserRuleContext<'input,RangeTestContextExt<'input>>;

#[derive(Clone)]
pub struct RangeTestContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for RangeTestContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for RangeTestContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_rangeTest(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_rangeTest(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for RangeTestContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_rangeTest(self);
	}
}

impl<'input> CustomRuleContext<'input> for RangeTestContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_rangeTest }
	//fn type_rule_index() -> usize where Self: Sized { RULE_rangeTest }
}
antlr_rust::type_id!{RangeTestContextExt<'a>}

impl<'input> RangeTestContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<RangeTestContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,RangeTestContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait RangeTestContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<RangeTestContextExt<'input>>{

fn inOperator(&self) -> Option<Rc<InOperatorContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}

}

impl<'input> RangeTestContextAttrs<'input> for RangeTestContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn rangeTest(&mut self,)
	-> Result<Rc<RangeTestContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = RangeTestContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 260, RULE_rangeTest);
        let mut _localctx: Rc<RangeTestContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule inOperator*/
			recog.base.set_state(3180);
			recog.inOperator()?;

			recog.base.set_state(3184);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(492,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					recog.base.set_state(3181);
					recog.base.match_token(NL,&mut recog.err_handler)?;

					}
					} 
				}
				recog.base.set_state(3186);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(492,&mut recog.base)?;
			}
			/*InvokeRule expression*/
			recog.base.set_state(3187);
			recog.expression()?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- typeTest ----------------
pub type TypeTestContextAll<'input> = TypeTestContext<'input>;


pub type TypeTestContext<'input> = BaseParserRuleContext<'input,TypeTestContextExt<'input>>;

#[derive(Clone)]
pub struct TypeTestContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for TypeTestContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for TypeTestContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_typeTest(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_typeTest(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for TypeTestContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_typeTest(self);
	}
}

impl<'input> CustomRuleContext<'input> for TypeTestContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_typeTest }
	//fn type_rule_index() -> usize where Self: Sized { RULE_typeTest }
}
antlr_rust::type_id!{TypeTestContextExt<'a>}

impl<'input> TypeTestContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<TypeTestContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,TypeTestContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait TypeTestContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<TypeTestContextExt<'input>>{

fn isOperator(&self) -> Option<Rc<IsOperatorContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn type(&self) -> Option<Rc<TypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}

}

impl<'input> TypeTestContextAttrs<'input> for TypeTestContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn typeTest(&mut self,)
	-> Result<Rc<TypeTestContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = TypeTestContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 262, RULE_typeTest);
        let mut _localctx: Rc<TypeTestContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule isOperator*/
			recog.base.set_state(3189);
			recog.isOperator()?;

			recog.base.set_state(3193);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(3190);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(3195);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			/*InvokeRule type*/
			recog.base.set_state(3196);
			recog.type()?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- tryExpression ----------------
pub type TryExpressionContextAll<'input> = TryExpressionContext<'input>;


pub type TryExpressionContext<'input> = BaseParserRuleContext<'input,TryExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct TryExpressionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for TryExpressionContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for TryExpressionContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_tryExpression(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_tryExpression(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for TryExpressionContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_tryExpression(self);
	}
}

impl<'input> CustomRuleContext<'input> for TryExpressionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_tryExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_tryExpression }
}
antlr_rust::type_id!{TryExpressionContextExt<'a>}

impl<'input> TryExpressionContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<TryExpressionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,TryExpressionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait TryExpressionContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<TryExpressionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token TRY
/// Returns `None` if there is no child corresponding to token TRY
fn TRY(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(TRY, 0)
}
fn block(&self) -> Option<Rc<BlockContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn finallyBlock(&self) -> Option<Rc<FinallyBlockContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}
fn catchBlock_all(&self) ->  Vec<Rc<CatchBlockContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn catchBlock(&self, i: usize) -> Option<Rc<CatchBlockContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> TryExpressionContextAttrs<'input> for TryExpressionContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn tryExpression(&mut self,)
	-> Result<Rc<TryExpressionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = TryExpressionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 264, RULE_tryExpression);
        let mut _localctx: Rc<TryExpressionContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(3198);
			recog.base.match_token(TRY,&mut recog.err_handler)?;

			recog.base.set_state(3202);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(3199);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(3204);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			/*InvokeRule block*/
			recog.base.set_state(3205);
			recog.block()?;

			recog.base.set_state(3233);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(500,&mut recog.base)? {
				1 =>{
					{
					recog.base.set_state(3213); 
					recog.err_handler.sync(&mut recog.base)?;
					_alt = 1;
					loop {
						match _alt {
						    x if x == 1=>
							{
							{
							recog.base.set_state(3209);
							recog.err_handler.sync(&mut recog.base)?;
							_la = recog.base.input.la(1);
							while _la==NL {
								{
								{
								recog.base.set_state(3206);
								recog.base.match_token(NL,&mut recog.err_handler)?;

								}
								}
								recog.base.set_state(3211);
								recog.err_handler.sync(&mut recog.base)?;
								_la = recog.base.input.la(1);
							}
							/*InvokeRule catchBlock*/
							recog.base.set_state(3212);
							recog.catchBlock()?;

							}
							}

						_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
						}
						recog.base.set_state(3215); 
						recog.err_handler.sync(&mut recog.base)?;
						_alt = recog.interpreter.adaptive_predict(496,&mut recog.base)?;
						if _alt==2 || _alt==INVALID_ALT { break }
					}
					recog.base.set_state(3224);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(498,&mut recog.base)? {
						x if x == 1=>{
							{
							recog.base.set_state(3220);
							recog.err_handler.sync(&mut recog.base)?;
							_la = recog.base.input.la(1);
							while _la==NL {
								{
								{
								recog.base.set_state(3217);
								recog.base.match_token(NL,&mut recog.err_handler)?;

								}
								}
								recog.base.set_state(3222);
								recog.err_handler.sync(&mut recog.base)?;
								_la = recog.base.input.la(1);
							}
							/*InvokeRule finallyBlock*/
							recog.base.set_state(3223);
							recog.finallyBlock()?;

							}
						}

						_ => {}
					}
					}
				}
			,
				2 =>{
					{
					recog.base.set_state(3229);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(3226);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(3231);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					/*InvokeRule finallyBlock*/
					recog.base.set_state(3232);
					recog.finallyBlock()?;

					}
				}

				_ => {}
			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- catchBlock ----------------
pub type CatchBlockContextAll<'input> = CatchBlockContext<'input>;


pub type CatchBlockContext<'input> = BaseParserRuleContext<'input,CatchBlockContextExt<'input>>;

#[derive(Clone)]
pub struct CatchBlockContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for CatchBlockContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for CatchBlockContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_catchBlock(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_catchBlock(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for CatchBlockContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_catchBlock(self);
	}
}

impl<'input> CustomRuleContext<'input> for CatchBlockContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_catchBlock }
	//fn type_rule_index() -> usize where Self: Sized { RULE_catchBlock }
}
antlr_rust::type_id!{CatchBlockContextExt<'a>}

impl<'input> CatchBlockContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<CatchBlockContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,CatchBlockContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait CatchBlockContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<CatchBlockContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token CATCH
/// Returns `None` if there is no child corresponding to token CATCH
fn CATCH(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(CATCH, 0)
}
/// Retrieves first TerminalNode corresponding to token LPAREN
/// Returns `None` if there is no child corresponding to token LPAREN
fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(LPAREN, 0)
}
fn simpleIdentifier(&self) -> Option<Rc<SimpleIdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COLON
/// Returns `None` if there is no child corresponding to token COLON
fn COLON(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(COLON, 0)
}
fn type(&self) -> Option<Rc<TypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token RPAREN
/// Returns `None` if there is no child corresponding to token RPAREN
fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(RPAREN, 0)
}
fn block(&self) -> Option<Rc<BlockContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}
fn annotation_all(&self) ->  Vec<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves first TerminalNode corresponding to token COMMA
/// Returns `None` if there is no child corresponding to token COMMA
fn COMMA(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(COMMA, 0)
}

}

impl<'input> CatchBlockContextAttrs<'input> for CatchBlockContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn catchBlock(&mut self,)
	-> Result<Rc<CatchBlockContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = CatchBlockContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 266, RULE_catchBlock);
        let mut _localctx: Rc<CatchBlockContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(3235);
			recog.base.match_token(CATCH,&mut recog.err_handler)?;

			recog.base.set_state(3239);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(3236);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(3241);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(3242);
			recog.base.match_token(LPAREN,&mut recog.err_handler)?;

			recog.base.set_state(3246);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==AT_NO_WS || _la==AT_PRE_WS {
				{
				{
				/*InvokeRule annotation*/
				recog.base.set_state(3243);
				recog.annotation()?;

				}
				}
				recog.base.set_state(3248);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			/*InvokeRule simpleIdentifier*/
			recog.base.set_state(3249);
			recog.simpleIdentifier()?;

			recog.base.set_state(3250);
			recog.base.match_token(COLON,&mut recog.err_handler)?;

			/*InvokeRule type*/
			recog.base.set_state(3251);
			recog.type()?;

			recog.base.set_state(3259);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==NL || _la==COMMA {
				{
				recog.base.set_state(3255);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
				while _la==NL {
					{
					{
					recog.base.set_state(3252);
					recog.base.match_token(NL,&mut recog.err_handler)?;

					}
					}
					recog.base.set_state(3257);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
				}
				recog.base.set_state(3258);
				recog.base.match_token(COMMA,&mut recog.err_handler)?;

				}
			}

			recog.base.set_state(3261);
			recog.base.match_token(RPAREN,&mut recog.err_handler)?;

			recog.base.set_state(3265);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(3262);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(3267);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			/*InvokeRule block*/
			recog.base.set_state(3268);
			recog.block()?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- finallyBlock ----------------
pub type FinallyBlockContextAll<'input> = FinallyBlockContext<'input>;


pub type FinallyBlockContext<'input> = BaseParserRuleContext<'input,FinallyBlockContextExt<'input>>;

#[derive(Clone)]
pub struct FinallyBlockContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for FinallyBlockContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for FinallyBlockContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_finallyBlock(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_finallyBlock(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for FinallyBlockContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_finallyBlock(self);
	}
}

impl<'input> CustomRuleContext<'input> for FinallyBlockContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_finallyBlock }
	//fn type_rule_index() -> usize where Self: Sized { RULE_finallyBlock }
}
antlr_rust::type_id!{FinallyBlockContextExt<'a>}

impl<'input> FinallyBlockContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<FinallyBlockContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,FinallyBlockContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait FinallyBlockContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<FinallyBlockContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token FINALLY
/// Returns `None` if there is no child corresponding to token FINALLY
fn FINALLY(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(FINALLY, 0)
}
fn block(&self) -> Option<Rc<BlockContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}

}

impl<'input> FinallyBlockContextAttrs<'input> for FinallyBlockContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn finallyBlock(&mut self,)
	-> Result<Rc<FinallyBlockContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = FinallyBlockContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 268, RULE_finallyBlock);
        let mut _localctx: Rc<FinallyBlockContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(3270);
			recog.base.match_token(FINALLY,&mut recog.err_handler)?;

			recog.base.set_state(3274);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(3271);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(3276);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			/*InvokeRule block*/
			recog.base.set_state(3277);
			recog.block()?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- jumpExpression ----------------
pub type JumpExpressionContextAll<'input> = JumpExpressionContext<'input>;


pub type JumpExpressionContext<'input> = BaseParserRuleContext<'input,JumpExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct JumpExpressionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for JumpExpressionContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for JumpExpressionContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_jumpExpression(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_jumpExpression(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for JumpExpressionContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_jumpExpression(self);
	}
}

impl<'input> CustomRuleContext<'input> for JumpExpressionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_jumpExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_jumpExpression }
}
antlr_rust::type_id!{JumpExpressionContextExt<'a>}

impl<'input> JumpExpressionContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<JumpExpressionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,JumpExpressionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait JumpExpressionContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<JumpExpressionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token THROW
/// Returns `None` if there is no child corresponding to token THROW
fn THROW(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(THROW, 0)
}
fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}
/// Retrieves first TerminalNode corresponding to token RETURN
/// Returns `None` if there is no child corresponding to token RETURN
fn RETURN(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(RETURN, 0)
}
/// Retrieves first TerminalNode corresponding to token RETURN_AT
/// Returns `None` if there is no child corresponding to token RETURN_AT
fn RETURN_AT(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(RETURN_AT, 0)
}
/// Retrieves first TerminalNode corresponding to token CONTINUE
/// Returns `None` if there is no child corresponding to token CONTINUE
fn CONTINUE(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(CONTINUE, 0)
}
/// Retrieves first TerminalNode corresponding to token CONTINUE_AT
/// Returns `None` if there is no child corresponding to token CONTINUE_AT
fn CONTINUE_AT(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(CONTINUE_AT, 0)
}
/// Retrieves first TerminalNode corresponding to token BREAK
/// Returns `None` if there is no child corresponding to token BREAK
fn BREAK(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(BREAK, 0)
}
/// Retrieves first TerminalNode corresponding to token BREAK_AT
/// Returns `None` if there is no child corresponding to token BREAK_AT
fn BREAK_AT(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(BREAK_AT, 0)
}

}

impl<'input> JumpExpressionContextAttrs<'input> for JumpExpressionContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn jumpExpression(&mut self,)
	-> Result<Rc<JumpExpressionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = JumpExpressionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 270, RULE_jumpExpression);
        let mut _localctx: Rc<JumpExpressionContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			let mut _alt: isize;
			recog.base.set_state(3295);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 THROW 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					recog.base.set_state(3279);
					recog.base.match_token(THROW,&mut recog.err_handler)?;

					recog.base.set_state(3283);
					recog.err_handler.sync(&mut recog.base)?;
					_alt = recog.interpreter.adaptive_predict(507,&mut recog.base)?;
					while { _alt!=2 && _alt!=INVALID_ALT } {
						if _alt==1 {
							{
							{
							recog.base.set_state(3280);
							recog.base.match_token(NL,&mut recog.err_handler)?;

							}
							} 
						}
						recog.base.set_state(3285);
						recog.err_handler.sync(&mut recog.base)?;
						_alt = recog.interpreter.adaptive_predict(507,&mut recog.base)?;
					}
					/*InvokeRule expression*/
					recog.base.set_state(3286);
					recog.expression()?;

					}
				}

			 RETURN_AT | RETURN 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(3287);
					_la = recog.base.input.la(1);
					if { !(_la==RETURN_AT || _la==RETURN) } {
						recog.err_handler.recover_inline(&mut recog.base)?;

					}
					else {
						if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
						recog.err_handler.report_match(&mut recog.base);
						recog.base.consume(&mut recog.err_handler);
					}
					recog.base.set_state(3289);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(508,&mut recog.base)? {
						x if x == 1=>{
							{
							/*InvokeRule expression*/
							recog.base.set_state(3288);
							recog.expression()?;

							}
						}

						_ => {}
					}
					}
				}

			 CONTINUE 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					recog.base.set_state(3291);
					recog.base.match_token(CONTINUE,&mut recog.err_handler)?;

					}
				}

			 CONTINUE_AT 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 4);
					recog.base.enter_outer_alt(None, 4);
					{
					recog.base.set_state(3292);
					recog.base.match_token(CONTINUE_AT,&mut recog.err_handler)?;

					}
				}

			 BREAK 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 5);
					recog.base.enter_outer_alt(None, 5);
					{
					recog.base.set_state(3293);
					recog.base.match_token(BREAK,&mut recog.err_handler)?;

					}
				}

			 BREAK_AT 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 6);
					recog.base.enter_outer_alt(None, 6);
					{
					recog.base.set_state(3294);
					recog.base.match_token(BREAK_AT,&mut recog.err_handler)?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- callableReference ----------------
pub type CallableReferenceContextAll<'input> = CallableReferenceContext<'input>;


pub type CallableReferenceContext<'input> = BaseParserRuleContext<'input,CallableReferenceContextExt<'input>>;

#[derive(Clone)]
pub struct CallableReferenceContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for CallableReferenceContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for CallableReferenceContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_callableReference(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_callableReference(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for CallableReferenceContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_callableReference(self);
	}
}

impl<'input> CustomRuleContext<'input> for CallableReferenceContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_callableReference }
	//fn type_rule_index() -> usize where Self: Sized { RULE_callableReference }
}
antlr_rust::type_id!{CallableReferenceContextExt<'a>}

impl<'input> CallableReferenceContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<CallableReferenceContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,CallableReferenceContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait CallableReferenceContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<CallableReferenceContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token COLONCOLON
/// Returns `None` if there is no child corresponding to token COLONCOLON
fn COLONCOLON(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(COLONCOLON, 0)
}
fn simpleIdentifier(&self) -> Option<Rc<SimpleIdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token CLASS
/// Returns `None` if there is no child corresponding to token CLASS
fn CLASS(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(CLASS, 0)
}
fn receiverType(&self) -> Option<Rc<ReceiverTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}

}

impl<'input> CallableReferenceContextAttrs<'input> for CallableReferenceContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn callableReference(&mut self,)
	-> Result<Rc<CallableReferenceContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = CallableReferenceContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 272, RULE_callableReference);
        let mut _localctx: Rc<CallableReferenceContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(3298);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << LPAREN) | (1usize << AT_NO_WS) | (1usize << AT_PRE_WS) | (1usize << FILE))) != 0) || ((((_la - 64)) & !0x3f) == 0 && ((1usize << (_la - 64)) & ((1usize << (FIELD - 64)) | (1usize << (PROPERTY - 64)) | (1usize << (GET - 64)) | (1usize << (SET - 64)) | (1usize << (RECEIVER - 64)) | (1usize << (PARAM - 64)) | (1usize << (SETPARAM - 64)) | (1usize << (DELEGATE - 64)) | (1usize << (IMPORT - 64)) | (1usize << (CONSTRUCTOR - 64)) | (1usize << (BY - 64)) | (1usize << (COMPANION - 64)) | (1usize << (INIT - 64)) | (1usize << (WHERE - 64)) | (1usize << (CATCH - 64)) | (1usize << (FINALLY - 64)) | (1usize << (OUT - 64)) | (1usize << (DYNAMIC - 64)) | (1usize << (PUBLIC - 64)) | (1usize << (PRIVATE - 64)) | (1usize << (PROTECTED - 64)) | (1usize << (INTERNAL - 64)) | (1usize << (ENUM - 64)) | (1usize << (SEALED - 64)) | (1usize << (ANNOTATION - 64)) | (1usize << (DATA - 64)) | (1usize << (INNER - 64)) | (1usize << (VALUE - 64)) | (1usize << (TAILREC - 64)) | (1usize << (OPERATOR - 64)) | (1usize << (INLINE - 64)) | (1usize << (INFIX - 64)) | (1usize << (EXTERNAL - 64)) | (1usize << (SUSPEND - 64)) | (1usize << (OVERRIDE - 64)) | (1usize << (ABSTRACT - 64)) | (1usize << (FINAL - 64)))) != 0) || ((((_la - 128)) & !0x3f) == 0 && ((1usize << (_la - 128)) & ((1usize << (OPEN - 128)) | (1usize << (CONST - 128)) | (1usize << (LATEINIT - 128)) | (1usize << (VARARG - 128)) | (1usize << (NOINLINE - 128)) | (1usize << (CROSSINLINE - 128)) | (1usize << (REIFIED - 128)) | (1usize << (EXPECT - 128)) | (1usize << (ACTUAL - 128)) | (1usize << (Identifier - 128)))) != 0) {
				{
				/*InvokeRule receiverType*/
				recog.base.set_state(3297);
				recog.receiverType()?;

				}
			}

			recog.base.set_state(3300);
			recog.base.match_token(COLONCOLON,&mut recog.err_handler)?;

			recog.base.set_state(3304);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(3301);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(3306);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(3309);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 FILE | FIELD | PROPERTY | GET | SET | RECEIVER | PARAM | SETPARAM | DELEGATE |
			 IMPORT | CONSTRUCTOR | BY | COMPANION | INIT | WHERE | CATCH | FINALLY |
			 OUT | DYNAMIC | PUBLIC | PRIVATE | PROTECTED | INTERNAL | ENUM | SEALED |
			 ANNOTATION | DATA | INNER | VALUE | TAILREC | OPERATOR | INLINE | INFIX |
			 EXTERNAL | SUSPEND | OVERRIDE | ABSTRACT | FINAL | OPEN | CONST | LATEINIT |
			 VARARG | NOINLINE | CROSSINLINE | REIFIED | EXPECT | ACTUAL | Identifier 
				=> {
					{
					/*InvokeRule simpleIdentifier*/
					recog.base.set_state(3307);
					recog.simpleIdentifier()?;

					}
				}

			 CLASS 
				=> {
					{
					recog.base.set_state(3308);
					recog.base.match_token(CLASS,&mut recog.err_handler)?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- assignmentAndOperator ----------------
pub type AssignmentAndOperatorContextAll<'input> = AssignmentAndOperatorContext<'input>;


pub type AssignmentAndOperatorContext<'input> = BaseParserRuleContext<'input,AssignmentAndOperatorContextExt<'input>>;

#[derive(Clone)]
pub struct AssignmentAndOperatorContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for AssignmentAndOperatorContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for AssignmentAndOperatorContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_assignmentAndOperator(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_assignmentAndOperator(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for AssignmentAndOperatorContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_assignmentAndOperator(self);
	}
}

impl<'input> CustomRuleContext<'input> for AssignmentAndOperatorContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_assignmentAndOperator }
	//fn type_rule_index() -> usize where Self: Sized { RULE_assignmentAndOperator }
}
antlr_rust::type_id!{AssignmentAndOperatorContextExt<'a>}

impl<'input> AssignmentAndOperatorContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AssignmentAndOperatorContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AssignmentAndOperatorContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AssignmentAndOperatorContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<AssignmentAndOperatorContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token ADD_ASSIGNMENT
/// Returns `None` if there is no child corresponding to token ADD_ASSIGNMENT
fn ADD_ASSIGNMENT(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(ADD_ASSIGNMENT, 0)
}
/// Retrieves first TerminalNode corresponding to token SUB_ASSIGNMENT
/// Returns `None` if there is no child corresponding to token SUB_ASSIGNMENT
fn SUB_ASSIGNMENT(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(SUB_ASSIGNMENT, 0)
}
/// Retrieves first TerminalNode corresponding to token MULT_ASSIGNMENT
/// Returns `None` if there is no child corresponding to token MULT_ASSIGNMENT
fn MULT_ASSIGNMENT(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(MULT_ASSIGNMENT, 0)
}
/// Retrieves first TerminalNode corresponding to token DIV_ASSIGNMENT
/// Returns `None` if there is no child corresponding to token DIV_ASSIGNMENT
fn DIV_ASSIGNMENT(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(DIV_ASSIGNMENT, 0)
}
/// Retrieves first TerminalNode corresponding to token MOD_ASSIGNMENT
/// Returns `None` if there is no child corresponding to token MOD_ASSIGNMENT
fn MOD_ASSIGNMENT(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(MOD_ASSIGNMENT, 0)
}

}

impl<'input> AssignmentAndOperatorContextAttrs<'input> for AssignmentAndOperatorContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn assignmentAndOperator(&mut self,)
	-> Result<Rc<AssignmentAndOperatorContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AssignmentAndOperatorContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 274, RULE_assignmentAndOperator);
        let mut _localctx: Rc<AssignmentAndOperatorContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(3311);
			_la = recog.base.input.la(1);
			if { !((((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << ADD_ASSIGNMENT) | (1usize << SUB_ASSIGNMENT) | (1usize << MULT_ASSIGNMENT) | (1usize << DIV_ASSIGNMENT) | (1usize << MOD_ASSIGNMENT))) != 0)) } {
				recog.err_handler.recover_inline(&mut recog.base)?;

			}
			else {
				if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
				recog.err_handler.report_match(&mut recog.base);
				recog.base.consume(&mut recog.err_handler);
			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- equalityOperator ----------------
pub type EqualityOperatorContextAll<'input> = EqualityOperatorContext<'input>;


pub type EqualityOperatorContext<'input> = BaseParserRuleContext<'input,EqualityOperatorContextExt<'input>>;

#[derive(Clone)]
pub struct EqualityOperatorContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for EqualityOperatorContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for EqualityOperatorContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_equalityOperator(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_equalityOperator(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for EqualityOperatorContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_equalityOperator(self);
	}
}

impl<'input> CustomRuleContext<'input> for EqualityOperatorContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_equalityOperator }
	//fn type_rule_index() -> usize where Self: Sized { RULE_equalityOperator }
}
antlr_rust::type_id!{EqualityOperatorContextExt<'a>}

impl<'input> EqualityOperatorContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<EqualityOperatorContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,EqualityOperatorContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait EqualityOperatorContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<EqualityOperatorContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token EXCL_EQ
/// Returns `None` if there is no child corresponding to token EXCL_EQ
fn EXCL_EQ(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(EXCL_EQ, 0)
}
/// Retrieves first TerminalNode corresponding to token EXCL_EQEQ
/// Returns `None` if there is no child corresponding to token EXCL_EQEQ
fn EXCL_EQEQ(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(EXCL_EQEQ, 0)
}
/// Retrieves first TerminalNode corresponding to token EQEQ
/// Returns `None` if there is no child corresponding to token EQEQ
fn EQEQ(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(EQEQ, 0)
}
/// Retrieves first TerminalNode corresponding to token EQEQEQ
/// Returns `None` if there is no child corresponding to token EQEQEQ
fn EQEQEQ(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(EQEQEQ, 0)
}

}

impl<'input> EqualityOperatorContextAttrs<'input> for EqualityOperatorContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn equalityOperator(&mut self,)
	-> Result<Rc<EqualityOperatorContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = EqualityOperatorContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 276, RULE_equalityOperator);
        let mut _localctx: Rc<EqualityOperatorContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(3313);
			_la = recog.base.input.la(1);
			if { !((((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << EXCL_EQ) | (1usize << EXCL_EQEQ) | (1usize << EQEQ) | (1usize << EQEQEQ))) != 0)) } {
				recog.err_handler.recover_inline(&mut recog.base)?;

			}
			else {
				if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
				recog.err_handler.report_match(&mut recog.base);
				recog.base.consume(&mut recog.err_handler);
			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- comparisonOperator ----------------
pub type ComparisonOperatorContextAll<'input> = ComparisonOperatorContext<'input>;


pub type ComparisonOperatorContext<'input> = BaseParserRuleContext<'input,ComparisonOperatorContextExt<'input>>;

#[derive(Clone)]
pub struct ComparisonOperatorContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for ComparisonOperatorContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for ComparisonOperatorContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_comparisonOperator(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_comparisonOperator(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for ComparisonOperatorContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_comparisonOperator(self);
	}
}

impl<'input> CustomRuleContext<'input> for ComparisonOperatorContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_comparisonOperator }
	//fn type_rule_index() -> usize where Self: Sized { RULE_comparisonOperator }
}
antlr_rust::type_id!{ComparisonOperatorContextExt<'a>}

impl<'input> ComparisonOperatorContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ComparisonOperatorContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ComparisonOperatorContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ComparisonOperatorContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<ComparisonOperatorContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token LANGLE
/// Returns `None` if there is no child corresponding to token LANGLE
fn LANGLE(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(LANGLE, 0)
}
/// Retrieves first TerminalNode corresponding to token RANGLE
/// Returns `None` if there is no child corresponding to token RANGLE
fn RANGLE(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(RANGLE, 0)
}
/// Retrieves first TerminalNode corresponding to token LE
/// Returns `None` if there is no child corresponding to token LE
fn LE(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(LE, 0)
}
/// Retrieves first TerminalNode corresponding to token GE
/// Returns `None` if there is no child corresponding to token GE
fn GE(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(GE, 0)
}

}

impl<'input> ComparisonOperatorContextAttrs<'input> for ComparisonOperatorContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn comparisonOperator(&mut self,)
	-> Result<Rc<ComparisonOperatorContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ComparisonOperatorContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 278, RULE_comparisonOperator);
        let mut _localctx: Rc<ComparisonOperatorContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(3315);
			_la = recog.base.input.la(1);
			if { !((((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << LANGLE) | (1usize << RANGLE) | (1usize << LE) | (1usize << GE))) != 0)) } {
				recog.err_handler.recover_inline(&mut recog.base)?;

			}
			else {
				if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
				recog.err_handler.report_match(&mut recog.base);
				recog.base.consume(&mut recog.err_handler);
			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- inOperator ----------------
pub type InOperatorContextAll<'input> = InOperatorContext<'input>;


pub type InOperatorContext<'input> = BaseParserRuleContext<'input,InOperatorContextExt<'input>>;

#[derive(Clone)]
pub struct InOperatorContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for InOperatorContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for InOperatorContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_inOperator(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_inOperator(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for InOperatorContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_inOperator(self);
	}
}

impl<'input> CustomRuleContext<'input> for InOperatorContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_inOperator }
	//fn type_rule_index() -> usize where Self: Sized { RULE_inOperator }
}
antlr_rust::type_id!{InOperatorContextExt<'a>}

impl<'input> InOperatorContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<InOperatorContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,InOperatorContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait InOperatorContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<InOperatorContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token IN
/// Returns `None` if there is no child corresponding to token IN
fn IN(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(IN, 0)
}
/// Retrieves first TerminalNode corresponding to token NOT_IN
/// Returns `None` if there is no child corresponding to token NOT_IN
fn NOT_IN(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NOT_IN, 0)
}

}

impl<'input> InOperatorContextAttrs<'input> for InOperatorContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn inOperator(&mut self,)
	-> Result<Rc<InOperatorContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = InOperatorContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 280, RULE_inOperator);
        let mut _localctx: Rc<InOperatorContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(3317);
			_la = recog.base.input.la(1);
			if { !(_la==IN || _la==NOT_IN) } {
				recog.err_handler.recover_inline(&mut recog.base)?;

			}
			else {
				if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
				recog.err_handler.report_match(&mut recog.base);
				recog.base.consume(&mut recog.err_handler);
			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- isOperator ----------------
pub type IsOperatorContextAll<'input> = IsOperatorContext<'input>;


pub type IsOperatorContext<'input> = BaseParserRuleContext<'input,IsOperatorContextExt<'input>>;

#[derive(Clone)]
pub struct IsOperatorContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for IsOperatorContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for IsOperatorContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_isOperator(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_isOperator(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for IsOperatorContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_isOperator(self);
	}
}

impl<'input> CustomRuleContext<'input> for IsOperatorContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_isOperator }
	//fn type_rule_index() -> usize where Self: Sized { RULE_isOperator }
}
antlr_rust::type_id!{IsOperatorContextExt<'a>}

impl<'input> IsOperatorContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<IsOperatorContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,IsOperatorContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait IsOperatorContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<IsOperatorContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token IS
/// Returns `None` if there is no child corresponding to token IS
fn IS(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(IS, 0)
}
/// Retrieves first TerminalNode corresponding to token NOT_IS
/// Returns `None` if there is no child corresponding to token NOT_IS
fn NOT_IS(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NOT_IS, 0)
}

}

impl<'input> IsOperatorContextAttrs<'input> for IsOperatorContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn isOperator(&mut self,)
	-> Result<Rc<IsOperatorContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = IsOperatorContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 282, RULE_isOperator);
        let mut _localctx: Rc<IsOperatorContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(3319);
			_la = recog.base.input.la(1);
			if { !(_la==IS || _la==NOT_IS) } {
				recog.err_handler.recover_inline(&mut recog.base)?;

			}
			else {
				if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
				recog.err_handler.report_match(&mut recog.base);
				recog.base.consume(&mut recog.err_handler);
			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- additiveOperator ----------------
pub type AdditiveOperatorContextAll<'input> = AdditiveOperatorContext<'input>;


pub type AdditiveOperatorContext<'input> = BaseParserRuleContext<'input,AdditiveOperatorContextExt<'input>>;

#[derive(Clone)]
pub struct AdditiveOperatorContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for AdditiveOperatorContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for AdditiveOperatorContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_additiveOperator(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_additiveOperator(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for AdditiveOperatorContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_additiveOperator(self);
	}
}

impl<'input> CustomRuleContext<'input> for AdditiveOperatorContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_additiveOperator }
	//fn type_rule_index() -> usize where Self: Sized { RULE_additiveOperator }
}
antlr_rust::type_id!{AdditiveOperatorContextExt<'a>}

impl<'input> AdditiveOperatorContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AdditiveOperatorContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AdditiveOperatorContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AdditiveOperatorContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<AdditiveOperatorContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token ADD
/// Returns `None` if there is no child corresponding to token ADD
fn ADD(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(ADD, 0)
}
/// Retrieves first TerminalNode corresponding to token SUB
/// Returns `None` if there is no child corresponding to token SUB
fn SUB(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(SUB, 0)
}

}

impl<'input> AdditiveOperatorContextAttrs<'input> for AdditiveOperatorContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn additiveOperator(&mut self,)
	-> Result<Rc<AdditiveOperatorContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AdditiveOperatorContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 284, RULE_additiveOperator);
        let mut _localctx: Rc<AdditiveOperatorContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(3321);
			_la = recog.base.input.la(1);
			if { !(_la==ADD || _la==SUB) } {
				recog.err_handler.recover_inline(&mut recog.base)?;

			}
			else {
				if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
				recog.err_handler.report_match(&mut recog.base);
				recog.base.consume(&mut recog.err_handler);
			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- multiplicativeOperator ----------------
pub type MultiplicativeOperatorContextAll<'input> = MultiplicativeOperatorContext<'input>;


pub type MultiplicativeOperatorContext<'input> = BaseParserRuleContext<'input,MultiplicativeOperatorContextExt<'input>>;

#[derive(Clone)]
pub struct MultiplicativeOperatorContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for MultiplicativeOperatorContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for MultiplicativeOperatorContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_multiplicativeOperator(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_multiplicativeOperator(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for MultiplicativeOperatorContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_multiplicativeOperator(self);
	}
}

impl<'input> CustomRuleContext<'input> for MultiplicativeOperatorContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_multiplicativeOperator }
	//fn type_rule_index() -> usize where Self: Sized { RULE_multiplicativeOperator }
}
antlr_rust::type_id!{MultiplicativeOperatorContextExt<'a>}

impl<'input> MultiplicativeOperatorContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<MultiplicativeOperatorContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,MultiplicativeOperatorContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait MultiplicativeOperatorContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<MultiplicativeOperatorContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token MULT
/// Returns `None` if there is no child corresponding to token MULT
fn MULT(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(MULT, 0)
}
/// Retrieves first TerminalNode corresponding to token DIV
/// Returns `None` if there is no child corresponding to token DIV
fn DIV(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(DIV, 0)
}
/// Retrieves first TerminalNode corresponding to token MOD
/// Returns `None` if there is no child corresponding to token MOD
fn MOD(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(MOD, 0)
}

}

impl<'input> MultiplicativeOperatorContextAttrs<'input> for MultiplicativeOperatorContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn multiplicativeOperator(&mut self,)
	-> Result<Rc<MultiplicativeOperatorContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = MultiplicativeOperatorContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 286, RULE_multiplicativeOperator);
        let mut _localctx: Rc<MultiplicativeOperatorContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(3323);
			_la = recog.base.input.la(1);
			if { !((((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << MULT) | (1usize << MOD) | (1usize << DIV))) != 0)) } {
				recog.err_handler.recover_inline(&mut recog.base)?;

			}
			else {
				if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
				recog.err_handler.report_match(&mut recog.base);
				recog.base.consume(&mut recog.err_handler);
			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- asOperator ----------------
pub type AsOperatorContextAll<'input> = AsOperatorContext<'input>;


pub type AsOperatorContext<'input> = BaseParserRuleContext<'input,AsOperatorContextExt<'input>>;

#[derive(Clone)]
pub struct AsOperatorContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for AsOperatorContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for AsOperatorContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_asOperator(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_asOperator(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for AsOperatorContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_asOperator(self);
	}
}

impl<'input> CustomRuleContext<'input> for AsOperatorContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_asOperator }
	//fn type_rule_index() -> usize where Self: Sized { RULE_asOperator }
}
antlr_rust::type_id!{AsOperatorContextExt<'a>}

impl<'input> AsOperatorContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AsOperatorContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AsOperatorContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AsOperatorContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<AsOperatorContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token AS
/// Returns `None` if there is no child corresponding to token AS
fn AS(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(AS, 0)
}
/// Retrieves first TerminalNode corresponding to token AS_SAFE
/// Returns `None` if there is no child corresponding to token AS_SAFE
fn AS_SAFE(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(AS_SAFE, 0)
}

}

impl<'input> AsOperatorContextAttrs<'input> for AsOperatorContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn asOperator(&mut self,)
	-> Result<Rc<AsOperatorContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AsOperatorContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 288, RULE_asOperator);
        let mut _localctx: Rc<AsOperatorContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(3325);
			_la = recog.base.input.la(1);
			if { !(_la==AS_SAFE || _la==AS) } {
				recog.err_handler.recover_inline(&mut recog.base)?;

			}
			else {
				if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
				recog.err_handler.report_match(&mut recog.base);
				recog.base.consume(&mut recog.err_handler);
			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- prefixUnaryOperator ----------------
pub type PrefixUnaryOperatorContextAll<'input> = PrefixUnaryOperatorContext<'input>;


pub type PrefixUnaryOperatorContext<'input> = BaseParserRuleContext<'input,PrefixUnaryOperatorContextExt<'input>>;

#[derive(Clone)]
pub struct PrefixUnaryOperatorContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for PrefixUnaryOperatorContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for PrefixUnaryOperatorContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_prefixUnaryOperator(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_prefixUnaryOperator(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for PrefixUnaryOperatorContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_prefixUnaryOperator(self);
	}
}

impl<'input> CustomRuleContext<'input> for PrefixUnaryOperatorContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_prefixUnaryOperator }
	//fn type_rule_index() -> usize where Self: Sized { RULE_prefixUnaryOperator }
}
antlr_rust::type_id!{PrefixUnaryOperatorContextExt<'a>}

impl<'input> PrefixUnaryOperatorContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<PrefixUnaryOperatorContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,PrefixUnaryOperatorContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait PrefixUnaryOperatorContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<PrefixUnaryOperatorContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token INCR
/// Returns `None` if there is no child corresponding to token INCR
fn INCR(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(INCR, 0)
}
/// Retrieves first TerminalNode corresponding to token DECR
/// Returns `None` if there is no child corresponding to token DECR
fn DECR(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(DECR, 0)
}
/// Retrieves first TerminalNode corresponding to token SUB
/// Returns `None` if there is no child corresponding to token SUB
fn SUB(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(SUB, 0)
}
/// Retrieves first TerminalNode corresponding to token ADD
/// Returns `None` if there is no child corresponding to token ADD
fn ADD(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(ADD, 0)
}
fn excl(&self) -> Option<Rc<ExclContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> PrefixUnaryOperatorContextAttrs<'input> for PrefixUnaryOperatorContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn prefixUnaryOperator(&mut self,)
	-> Result<Rc<PrefixUnaryOperatorContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = PrefixUnaryOperatorContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 290, RULE_prefixUnaryOperator);
        let mut _localctx: Rc<PrefixUnaryOperatorContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			recog.base.set_state(3332);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 INCR 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					recog.base.set_state(3327);
					recog.base.match_token(INCR,&mut recog.err_handler)?;

					}
				}

			 DECR 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(3328);
					recog.base.match_token(DECR,&mut recog.err_handler)?;

					}
				}

			 SUB 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					recog.base.set_state(3329);
					recog.base.match_token(SUB,&mut recog.err_handler)?;

					}
				}

			 ADD 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 4);
					recog.base.enter_outer_alt(None, 4);
					{
					recog.base.set_state(3330);
					recog.base.match_token(ADD,&mut recog.err_handler)?;

					}
				}

			 EXCL_WS | EXCL_NO_WS 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 5);
					recog.base.enter_outer_alt(None, 5);
					{
					/*InvokeRule excl*/
					recog.base.set_state(3331);
					recog.excl()?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- postfixUnaryOperator ----------------
pub type PostfixUnaryOperatorContextAll<'input> = PostfixUnaryOperatorContext<'input>;


pub type PostfixUnaryOperatorContext<'input> = BaseParserRuleContext<'input,PostfixUnaryOperatorContextExt<'input>>;

#[derive(Clone)]
pub struct PostfixUnaryOperatorContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for PostfixUnaryOperatorContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for PostfixUnaryOperatorContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_postfixUnaryOperator(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_postfixUnaryOperator(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for PostfixUnaryOperatorContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_postfixUnaryOperator(self);
	}
}

impl<'input> CustomRuleContext<'input> for PostfixUnaryOperatorContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_postfixUnaryOperator }
	//fn type_rule_index() -> usize where Self: Sized { RULE_postfixUnaryOperator }
}
antlr_rust::type_id!{PostfixUnaryOperatorContextExt<'a>}

impl<'input> PostfixUnaryOperatorContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<PostfixUnaryOperatorContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,PostfixUnaryOperatorContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait PostfixUnaryOperatorContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<PostfixUnaryOperatorContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token INCR
/// Returns `None` if there is no child corresponding to token INCR
fn INCR(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(INCR, 0)
}
/// Retrieves first TerminalNode corresponding to token DECR
/// Returns `None` if there is no child corresponding to token DECR
fn DECR(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(DECR, 0)
}
/// Retrieves first TerminalNode corresponding to token EXCL_NO_WS
/// Returns `None` if there is no child corresponding to token EXCL_NO_WS
fn EXCL_NO_WS(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(EXCL_NO_WS, 0)
}
fn excl(&self) -> Option<Rc<ExclContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> PostfixUnaryOperatorContextAttrs<'input> for PostfixUnaryOperatorContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn postfixUnaryOperator(&mut self,)
	-> Result<Rc<PostfixUnaryOperatorContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = PostfixUnaryOperatorContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 292, RULE_postfixUnaryOperator);
        let mut _localctx: Rc<PostfixUnaryOperatorContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			recog.base.set_state(3338);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 INCR 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					recog.base.set_state(3334);
					recog.base.match_token(INCR,&mut recog.err_handler)?;

					}
				}

			 DECR 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(3335);
					recog.base.match_token(DECR,&mut recog.err_handler)?;

					}
				}

			 EXCL_NO_WS 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					recog.base.set_state(3336);
					recog.base.match_token(EXCL_NO_WS,&mut recog.err_handler)?;

					/*InvokeRule excl*/
					recog.base.set_state(3337);
					recog.excl()?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- excl ----------------
pub type ExclContextAll<'input> = ExclContext<'input>;


pub type ExclContext<'input> = BaseParserRuleContext<'input,ExclContextExt<'input>>;

#[derive(Clone)]
pub struct ExclContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for ExclContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for ExclContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_excl(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_excl(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for ExclContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_excl(self);
	}
}

impl<'input> CustomRuleContext<'input> for ExclContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_excl }
	//fn type_rule_index() -> usize where Self: Sized { RULE_excl }
}
antlr_rust::type_id!{ExclContextExt<'a>}

impl<'input> ExclContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ExclContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ExclContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ExclContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<ExclContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token EXCL_NO_WS
/// Returns `None` if there is no child corresponding to token EXCL_NO_WS
fn EXCL_NO_WS(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(EXCL_NO_WS, 0)
}
/// Retrieves first TerminalNode corresponding to token EXCL_WS
/// Returns `None` if there is no child corresponding to token EXCL_WS
fn EXCL_WS(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(EXCL_WS, 0)
}

}

impl<'input> ExclContextAttrs<'input> for ExclContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn excl(&mut self,)
	-> Result<Rc<ExclContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ExclContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 294, RULE_excl);
        let mut _localctx: Rc<ExclContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(3340);
			_la = recog.base.input.la(1);
			if { !(_la==EXCL_WS || _la==EXCL_NO_WS) } {
				recog.err_handler.recover_inline(&mut recog.base)?;

			}
			else {
				if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
				recog.err_handler.report_match(&mut recog.base);
				recog.base.consume(&mut recog.err_handler);
			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- memberAccessOperator ----------------
pub type MemberAccessOperatorContextAll<'input> = MemberAccessOperatorContext<'input>;


pub type MemberAccessOperatorContext<'input> = BaseParserRuleContext<'input,MemberAccessOperatorContextExt<'input>>;

#[derive(Clone)]
pub struct MemberAccessOperatorContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for MemberAccessOperatorContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for MemberAccessOperatorContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_memberAccessOperator(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_memberAccessOperator(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for MemberAccessOperatorContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_memberAccessOperator(self);
	}
}

impl<'input> CustomRuleContext<'input> for MemberAccessOperatorContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_memberAccessOperator }
	//fn type_rule_index() -> usize where Self: Sized { RULE_memberAccessOperator }
}
antlr_rust::type_id!{MemberAccessOperatorContextExt<'a>}

impl<'input> MemberAccessOperatorContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<MemberAccessOperatorContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,MemberAccessOperatorContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait MemberAccessOperatorContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<MemberAccessOperatorContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token DOT
/// Returns `None` if there is no child corresponding to token DOT
fn DOT(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(DOT, 0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}
fn safeNav(&self) -> Option<Rc<SafeNavContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COLONCOLON
/// Returns `None` if there is no child corresponding to token COLONCOLON
fn COLONCOLON(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(COLONCOLON, 0)
}

}

impl<'input> MemberAccessOperatorContextAttrs<'input> for MemberAccessOperatorContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn memberAccessOperator(&mut self,)
	-> Result<Rc<MemberAccessOperatorContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = MemberAccessOperatorContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 296, RULE_memberAccessOperator);
        let mut _localctx: Rc<MemberAccessOperatorContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			recog.base.set_state(3357);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(517,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					recog.base.set_state(3345);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(3342);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(3347);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(3348);
					recog.base.match_token(DOT,&mut recog.err_handler)?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(3352);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(3349);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(3354);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					/*InvokeRule safeNav*/
					recog.base.set_state(3355);
					recog.safeNav()?;

					}
				}
			,
				3 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					recog.base.set_state(3356);
					recog.base.match_token(COLONCOLON,&mut recog.err_handler)?;

					}
				}

				_ => {}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- safeNav ----------------
pub type SafeNavContextAll<'input> = SafeNavContext<'input>;


pub type SafeNavContext<'input> = BaseParserRuleContext<'input,SafeNavContextExt<'input>>;

#[derive(Clone)]
pub struct SafeNavContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for SafeNavContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for SafeNavContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_safeNav(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_safeNav(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for SafeNavContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_safeNav(self);
	}
}

impl<'input> CustomRuleContext<'input> for SafeNavContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_safeNav }
	//fn type_rule_index() -> usize where Self: Sized { RULE_safeNav }
}
antlr_rust::type_id!{SafeNavContextExt<'a>}

impl<'input> SafeNavContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<SafeNavContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,SafeNavContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait SafeNavContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<SafeNavContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token QUEST_NO_WS
/// Returns `None` if there is no child corresponding to token QUEST_NO_WS
fn QUEST_NO_WS(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(QUEST_NO_WS, 0)
}
/// Retrieves first TerminalNode corresponding to token DOT
/// Returns `None` if there is no child corresponding to token DOT
fn DOT(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(DOT, 0)
}

}

impl<'input> SafeNavContextAttrs<'input> for SafeNavContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn safeNav(&mut self,)
	-> Result<Rc<SafeNavContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = SafeNavContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 298, RULE_safeNav);
        let mut _localctx: Rc<SafeNavContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(3359);
			recog.base.match_token(QUEST_NO_WS,&mut recog.err_handler)?;

			recog.base.set_state(3360);
			recog.base.match_token(DOT,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- modifiers ----------------
pub type ModifiersContextAll<'input> = ModifiersContext<'input>;


pub type ModifiersContext<'input> = BaseParserRuleContext<'input,ModifiersContextExt<'input>>;

#[derive(Clone)]
pub struct ModifiersContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for ModifiersContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for ModifiersContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_modifiers(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_modifiers(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for ModifiersContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_modifiers(self);
	}
}

impl<'input> CustomRuleContext<'input> for ModifiersContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_modifiers }
	//fn type_rule_index() -> usize where Self: Sized { RULE_modifiers }
}
antlr_rust::type_id!{ModifiersContextExt<'a>}

impl<'input> ModifiersContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ModifiersContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ModifiersContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ModifiersContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<ModifiersContextExt<'input>>{

fn annotation_all(&self) ->  Vec<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn modifier_all(&self) ->  Vec<Rc<ModifierContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn modifier(&self, i: usize) -> Option<Rc<ModifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> ModifiersContextAttrs<'input> for ModifiersContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn modifiers(&mut self,)
	-> Result<Rc<ModifiersContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ModifiersContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 300, RULE_modifiers);
        let mut _localctx: Rc<ModifiersContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(3364); 
			recog.err_handler.sync(&mut recog.base)?;
			_alt = 1;
			loop {
				match _alt {
				    x if x == 1=>
					{
					recog.base.set_state(3364);
					recog.err_handler.sync(&mut recog.base)?;
					match recog.base.input.la(1) {
					 AT_NO_WS | AT_PRE_WS 
						=> {
							{
							/*InvokeRule annotation*/
							recog.base.set_state(3362);
							recog.annotation()?;

							}
						}

					 PUBLIC | PRIVATE | PROTECTED | INTERNAL | ENUM | SEALED | ANNOTATION |
					 DATA | INNER | VALUE | TAILREC | OPERATOR | INLINE | INFIX | EXTERNAL |
					 SUSPEND | OVERRIDE | ABSTRACT | FINAL | OPEN | CONST | LATEINIT | VARARG |
					 NOINLINE | CROSSINLINE | EXPECT | ACTUAL 
						=> {
							{
							/*InvokeRule modifier*/
							recog.base.set_state(3363);
							recog.modifier()?;

							}
						}

						_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
					}
					}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
				}
				recog.base.set_state(3366); 
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(519,&mut recog.base)?;
				if _alt==2 || _alt==INVALID_ALT { break }
			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- parameterModifiers ----------------
pub type ParameterModifiersContextAll<'input> = ParameterModifiersContext<'input>;


pub type ParameterModifiersContext<'input> = BaseParserRuleContext<'input,ParameterModifiersContextExt<'input>>;

#[derive(Clone)]
pub struct ParameterModifiersContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for ParameterModifiersContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for ParameterModifiersContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_parameterModifiers(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_parameterModifiers(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for ParameterModifiersContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_parameterModifiers(self);
	}
}

impl<'input> CustomRuleContext<'input> for ParameterModifiersContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_parameterModifiers }
	//fn type_rule_index() -> usize where Self: Sized { RULE_parameterModifiers }
}
antlr_rust::type_id!{ParameterModifiersContextExt<'a>}

impl<'input> ParameterModifiersContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ParameterModifiersContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ParameterModifiersContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ParameterModifiersContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<ParameterModifiersContextExt<'input>>{

fn annotation_all(&self) ->  Vec<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn parameterModifier_all(&self) ->  Vec<Rc<ParameterModifierContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn parameterModifier(&self, i: usize) -> Option<Rc<ParameterModifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> ParameterModifiersContextAttrs<'input> for ParameterModifiersContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn parameterModifiers(&mut self,)
	-> Result<Rc<ParameterModifiersContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ParameterModifiersContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 302, RULE_parameterModifiers);
        let mut _localctx: Rc<ParameterModifiersContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(3370); 
			recog.err_handler.sync(&mut recog.base)?;
			_alt = 1;
			loop {
				match _alt {
				    x if x == 1=>
					{
					recog.base.set_state(3370);
					recog.err_handler.sync(&mut recog.base)?;
					match recog.base.input.la(1) {
					 AT_NO_WS | AT_PRE_WS 
						=> {
							{
							/*InvokeRule annotation*/
							recog.base.set_state(3368);
							recog.annotation()?;

							}
						}

					 VARARG | NOINLINE | CROSSINLINE 
						=> {
							{
							/*InvokeRule parameterModifier*/
							recog.base.set_state(3369);
							recog.parameterModifier()?;

							}
						}

						_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
					}
					}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
				}
				recog.base.set_state(3372); 
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(521,&mut recog.base)?;
				if _alt==2 || _alt==INVALID_ALT { break }
			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- modifier ----------------
pub type ModifierContextAll<'input> = ModifierContext<'input>;


pub type ModifierContext<'input> = BaseParserRuleContext<'input,ModifierContextExt<'input>>;

#[derive(Clone)]
pub struct ModifierContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for ModifierContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for ModifierContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_modifier(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_modifier(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for ModifierContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_modifier(self);
	}
}

impl<'input> CustomRuleContext<'input> for ModifierContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_modifier }
	//fn type_rule_index() -> usize where Self: Sized { RULE_modifier }
}
antlr_rust::type_id!{ModifierContextExt<'a>}

impl<'input> ModifierContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ModifierContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ModifierContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ModifierContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<ModifierContextExt<'input>>{

fn classModifier(&self) -> Option<Rc<ClassModifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn memberModifier(&self) -> Option<Rc<MemberModifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn visibilityModifier(&self) -> Option<Rc<VisibilityModifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn functionModifier(&self) -> Option<Rc<FunctionModifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn propertyModifier(&self) -> Option<Rc<PropertyModifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn inheritanceModifier(&self) -> Option<Rc<InheritanceModifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn parameterModifier(&self) -> Option<Rc<ParameterModifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn platformModifier(&self) -> Option<Rc<PlatformModifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}

}

impl<'input> ModifierContextAttrs<'input> for ModifierContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn modifier(&mut self,)
	-> Result<Rc<ModifierContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ModifierContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 304, RULE_modifier);
        let mut _localctx: Rc<ModifierContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(3382);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 ENUM | SEALED | ANNOTATION | DATA | INNER | VALUE 
				=> {
					{
					/*InvokeRule classModifier*/
					recog.base.set_state(3374);
					recog.classModifier()?;

					}
				}

			 OVERRIDE | LATEINIT 
				=> {
					{
					/*InvokeRule memberModifier*/
					recog.base.set_state(3375);
					recog.memberModifier()?;

					}
				}

			 PUBLIC | PRIVATE | PROTECTED | INTERNAL 
				=> {
					{
					/*InvokeRule visibilityModifier*/
					recog.base.set_state(3376);
					recog.visibilityModifier()?;

					}
				}

			 TAILREC | OPERATOR | INLINE | INFIX | EXTERNAL | SUSPEND 
				=> {
					{
					/*InvokeRule functionModifier*/
					recog.base.set_state(3377);
					recog.functionModifier()?;

					}
				}

			 CONST 
				=> {
					{
					/*InvokeRule propertyModifier*/
					recog.base.set_state(3378);
					recog.propertyModifier()?;

					}
				}

			 ABSTRACT | FINAL | OPEN 
				=> {
					{
					/*InvokeRule inheritanceModifier*/
					recog.base.set_state(3379);
					recog.inheritanceModifier()?;

					}
				}

			 VARARG | NOINLINE | CROSSINLINE 
				=> {
					{
					/*InvokeRule parameterModifier*/
					recog.base.set_state(3380);
					recog.parameterModifier()?;

					}
				}

			 EXPECT | ACTUAL 
				=> {
					{
					/*InvokeRule platformModifier*/
					recog.base.set_state(3381);
					recog.platformModifier()?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			recog.base.set_state(3387);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(523,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					recog.base.set_state(3384);
					recog.base.match_token(NL,&mut recog.err_handler)?;

					}
					} 
				}
				recog.base.set_state(3389);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(523,&mut recog.base)?;
			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- typeModifiers ----------------
pub type TypeModifiersContextAll<'input> = TypeModifiersContext<'input>;


pub type TypeModifiersContext<'input> = BaseParserRuleContext<'input,TypeModifiersContextExt<'input>>;

#[derive(Clone)]
pub struct TypeModifiersContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for TypeModifiersContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for TypeModifiersContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_typeModifiers(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_typeModifiers(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for TypeModifiersContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_typeModifiers(self);
	}
}

impl<'input> CustomRuleContext<'input> for TypeModifiersContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_typeModifiers }
	//fn type_rule_index() -> usize where Self: Sized { RULE_typeModifiers }
}
antlr_rust::type_id!{TypeModifiersContextExt<'a>}

impl<'input> TypeModifiersContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<TypeModifiersContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,TypeModifiersContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait TypeModifiersContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<TypeModifiersContextExt<'input>>{

fn typeModifier_all(&self) ->  Vec<Rc<TypeModifierContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn typeModifier(&self, i: usize) -> Option<Rc<TypeModifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> TypeModifiersContextAttrs<'input> for TypeModifiersContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn typeModifiers(&mut self,)
	-> Result<Rc<TypeModifiersContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = TypeModifiersContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 306, RULE_typeModifiers);
        let mut _localctx: Rc<TypeModifiersContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(3391); 
			recog.err_handler.sync(&mut recog.base)?;
			_alt = 1;
			loop {
				match _alt {
				    x if x == 1=>
					{
					{
					/*InvokeRule typeModifier*/
					recog.base.set_state(3390);
					recog.typeModifier()?;

					}
					}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
				}
				recog.base.set_state(3393); 
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(524,&mut recog.base)?;
				if _alt==2 || _alt==INVALID_ALT { break }
			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- typeModifier ----------------
pub type TypeModifierContextAll<'input> = TypeModifierContext<'input>;


pub type TypeModifierContext<'input> = BaseParserRuleContext<'input,TypeModifierContextExt<'input>>;

#[derive(Clone)]
pub struct TypeModifierContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for TypeModifierContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for TypeModifierContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_typeModifier(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_typeModifier(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for TypeModifierContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_typeModifier(self);
	}
}

impl<'input> CustomRuleContext<'input> for TypeModifierContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_typeModifier }
	//fn type_rule_index() -> usize where Self: Sized { RULE_typeModifier }
}
antlr_rust::type_id!{TypeModifierContextExt<'a>}

impl<'input> TypeModifierContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<TypeModifierContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,TypeModifierContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait TypeModifierContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<TypeModifierContextExt<'input>>{

fn annotation(&self) -> Option<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token SUSPEND
/// Returns `None` if there is no child corresponding to token SUSPEND
fn SUSPEND(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(SUSPEND, 0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}

}

impl<'input> TypeModifierContextAttrs<'input> for TypeModifierContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn typeModifier(&mut self,)
	-> Result<Rc<TypeModifierContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = TypeModifierContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 308, RULE_typeModifier);
        let mut _localctx: Rc<TypeModifierContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			recog.base.set_state(3403);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 AT_NO_WS | AT_PRE_WS 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule annotation*/
					recog.base.set_state(3395);
					recog.annotation()?;

					}
				}

			 SUSPEND 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(3396);
					recog.base.match_token(SUSPEND,&mut recog.err_handler)?;

					recog.base.set_state(3400);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(3397);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(3402);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- classModifier ----------------
pub type ClassModifierContextAll<'input> = ClassModifierContext<'input>;


pub type ClassModifierContext<'input> = BaseParserRuleContext<'input,ClassModifierContextExt<'input>>;

#[derive(Clone)]
pub struct ClassModifierContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for ClassModifierContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for ClassModifierContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_classModifier(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_classModifier(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for ClassModifierContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_classModifier(self);
	}
}

impl<'input> CustomRuleContext<'input> for ClassModifierContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_classModifier }
	//fn type_rule_index() -> usize where Self: Sized { RULE_classModifier }
}
antlr_rust::type_id!{ClassModifierContextExt<'a>}

impl<'input> ClassModifierContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ClassModifierContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ClassModifierContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ClassModifierContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<ClassModifierContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token ENUM
/// Returns `None` if there is no child corresponding to token ENUM
fn ENUM(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(ENUM, 0)
}
/// Retrieves first TerminalNode corresponding to token SEALED
/// Returns `None` if there is no child corresponding to token SEALED
fn SEALED(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(SEALED, 0)
}
/// Retrieves first TerminalNode corresponding to token ANNOTATION
/// Returns `None` if there is no child corresponding to token ANNOTATION
fn ANNOTATION(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(ANNOTATION, 0)
}
/// Retrieves first TerminalNode corresponding to token DATA
/// Returns `None` if there is no child corresponding to token DATA
fn DATA(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(DATA, 0)
}
/// Retrieves first TerminalNode corresponding to token INNER
/// Returns `None` if there is no child corresponding to token INNER
fn INNER(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(INNER, 0)
}
/// Retrieves first TerminalNode corresponding to token VALUE
/// Returns `None` if there is no child corresponding to token VALUE
fn VALUE(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(VALUE, 0)
}

}

impl<'input> ClassModifierContextAttrs<'input> for ClassModifierContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn classModifier(&mut self,)
	-> Result<Rc<ClassModifierContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ClassModifierContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 310, RULE_classModifier);
        let mut _localctx: Rc<ClassModifierContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(3405);
			_la = recog.base.input.la(1);
			if { !(((((_la - 113)) & !0x3f) == 0 && ((1usize << (_la - 113)) & ((1usize << (ENUM - 113)) | (1usize << (SEALED - 113)) | (1usize << (ANNOTATION - 113)) | (1usize << (DATA - 113)) | (1usize << (INNER - 113)) | (1usize << (VALUE - 113)))) != 0)) } {
				recog.err_handler.recover_inline(&mut recog.base)?;

			}
			else {
				if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
				recog.err_handler.report_match(&mut recog.base);
				recog.base.consume(&mut recog.err_handler);
			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- memberModifier ----------------
pub type MemberModifierContextAll<'input> = MemberModifierContext<'input>;


pub type MemberModifierContext<'input> = BaseParserRuleContext<'input,MemberModifierContextExt<'input>>;

#[derive(Clone)]
pub struct MemberModifierContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for MemberModifierContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for MemberModifierContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_memberModifier(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_memberModifier(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for MemberModifierContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_memberModifier(self);
	}
}

impl<'input> CustomRuleContext<'input> for MemberModifierContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_memberModifier }
	//fn type_rule_index() -> usize where Self: Sized { RULE_memberModifier }
}
antlr_rust::type_id!{MemberModifierContextExt<'a>}

impl<'input> MemberModifierContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<MemberModifierContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,MemberModifierContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait MemberModifierContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<MemberModifierContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OVERRIDE
/// Returns `None` if there is no child corresponding to token OVERRIDE
fn OVERRIDE(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(OVERRIDE, 0)
}
/// Retrieves first TerminalNode corresponding to token LATEINIT
/// Returns `None` if there is no child corresponding to token LATEINIT
fn LATEINIT(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(LATEINIT, 0)
}

}

impl<'input> MemberModifierContextAttrs<'input> for MemberModifierContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn memberModifier(&mut self,)
	-> Result<Rc<MemberModifierContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = MemberModifierContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 312, RULE_memberModifier);
        let mut _localctx: Rc<MemberModifierContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(3407);
			_la = recog.base.input.la(1);
			if { !(_la==OVERRIDE || _la==LATEINIT) } {
				recog.err_handler.recover_inline(&mut recog.base)?;

			}
			else {
				if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
				recog.err_handler.report_match(&mut recog.base);
				recog.base.consume(&mut recog.err_handler);
			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- visibilityModifier ----------------
pub type VisibilityModifierContextAll<'input> = VisibilityModifierContext<'input>;


pub type VisibilityModifierContext<'input> = BaseParserRuleContext<'input,VisibilityModifierContextExt<'input>>;

#[derive(Clone)]
pub struct VisibilityModifierContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for VisibilityModifierContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for VisibilityModifierContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_visibilityModifier(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_visibilityModifier(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for VisibilityModifierContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_visibilityModifier(self);
	}
}

impl<'input> CustomRuleContext<'input> for VisibilityModifierContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_visibilityModifier }
	//fn type_rule_index() -> usize where Self: Sized { RULE_visibilityModifier }
}
antlr_rust::type_id!{VisibilityModifierContextExt<'a>}

impl<'input> VisibilityModifierContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<VisibilityModifierContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,VisibilityModifierContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait VisibilityModifierContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<VisibilityModifierContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token PUBLIC
/// Returns `None` if there is no child corresponding to token PUBLIC
fn PUBLIC(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(PUBLIC, 0)
}
/// Retrieves first TerminalNode corresponding to token PRIVATE
/// Returns `None` if there is no child corresponding to token PRIVATE
fn PRIVATE(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(PRIVATE, 0)
}
/// Retrieves first TerminalNode corresponding to token INTERNAL
/// Returns `None` if there is no child corresponding to token INTERNAL
fn INTERNAL(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(INTERNAL, 0)
}
/// Retrieves first TerminalNode corresponding to token PROTECTED
/// Returns `None` if there is no child corresponding to token PROTECTED
fn PROTECTED(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(PROTECTED, 0)
}

}

impl<'input> VisibilityModifierContextAttrs<'input> for VisibilityModifierContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn visibilityModifier(&mut self,)
	-> Result<Rc<VisibilityModifierContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = VisibilityModifierContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 314, RULE_visibilityModifier);
        let mut _localctx: Rc<VisibilityModifierContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(3409);
			_la = recog.base.input.la(1);
			if { !(((((_la - 109)) & !0x3f) == 0 && ((1usize << (_la - 109)) & ((1usize << (PUBLIC - 109)) | (1usize << (PRIVATE - 109)) | (1usize << (PROTECTED - 109)) | (1usize << (INTERNAL - 109)))) != 0)) } {
				recog.err_handler.recover_inline(&mut recog.base)?;

			}
			else {
				if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
				recog.err_handler.report_match(&mut recog.base);
				recog.base.consume(&mut recog.err_handler);
			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- varianceModifier ----------------
pub type VarianceModifierContextAll<'input> = VarianceModifierContext<'input>;


pub type VarianceModifierContext<'input> = BaseParserRuleContext<'input,VarianceModifierContextExt<'input>>;

#[derive(Clone)]
pub struct VarianceModifierContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for VarianceModifierContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for VarianceModifierContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_varianceModifier(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_varianceModifier(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for VarianceModifierContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_varianceModifier(self);
	}
}

impl<'input> CustomRuleContext<'input> for VarianceModifierContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_varianceModifier }
	//fn type_rule_index() -> usize where Self: Sized { RULE_varianceModifier }
}
antlr_rust::type_id!{VarianceModifierContextExt<'a>}

impl<'input> VarianceModifierContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<VarianceModifierContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,VarianceModifierContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait VarianceModifierContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<VarianceModifierContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token IN
/// Returns `None` if there is no child corresponding to token IN
fn IN(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(IN, 0)
}
/// Retrieves first TerminalNode corresponding to token OUT
/// Returns `None` if there is no child corresponding to token OUT
fn OUT(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(OUT, 0)
}

}

impl<'input> VarianceModifierContextAttrs<'input> for VarianceModifierContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn varianceModifier(&mut self,)
	-> Result<Rc<VarianceModifierContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = VarianceModifierContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 316, RULE_varianceModifier);
        let mut _localctx: Rc<VarianceModifierContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(3411);
			_la = recog.base.input.la(1);
			if { !(_la==IN || _la==OUT) } {
				recog.err_handler.recover_inline(&mut recog.base)?;

			}
			else {
				if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
				recog.err_handler.report_match(&mut recog.base);
				recog.base.consume(&mut recog.err_handler);
			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- typeParameterModifiers ----------------
pub type TypeParameterModifiersContextAll<'input> = TypeParameterModifiersContext<'input>;


pub type TypeParameterModifiersContext<'input> = BaseParserRuleContext<'input,TypeParameterModifiersContextExt<'input>>;

#[derive(Clone)]
pub struct TypeParameterModifiersContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for TypeParameterModifiersContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for TypeParameterModifiersContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_typeParameterModifiers(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_typeParameterModifiers(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for TypeParameterModifiersContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_typeParameterModifiers(self);
	}
}

impl<'input> CustomRuleContext<'input> for TypeParameterModifiersContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_typeParameterModifiers }
	//fn type_rule_index() -> usize where Self: Sized { RULE_typeParameterModifiers }
}
antlr_rust::type_id!{TypeParameterModifiersContextExt<'a>}

impl<'input> TypeParameterModifiersContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<TypeParameterModifiersContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,TypeParameterModifiersContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait TypeParameterModifiersContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<TypeParameterModifiersContextExt<'input>>{

fn typeParameterModifier_all(&self) ->  Vec<Rc<TypeParameterModifierContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn typeParameterModifier(&self, i: usize) -> Option<Rc<TypeParameterModifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> TypeParameterModifiersContextAttrs<'input> for TypeParameterModifiersContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn typeParameterModifiers(&mut self,)
	-> Result<Rc<TypeParameterModifiersContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = TypeParameterModifiersContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 318, RULE_typeParameterModifiers);
        let mut _localctx: Rc<TypeParameterModifiersContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(3414); 
			recog.err_handler.sync(&mut recog.base)?;
			_alt = 1;
			loop {
				match _alt {
				    x if x == 1=>
					{
					{
					/*InvokeRule typeParameterModifier*/
					recog.base.set_state(3413);
					recog.typeParameterModifier()?;

					}
					}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
				}
				recog.base.set_state(3416); 
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(527,&mut recog.base)?;
				if _alt==2 || _alt==INVALID_ALT { break }
			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- typeParameterModifier ----------------
pub type TypeParameterModifierContextAll<'input> = TypeParameterModifierContext<'input>;


pub type TypeParameterModifierContext<'input> = BaseParserRuleContext<'input,TypeParameterModifierContextExt<'input>>;

#[derive(Clone)]
pub struct TypeParameterModifierContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for TypeParameterModifierContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for TypeParameterModifierContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_typeParameterModifier(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_typeParameterModifier(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for TypeParameterModifierContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_typeParameterModifier(self);
	}
}

impl<'input> CustomRuleContext<'input> for TypeParameterModifierContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_typeParameterModifier }
	//fn type_rule_index() -> usize where Self: Sized { RULE_typeParameterModifier }
}
antlr_rust::type_id!{TypeParameterModifierContextExt<'a>}

impl<'input> TypeParameterModifierContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<TypeParameterModifierContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,TypeParameterModifierContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait TypeParameterModifierContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<TypeParameterModifierContextExt<'input>>{

fn reificationModifier(&self) -> Option<Rc<ReificationModifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}
fn varianceModifier(&self) -> Option<Rc<VarianceModifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn annotation(&self) -> Option<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> TypeParameterModifierContextAttrs<'input> for TypeParameterModifierContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn typeParameterModifier(&mut self,)
	-> Result<Rc<TypeParameterModifierContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = TypeParameterModifierContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 320, RULE_typeParameterModifier);
        let mut _localctx: Rc<TypeParameterModifierContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			let mut _alt: isize;
			recog.base.set_state(3433);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 REIFIED 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule reificationModifier*/
					recog.base.set_state(3418);
					recog.reificationModifier()?;

					recog.base.set_state(3422);
					recog.err_handler.sync(&mut recog.base)?;
					_alt = recog.interpreter.adaptive_predict(528,&mut recog.base)?;
					while { _alt!=2 && _alt!=INVALID_ALT } {
						if _alt==1 {
							{
							{
							recog.base.set_state(3419);
							recog.base.match_token(NL,&mut recog.err_handler)?;

							}
							} 
						}
						recog.base.set_state(3424);
						recog.err_handler.sync(&mut recog.base)?;
						_alt = recog.interpreter.adaptive_predict(528,&mut recog.base)?;
					}
					}
				}

			 IN | OUT 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule varianceModifier*/
					recog.base.set_state(3425);
					recog.varianceModifier()?;

					recog.base.set_state(3429);
					recog.err_handler.sync(&mut recog.base)?;
					_alt = recog.interpreter.adaptive_predict(529,&mut recog.base)?;
					while { _alt!=2 && _alt!=INVALID_ALT } {
						if _alt==1 {
							{
							{
							recog.base.set_state(3426);
							recog.base.match_token(NL,&mut recog.err_handler)?;

							}
							} 
						}
						recog.base.set_state(3431);
						recog.err_handler.sync(&mut recog.base)?;
						_alt = recog.interpreter.adaptive_predict(529,&mut recog.base)?;
					}
					}
				}

			 AT_NO_WS | AT_PRE_WS 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					/*InvokeRule annotation*/
					recog.base.set_state(3432);
					recog.annotation()?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- functionModifier ----------------
pub type FunctionModifierContextAll<'input> = FunctionModifierContext<'input>;


pub type FunctionModifierContext<'input> = BaseParserRuleContext<'input,FunctionModifierContextExt<'input>>;

#[derive(Clone)]
pub struct FunctionModifierContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for FunctionModifierContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for FunctionModifierContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_functionModifier(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_functionModifier(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for FunctionModifierContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_functionModifier(self);
	}
}

impl<'input> CustomRuleContext<'input> for FunctionModifierContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_functionModifier }
	//fn type_rule_index() -> usize where Self: Sized { RULE_functionModifier }
}
antlr_rust::type_id!{FunctionModifierContextExt<'a>}

impl<'input> FunctionModifierContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<FunctionModifierContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,FunctionModifierContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait FunctionModifierContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<FunctionModifierContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token TAILREC
/// Returns `None` if there is no child corresponding to token TAILREC
fn TAILREC(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(TAILREC, 0)
}
/// Retrieves first TerminalNode corresponding to token OPERATOR
/// Returns `None` if there is no child corresponding to token OPERATOR
fn OPERATOR(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(OPERATOR, 0)
}
/// Retrieves first TerminalNode corresponding to token INFIX
/// Returns `None` if there is no child corresponding to token INFIX
fn INFIX(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(INFIX, 0)
}
/// Retrieves first TerminalNode corresponding to token INLINE
/// Returns `None` if there is no child corresponding to token INLINE
fn INLINE(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(INLINE, 0)
}
/// Retrieves first TerminalNode corresponding to token EXTERNAL
/// Returns `None` if there is no child corresponding to token EXTERNAL
fn EXTERNAL(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(EXTERNAL, 0)
}
/// Retrieves first TerminalNode corresponding to token SUSPEND
/// Returns `None` if there is no child corresponding to token SUSPEND
fn SUSPEND(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(SUSPEND, 0)
}

}

impl<'input> FunctionModifierContextAttrs<'input> for FunctionModifierContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn functionModifier(&mut self,)
	-> Result<Rc<FunctionModifierContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = FunctionModifierContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 322, RULE_functionModifier);
        let mut _localctx: Rc<FunctionModifierContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(3435);
			_la = recog.base.input.la(1);
			if { !(((((_la - 119)) & !0x3f) == 0 && ((1usize << (_la - 119)) & ((1usize << (TAILREC - 119)) | (1usize << (OPERATOR - 119)) | (1usize << (INLINE - 119)) | (1usize << (INFIX - 119)) | (1usize << (EXTERNAL - 119)) | (1usize << (SUSPEND - 119)))) != 0)) } {
				recog.err_handler.recover_inline(&mut recog.base)?;

			}
			else {
				if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
				recog.err_handler.report_match(&mut recog.base);
				recog.base.consume(&mut recog.err_handler);
			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- propertyModifier ----------------
pub type PropertyModifierContextAll<'input> = PropertyModifierContext<'input>;


pub type PropertyModifierContext<'input> = BaseParserRuleContext<'input,PropertyModifierContextExt<'input>>;

#[derive(Clone)]
pub struct PropertyModifierContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for PropertyModifierContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for PropertyModifierContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_propertyModifier(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_propertyModifier(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for PropertyModifierContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_propertyModifier(self);
	}
}

impl<'input> CustomRuleContext<'input> for PropertyModifierContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_propertyModifier }
	//fn type_rule_index() -> usize where Self: Sized { RULE_propertyModifier }
}
antlr_rust::type_id!{PropertyModifierContextExt<'a>}

impl<'input> PropertyModifierContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<PropertyModifierContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,PropertyModifierContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait PropertyModifierContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<PropertyModifierContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token CONST
/// Returns `None` if there is no child corresponding to token CONST
fn CONST(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(CONST, 0)
}

}

impl<'input> PropertyModifierContextAttrs<'input> for PropertyModifierContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn propertyModifier(&mut self,)
	-> Result<Rc<PropertyModifierContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = PropertyModifierContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 324, RULE_propertyModifier);
        let mut _localctx: Rc<PropertyModifierContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(3437);
			recog.base.match_token(CONST,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- inheritanceModifier ----------------
pub type InheritanceModifierContextAll<'input> = InheritanceModifierContext<'input>;


pub type InheritanceModifierContext<'input> = BaseParserRuleContext<'input,InheritanceModifierContextExt<'input>>;

#[derive(Clone)]
pub struct InheritanceModifierContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for InheritanceModifierContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for InheritanceModifierContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_inheritanceModifier(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_inheritanceModifier(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for InheritanceModifierContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_inheritanceModifier(self);
	}
}

impl<'input> CustomRuleContext<'input> for InheritanceModifierContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_inheritanceModifier }
	//fn type_rule_index() -> usize where Self: Sized { RULE_inheritanceModifier }
}
antlr_rust::type_id!{InheritanceModifierContextExt<'a>}

impl<'input> InheritanceModifierContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<InheritanceModifierContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,InheritanceModifierContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait InheritanceModifierContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<InheritanceModifierContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token ABSTRACT
/// Returns `None` if there is no child corresponding to token ABSTRACT
fn ABSTRACT(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(ABSTRACT, 0)
}
/// Retrieves first TerminalNode corresponding to token FINAL
/// Returns `None` if there is no child corresponding to token FINAL
fn FINAL(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(FINAL, 0)
}
/// Retrieves first TerminalNode corresponding to token OPEN
/// Returns `None` if there is no child corresponding to token OPEN
fn OPEN(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(OPEN, 0)
}

}

impl<'input> InheritanceModifierContextAttrs<'input> for InheritanceModifierContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn inheritanceModifier(&mut self,)
	-> Result<Rc<InheritanceModifierContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = InheritanceModifierContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 326, RULE_inheritanceModifier);
        let mut _localctx: Rc<InheritanceModifierContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(3439);
			_la = recog.base.input.la(1);
			if { !(((((_la - 126)) & !0x3f) == 0 && ((1usize << (_la - 126)) & ((1usize << (ABSTRACT - 126)) | (1usize << (FINAL - 126)) | (1usize << (OPEN - 126)))) != 0)) } {
				recog.err_handler.recover_inline(&mut recog.base)?;

			}
			else {
				if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
				recog.err_handler.report_match(&mut recog.base);
				recog.base.consume(&mut recog.err_handler);
			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- parameterModifier ----------------
pub type ParameterModifierContextAll<'input> = ParameterModifierContext<'input>;


pub type ParameterModifierContext<'input> = BaseParserRuleContext<'input,ParameterModifierContextExt<'input>>;

#[derive(Clone)]
pub struct ParameterModifierContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for ParameterModifierContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for ParameterModifierContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_parameterModifier(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_parameterModifier(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for ParameterModifierContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_parameterModifier(self);
	}
}

impl<'input> CustomRuleContext<'input> for ParameterModifierContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_parameterModifier }
	//fn type_rule_index() -> usize where Self: Sized { RULE_parameterModifier }
}
antlr_rust::type_id!{ParameterModifierContextExt<'a>}

impl<'input> ParameterModifierContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ParameterModifierContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ParameterModifierContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ParameterModifierContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<ParameterModifierContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token VARARG
/// Returns `None` if there is no child corresponding to token VARARG
fn VARARG(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(VARARG, 0)
}
/// Retrieves first TerminalNode corresponding to token NOINLINE
/// Returns `None` if there is no child corresponding to token NOINLINE
fn NOINLINE(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NOINLINE, 0)
}
/// Retrieves first TerminalNode corresponding to token CROSSINLINE
/// Returns `None` if there is no child corresponding to token CROSSINLINE
fn CROSSINLINE(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(CROSSINLINE, 0)
}

}

impl<'input> ParameterModifierContextAttrs<'input> for ParameterModifierContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn parameterModifier(&mut self,)
	-> Result<Rc<ParameterModifierContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ParameterModifierContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 328, RULE_parameterModifier);
        let mut _localctx: Rc<ParameterModifierContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(3441);
			_la = recog.base.input.la(1);
			if { !(((((_la - 131)) & !0x3f) == 0 && ((1usize << (_la - 131)) & ((1usize << (VARARG - 131)) | (1usize << (NOINLINE - 131)) | (1usize << (CROSSINLINE - 131)))) != 0)) } {
				recog.err_handler.recover_inline(&mut recog.base)?;

			}
			else {
				if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
				recog.err_handler.report_match(&mut recog.base);
				recog.base.consume(&mut recog.err_handler);
			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- reificationModifier ----------------
pub type ReificationModifierContextAll<'input> = ReificationModifierContext<'input>;


pub type ReificationModifierContext<'input> = BaseParserRuleContext<'input,ReificationModifierContextExt<'input>>;

#[derive(Clone)]
pub struct ReificationModifierContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for ReificationModifierContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for ReificationModifierContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_reificationModifier(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_reificationModifier(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for ReificationModifierContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_reificationModifier(self);
	}
}

impl<'input> CustomRuleContext<'input> for ReificationModifierContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_reificationModifier }
	//fn type_rule_index() -> usize where Self: Sized { RULE_reificationModifier }
}
antlr_rust::type_id!{ReificationModifierContextExt<'a>}

impl<'input> ReificationModifierContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ReificationModifierContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ReificationModifierContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ReificationModifierContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<ReificationModifierContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token REIFIED
/// Returns `None` if there is no child corresponding to token REIFIED
fn REIFIED(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(REIFIED, 0)
}

}

impl<'input> ReificationModifierContextAttrs<'input> for ReificationModifierContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn reificationModifier(&mut self,)
	-> Result<Rc<ReificationModifierContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ReificationModifierContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 330, RULE_reificationModifier);
        let mut _localctx: Rc<ReificationModifierContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(3443);
			recog.base.match_token(REIFIED,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- platformModifier ----------------
pub type PlatformModifierContextAll<'input> = PlatformModifierContext<'input>;


pub type PlatformModifierContext<'input> = BaseParserRuleContext<'input,PlatformModifierContextExt<'input>>;

#[derive(Clone)]
pub struct PlatformModifierContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for PlatformModifierContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for PlatformModifierContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_platformModifier(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_platformModifier(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for PlatformModifierContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_platformModifier(self);
	}
}

impl<'input> CustomRuleContext<'input> for PlatformModifierContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_platformModifier }
	//fn type_rule_index() -> usize where Self: Sized { RULE_platformModifier }
}
antlr_rust::type_id!{PlatformModifierContextExt<'a>}

impl<'input> PlatformModifierContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<PlatformModifierContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,PlatformModifierContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait PlatformModifierContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<PlatformModifierContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token EXPECT
/// Returns `None` if there is no child corresponding to token EXPECT
fn EXPECT(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(EXPECT, 0)
}
/// Retrieves first TerminalNode corresponding to token ACTUAL
/// Returns `None` if there is no child corresponding to token ACTUAL
fn ACTUAL(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(ACTUAL, 0)
}

}

impl<'input> PlatformModifierContextAttrs<'input> for PlatformModifierContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn platformModifier(&mut self,)
	-> Result<Rc<PlatformModifierContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = PlatformModifierContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 332, RULE_platformModifier);
        let mut _localctx: Rc<PlatformModifierContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(3445);
			_la = recog.base.input.la(1);
			if { !(_la==EXPECT || _la==ACTUAL) } {
				recog.err_handler.recover_inline(&mut recog.base)?;

			}
			else {
				if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
				recog.err_handler.report_match(&mut recog.base);
				recog.base.consume(&mut recog.err_handler);
			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- annotation ----------------
pub type AnnotationContextAll<'input> = AnnotationContext<'input>;


pub type AnnotationContext<'input> = BaseParserRuleContext<'input,AnnotationContextExt<'input>>;

#[derive(Clone)]
pub struct AnnotationContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for AnnotationContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for AnnotationContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_annotation(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_annotation(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for AnnotationContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_annotation(self);
	}
}

impl<'input> CustomRuleContext<'input> for AnnotationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_annotation }
	//fn type_rule_index() -> usize where Self: Sized { RULE_annotation }
}
antlr_rust::type_id!{AnnotationContextExt<'a>}

impl<'input> AnnotationContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AnnotationContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AnnotationContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AnnotationContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<AnnotationContextExt<'input>>{

fn singleAnnotation(&self) -> Option<Rc<SingleAnnotationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn multiAnnotation(&self) -> Option<Rc<MultiAnnotationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}

}

impl<'input> AnnotationContextAttrs<'input> for AnnotationContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn annotation(&mut self,)
	-> Result<Rc<AnnotationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AnnotationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 334, RULE_annotation);
        let mut _localctx: Rc<AnnotationContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(3449);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(531,&mut recog.base)? {
				1 =>{
					{
					/*InvokeRule singleAnnotation*/
					recog.base.set_state(3447);
					recog.singleAnnotation()?;

					}
				}
			,
				2 =>{
					{
					/*InvokeRule multiAnnotation*/
					recog.base.set_state(3448);
					recog.multiAnnotation()?;

					}
				}

				_ => {}
			}
			recog.base.set_state(3454);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(532,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					recog.base.set_state(3451);
					recog.base.match_token(NL,&mut recog.err_handler)?;

					}
					} 
				}
				recog.base.set_state(3456);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(532,&mut recog.base)?;
			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- singleAnnotation ----------------
pub type SingleAnnotationContextAll<'input> = SingleAnnotationContext<'input>;


pub type SingleAnnotationContext<'input> = BaseParserRuleContext<'input,SingleAnnotationContextExt<'input>>;

#[derive(Clone)]
pub struct SingleAnnotationContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for SingleAnnotationContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for SingleAnnotationContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_singleAnnotation(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_singleAnnotation(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for SingleAnnotationContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_singleAnnotation(self);
	}
}

impl<'input> CustomRuleContext<'input> for SingleAnnotationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_singleAnnotation }
	//fn type_rule_index() -> usize where Self: Sized { RULE_singleAnnotation }
}
antlr_rust::type_id!{SingleAnnotationContextExt<'a>}

impl<'input> SingleAnnotationContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<SingleAnnotationContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,SingleAnnotationContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait SingleAnnotationContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<SingleAnnotationContextExt<'input>>{

fn unescapedAnnotation(&self) -> Option<Rc<UnescapedAnnotationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn annotationUseSiteTarget(&self) -> Option<Rc<AnnotationUseSiteTargetContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token AT_NO_WS
/// Returns `None` if there is no child corresponding to token AT_NO_WS
fn AT_NO_WS(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(AT_NO_WS, 0)
}
/// Retrieves first TerminalNode corresponding to token AT_PRE_WS
/// Returns `None` if there is no child corresponding to token AT_PRE_WS
fn AT_PRE_WS(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(AT_PRE_WS, 0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}

}

impl<'input> SingleAnnotationContextAttrs<'input> for SingleAnnotationContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn singleAnnotation(&mut self,)
	-> Result<Rc<SingleAnnotationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = SingleAnnotationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 336, RULE_singleAnnotation);
        let mut _localctx: Rc<SingleAnnotationContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(3466);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(534,&mut recog.base)? {
				1 =>{
					{
					/*InvokeRule annotationUseSiteTarget*/
					recog.base.set_state(3457);
					recog.annotationUseSiteTarget()?;

					recog.base.set_state(3461);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(3458);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(3463);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					}
				}
			,
				2 =>{
					{
					recog.base.set_state(3464);
					recog.base.match_token(AT_NO_WS,&mut recog.err_handler)?;

					}
				}
			,
				3 =>{
					{
					recog.base.set_state(3465);
					recog.base.match_token(AT_PRE_WS,&mut recog.err_handler)?;

					}
				}

				_ => {}
			}
			/*InvokeRule unescapedAnnotation*/
			recog.base.set_state(3468);
			recog.unescapedAnnotation()?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- multiAnnotation ----------------
pub type MultiAnnotationContextAll<'input> = MultiAnnotationContext<'input>;


pub type MultiAnnotationContext<'input> = BaseParserRuleContext<'input,MultiAnnotationContextExt<'input>>;

#[derive(Clone)]
pub struct MultiAnnotationContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for MultiAnnotationContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for MultiAnnotationContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_multiAnnotation(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_multiAnnotation(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for MultiAnnotationContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_multiAnnotation(self);
	}
}

impl<'input> CustomRuleContext<'input> for MultiAnnotationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_multiAnnotation }
	//fn type_rule_index() -> usize where Self: Sized { RULE_multiAnnotation }
}
antlr_rust::type_id!{MultiAnnotationContextExt<'a>}

impl<'input> MultiAnnotationContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<MultiAnnotationContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,MultiAnnotationContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait MultiAnnotationContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<MultiAnnotationContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token LSQUARE
/// Returns `None` if there is no child corresponding to token LSQUARE
fn LSQUARE(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(LSQUARE, 0)
}
/// Retrieves first TerminalNode corresponding to token RSQUARE
/// Returns `None` if there is no child corresponding to token RSQUARE
fn RSQUARE(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(RSQUARE, 0)
}
fn annotationUseSiteTarget(&self) -> Option<Rc<AnnotationUseSiteTargetContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token AT_NO_WS
/// Returns `None` if there is no child corresponding to token AT_NO_WS
fn AT_NO_WS(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(AT_NO_WS, 0)
}
/// Retrieves first TerminalNode corresponding to token AT_PRE_WS
/// Returns `None` if there is no child corresponding to token AT_PRE_WS
fn AT_PRE_WS(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(AT_PRE_WS, 0)
}
fn unescapedAnnotation_all(&self) ->  Vec<Rc<UnescapedAnnotationContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn unescapedAnnotation(&self, i: usize) -> Option<Rc<UnescapedAnnotationContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}

}

impl<'input> MultiAnnotationContextAttrs<'input> for MultiAnnotationContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn multiAnnotation(&mut self,)
	-> Result<Rc<MultiAnnotationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = MultiAnnotationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 338, RULE_multiAnnotation);
        let mut _localctx: Rc<MultiAnnotationContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(3479);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(536,&mut recog.base)? {
				1 =>{
					{
					/*InvokeRule annotationUseSiteTarget*/
					recog.base.set_state(3470);
					recog.annotationUseSiteTarget()?;

					recog.base.set_state(3474);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(3471);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(3476);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					}
				}
			,
				2 =>{
					{
					recog.base.set_state(3477);
					recog.base.match_token(AT_NO_WS,&mut recog.err_handler)?;

					}
				}
			,
				3 =>{
					{
					recog.base.set_state(3478);
					recog.base.match_token(AT_PRE_WS,&mut recog.err_handler)?;

					}
				}

				_ => {}
			}
			recog.base.set_state(3481);
			recog.base.match_token(LSQUARE,&mut recog.err_handler)?;

			recog.base.set_state(3483); 
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			loop {
				{
				{
				/*InvokeRule unescapedAnnotation*/
				recog.base.set_state(3482);
				recog.unescapedAnnotation()?;

				}
				}
				recog.base.set_state(3485); 
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
				if !(((((_la - 63)) & !0x3f) == 0 && ((1usize << (_la - 63)) & ((1usize << (FILE - 63)) | (1usize << (FIELD - 63)) | (1usize << (PROPERTY - 63)) | (1usize << (GET - 63)) | (1usize << (SET - 63)) | (1usize << (RECEIVER - 63)) | (1usize << (PARAM - 63)) | (1usize << (SETPARAM - 63)) | (1usize << (DELEGATE - 63)) | (1usize << (IMPORT - 63)) | (1usize << (CONSTRUCTOR - 63)) | (1usize << (BY - 63)) | (1usize << (COMPANION - 63)) | (1usize << (INIT - 63)) | (1usize << (WHERE - 63)) | (1usize << (CATCH - 63)) | (1usize << (FINALLY - 63)) | (1usize << (OUT - 63)) | (1usize << (DYNAMIC - 63)) | (1usize << (PUBLIC - 63)) | (1usize << (PRIVATE - 63)) | (1usize << (PROTECTED - 63)) | (1usize << (INTERNAL - 63)) | (1usize << (ENUM - 63)) | (1usize << (SEALED - 63)) | (1usize << (ANNOTATION - 63)) | (1usize << (DATA - 63)) | (1usize << (INNER - 63)) | (1usize << (VALUE - 63)) | (1usize << (TAILREC - 63)) | (1usize << (OPERATOR - 63)) | (1usize << (INLINE - 63)) | (1usize << (INFIX - 63)) | (1usize << (EXTERNAL - 63)) | (1usize << (SUSPEND - 63)) | (1usize << (OVERRIDE - 63)) | (1usize << (ABSTRACT - 63)))) != 0) || ((((_la - 127)) & !0x3f) == 0 && ((1usize << (_la - 127)) & ((1usize << (FINAL - 127)) | (1usize << (OPEN - 127)) | (1usize << (CONST - 127)) | (1usize << (LATEINIT - 127)) | (1usize << (VARARG - 127)) | (1usize << (NOINLINE - 127)) | (1usize << (CROSSINLINE - 127)) | (1usize << (REIFIED - 127)) | (1usize << (EXPECT - 127)) | (1usize << (ACTUAL - 127)) | (1usize << (Identifier - 127)))) != 0)) {break}
			}
			recog.base.set_state(3487);
			recog.base.match_token(RSQUARE,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- annotationUseSiteTarget ----------------
pub type AnnotationUseSiteTargetContextAll<'input> = AnnotationUseSiteTargetContext<'input>;


pub type AnnotationUseSiteTargetContext<'input> = BaseParserRuleContext<'input,AnnotationUseSiteTargetContextExt<'input>>;

#[derive(Clone)]
pub struct AnnotationUseSiteTargetContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for AnnotationUseSiteTargetContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for AnnotationUseSiteTargetContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_annotationUseSiteTarget(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_annotationUseSiteTarget(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for AnnotationUseSiteTargetContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_annotationUseSiteTarget(self);
	}
}

impl<'input> CustomRuleContext<'input> for AnnotationUseSiteTargetContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_annotationUseSiteTarget }
	//fn type_rule_index() -> usize where Self: Sized { RULE_annotationUseSiteTarget }
}
antlr_rust::type_id!{AnnotationUseSiteTargetContextExt<'a>}

impl<'input> AnnotationUseSiteTargetContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AnnotationUseSiteTargetContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AnnotationUseSiteTargetContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AnnotationUseSiteTargetContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<AnnotationUseSiteTargetContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token COLON
/// Returns `None` if there is no child corresponding to token COLON
fn COLON(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(COLON, 0)
}
/// Retrieves first TerminalNode corresponding to token AT_NO_WS
/// Returns `None` if there is no child corresponding to token AT_NO_WS
fn AT_NO_WS(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(AT_NO_WS, 0)
}
/// Retrieves first TerminalNode corresponding to token AT_PRE_WS
/// Returns `None` if there is no child corresponding to token AT_PRE_WS
fn AT_PRE_WS(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(AT_PRE_WS, 0)
}
/// Retrieves first TerminalNode corresponding to token FIELD
/// Returns `None` if there is no child corresponding to token FIELD
fn FIELD(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(FIELD, 0)
}
/// Retrieves first TerminalNode corresponding to token PROPERTY
/// Returns `None` if there is no child corresponding to token PROPERTY
fn PROPERTY(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(PROPERTY, 0)
}
/// Retrieves first TerminalNode corresponding to token GET
/// Returns `None` if there is no child corresponding to token GET
fn GET(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(GET, 0)
}
/// Retrieves first TerminalNode corresponding to token SET
/// Returns `None` if there is no child corresponding to token SET
fn SET(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(SET, 0)
}
/// Retrieves first TerminalNode corresponding to token RECEIVER
/// Returns `None` if there is no child corresponding to token RECEIVER
fn RECEIVER(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(RECEIVER, 0)
}
/// Retrieves first TerminalNode corresponding to token PARAM
/// Returns `None` if there is no child corresponding to token PARAM
fn PARAM(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(PARAM, 0)
}
/// Retrieves first TerminalNode corresponding to token SETPARAM
/// Returns `None` if there is no child corresponding to token SETPARAM
fn SETPARAM(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(SETPARAM, 0)
}
/// Retrieves first TerminalNode corresponding to token DELEGATE
/// Returns `None` if there is no child corresponding to token DELEGATE
fn DELEGATE(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(DELEGATE, 0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}

}

impl<'input> AnnotationUseSiteTargetContextAttrs<'input> for AnnotationUseSiteTargetContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn annotationUseSiteTarget(&mut self,)
	-> Result<Rc<AnnotationUseSiteTargetContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AnnotationUseSiteTargetContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 340, RULE_annotationUseSiteTarget);
        let mut _localctx: Rc<AnnotationUseSiteTargetContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(3489);
			_la = recog.base.input.la(1);
			if { !(_la==AT_NO_WS || _la==AT_PRE_WS) } {
				recog.err_handler.recover_inline(&mut recog.base)?;

			}
			else {
				if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
				recog.err_handler.report_match(&mut recog.base);
				recog.base.consume(&mut recog.err_handler);
			}
			recog.base.set_state(3490);
			_la = recog.base.input.la(1);
			if { !(((((_la - 64)) & !0x3f) == 0 && ((1usize << (_la - 64)) & ((1usize << (FIELD - 64)) | (1usize << (PROPERTY - 64)) | (1usize << (GET - 64)) | (1usize << (SET - 64)) | (1usize << (RECEIVER - 64)) | (1usize << (PARAM - 64)) | (1usize << (SETPARAM - 64)) | (1usize << (DELEGATE - 64)))) != 0)) } {
				recog.err_handler.recover_inline(&mut recog.base)?;

			}
			else {
				if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
				recog.err_handler.report_match(&mut recog.base);
				recog.base.consume(&mut recog.err_handler);
			}
			recog.base.set_state(3494);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(3491);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(3496);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(3497);
			recog.base.match_token(COLON,&mut recog.err_handler)?;

			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- unescapedAnnotation ----------------
pub type UnescapedAnnotationContextAll<'input> = UnescapedAnnotationContext<'input>;


pub type UnescapedAnnotationContext<'input> = BaseParserRuleContext<'input,UnescapedAnnotationContextExt<'input>>;

#[derive(Clone)]
pub struct UnescapedAnnotationContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for UnescapedAnnotationContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for UnescapedAnnotationContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_unescapedAnnotation(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_unescapedAnnotation(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for UnescapedAnnotationContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_unescapedAnnotation(self);
	}
}

impl<'input> CustomRuleContext<'input> for UnescapedAnnotationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_unescapedAnnotation }
	//fn type_rule_index() -> usize where Self: Sized { RULE_unescapedAnnotation }
}
antlr_rust::type_id!{UnescapedAnnotationContextExt<'a>}

impl<'input> UnescapedAnnotationContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<UnescapedAnnotationContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,UnescapedAnnotationContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait UnescapedAnnotationContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<UnescapedAnnotationContextExt<'input>>{

fn constructorInvocation(&self) -> Option<Rc<ConstructorInvocationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn userType(&self) -> Option<Rc<UserTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> UnescapedAnnotationContextAttrs<'input> for UnescapedAnnotationContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn unescapedAnnotation(&mut self,)
	-> Result<Rc<UnescapedAnnotationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = UnescapedAnnotationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 342, RULE_unescapedAnnotation);
        let mut _localctx: Rc<UnescapedAnnotationContextAll> = _localctx;
		let result: Result<(), ANTLRError> = try {

			recog.base.set_state(3501);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(539,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule constructorInvocation*/
					recog.base.set_state(3499);
					recog.constructorInvocation()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule userType*/
					recog.base.set_state(3500);
					recog.userType()?;

					}
				}

				_ => {}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- simpleIdentifier ----------------
pub type SimpleIdentifierContextAll<'input> = SimpleIdentifierContext<'input>;


pub type SimpleIdentifierContext<'input> = BaseParserRuleContext<'input,SimpleIdentifierContextExt<'input>>;

#[derive(Clone)]
pub struct SimpleIdentifierContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for SimpleIdentifierContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for SimpleIdentifierContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_simpleIdentifier(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_simpleIdentifier(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for SimpleIdentifierContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_simpleIdentifier(self);
	}
}

impl<'input> CustomRuleContext<'input> for SimpleIdentifierContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_simpleIdentifier }
	//fn type_rule_index() -> usize where Self: Sized { RULE_simpleIdentifier }
}
antlr_rust::type_id!{SimpleIdentifierContextExt<'a>}

impl<'input> SimpleIdentifierContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<SimpleIdentifierContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,SimpleIdentifierContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait SimpleIdentifierContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<SimpleIdentifierContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token Identifier
/// Returns `None` if there is no child corresponding to token Identifier
fn Identifier(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(Identifier, 0)
}
/// Retrieves first TerminalNode corresponding to token ABSTRACT
/// Returns `None` if there is no child corresponding to token ABSTRACT
fn ABSTRACT(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(ABSTRACT, 0)
}
/// Retrieves first TerminalNode corresponding to token ANNOTATION
/// Returns `None` if there is no child corresponding to token ANNOTATION
fn ANNOTATION(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(ANNOTATION, 0)
}
/// Retrieves first TerminalNode corresponding to token BY
/// Returns `None` if there is no child corresponding to token BY
fn BY(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(BY, 0)
}
/// Retrieves first TerminalNode corresponding to token CATCH
/// Returns `None` if there is no child corresponding to token CATCH
fn CATCH(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(CATCH, 0)
}
/// Retrieves first TerminalNode corresponding to token COMPANION
/// Returns `None` if there is no child corresponding to token COMPANION
fn COMPANION(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(COMPANION, 0)
}
/// Retrieves first TerminalNode corresponding to token CONSTRUCTOR
/// Returns `None` if there is no child corresponding to token CONSTRUCTOR
fn CONSTRUCTOR(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(CONSTRUCTOR, 0)
}
/// Retrieves first TerminalNode corresponding to token CROSSINLINE
/// Returns `None` if there is no child corresponding to token CROSSINLINE
fn CROSSINLINE(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(CROSSINLINE, 0)
}
/// Retrieves first TerminalNode corresponding to token DATA
/// Returns `None` if there is no child corresponding to token DATA
fn DATA(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(DATA, 0)
}
/// Retrieves first TerminalNode corresponding to token DYNAMIC
/// Returns `None` if there is no child corresponding to token DYNAMIC
fn DYNAMIC(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(DYNAMIC, 0)
}
/// Retrieves first TerminalNode corresponding to token ENUM
/// Returns `None` if there is no child corresponding to token ENUM
fn ENUM(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(ENUM, 0)
}
/// Retrieves first TerminalNode corresponding to token EXTERNAL
/// Returns `None` if there is no child corresponding to token EXTERNAL
fn EXTERNAL(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(EXTERNAL, 0)
}
/// Retrieves first TerminalNode corresponding to token FINAL
/// Returns `None` if there is no child corresponding to token FINAL
fn FINAL(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(FINAL, 0)
}
/// Retrieves first TerminalNode corresponding to token FINALLY
/// Returns `None` if there is no child corresponding to token FINALLY
fn FINALLY(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(FINALLY, 0)
}
/// Retrieves first TerminalNode corresponding to token GET
/// Returns `None` if there is no child corresponding to token GET
fn GET(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(GET, 0)
}
/// Retrieves first TerminalNode corresponding to token IMPORT
/// Returns `None` if there is no child corresponding to token IMPORT
fn IMPORT(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(IMPORT, 0)
}
/// Retrieves first TerminalNode corresponding to token INFIX
/// Returns `None` if there is no child corresponding to token INFIX
fn INFIX(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(INFIX, 0)
}
/// Retrieves first TerminalNode corresponding to token INIT
/// Returns `None` if there is no child corresponding to token INIT
fn INIT(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(INIT, 0)
}
/// Retrieves first TerminalNode corresponding to token INLINE
/// Returns `None` if there is no child corresponding to token INLINE
fn INLINE(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(INLINE, 0)
}
/// Retrieves first TerminalNode corresponding to token INNER
/// Returns `None` if there is no child corresponding to token INNER
fn INNER(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(INNER, 0)
}
/// Retrieves first TerminalNode corresponding to token INTERNAL
/// Returns `None` if there is no child corresponding to token INTERNAL
fn INTERNAL(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(INTERNAL, 0)
}
/// Retrieves first TerminalNode corresponding to token LATEINIT
/// Returns `None` if there is no child corresponding to token LATEINIT
fn LATEINIT(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(LATEINIT, 0)
}
/// Retrieves first TerminalNode corresponding to token NOINLINE
/// Returns `None` if there is no child corresponding to token NOINLINE
fn NOINLINE(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NOINLINE, 0)
}
/// Retrieves first TerminalNode corresponding to token OPEN
/// Returns `None` if there is no child corresponding to token OPEN
fn OPEN(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(OPEN, 0)
}
/// Retrieves first TerminalNode corresponding to token OPERATOR
/// Returns `None` if there is no child corresponding to token OPERATOR
fn OPERATOR(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(OPERATOR, 0)
}
/// Retrieves first TerminalNode corresponding to token OUT
/// Returns `None` if there is no child corresponding to token OUT
fn OUT(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(OUT, 0)
}
/// Retrieves first TerminalNode corresponding to token OVERRIDE
/// Returns `None` if there is no child corresponding to token OVERRIDE
fn OVERRIDE(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(OVERRIDE, 0)
}
/// Retrieves first TerminalNode corresponding to token PRIVATE
/// Returns `None` if there is no child corresponding to token PRIVATE
fn PRIVATE(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(PRIVATE, 0)
}
/// Retrieves first TerminalNode corresponding to token PROTECTED
/// Returns `None` if there is no child corresponding to token PROTECTED
fn PROTECTED(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(PROTECTED, 0)
}
/// Retrieves first TerminalNode corresponding to token PUBLIC
/// Returns `None` if there is no child corresponding to token PUBLIC
fn PUBLIC(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(PUBLIC, 0)
}
/// Retrieves first TerminalNode corresponding to token REIFIED
/// Returns `None` if there is no child corresponding to token REIFIED
fn REIFIED(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(REIFIED, 0)
}
/// Retrieves first TerminalNode corresponding to token SEALED
/// Returns `None` if there is no child corresponding to token SEALED
fn SEALED(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(SEALED, 0)
}
/// Retrieves first TerminalNode corresponding to token TAILREC
/// Returns `None` if there is no child corresponding to token TAILREC
fn TAILREC(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(TAILREC, 0)
}
/// Retrieves first TerminalNode corresponding to token SET
/// Returns `None` if there is no child corresponding to token SET
fn SET(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(SET, 0)
}
/// Retrieves first TerminalNode corresponding to token VARARG
/// Returns `None` if there is no child corresponding to token VARARG
fn VARARG(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(VARARG, 0)
}
/// Retrieves first TerminalNode corresponding to token WHERE
/// Returns `None` if there is no child corresponding to token WHERE
fn WHERE(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(WHERE, 0)
}
/// Retrieves first TerminalNode corresponding to token FIELD
/// Returns `None` if there is no child corresponding to token FIELD
fn FIELD(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(FIELD, 0)
}
/// Retrieves first TerminalNode corresponding to token PROPERTY
/// Returns `None` if there is no child corresponding to token PROPERTY
fn PROPERTY(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(PROPERTY, 0)
}
/// Retrieves first TerminalNode corresponding to token RECEIVER
/// Returns `None` if there is no child corresponding to token RECEIVER
fn RECEIVER(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(RECEIVER, 0)
}
/// Retrieves first TerminalNode corresponding to token PARAM
/// Returns `None` if there is no child corresponding to token PARAM
fn PARAM(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(PARAM, 0)
}
/// Retrieves first TerminalNode corresponding to token SETPARAM
/// Returns `None` if there is no child corresponding to token SETPARAM
fn SETPARAM(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(SETPARAM, 0)
}
/// Retrieves first TerminalNode corresponding to token DELEGATE
/// Returns `None` if there is no child corresponding to token DELEGATE
fn DELEGATE(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(DELEGATE, 0)
}
/// Retrieves first TerminalNode corresponding to token FILE
/// Returns `None` if there is no child corresponding to token FILE
fn FILE(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(FILE, 0)
}
/// Retrieves first TerminalNode corresponding to token EXPECT
/// Returns `None` if there is no child corresponding to token EXPECT
fn EXPECT(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(EXPECT, 0)
}
/// Retrieves first TerminalNode corresponding to token ACTUAL
/// Returns `None` if there is no child corresponding to token ACTUAL
fn ACTUAL(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(ACTUAL, 0)
}
/// Retrieves first TerminalNode corresponding to token CONST
/// Returns `None` if there is no child corresponding to token CONST
fn CONST(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(CONST, 0)
}
/// Retrieves first TerminalNode corresponding to token SUSPEND
/// Returns `None` if there is no child corresponding to token SUSPEND
fn SUSPEND(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(SUSPEND, 0)
}
/// Retrieves first TerminalNode corresponding to token VALUE
/// Returns `None` if there is no child corresponding to token VALUE
fn VALUE(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(VALUE, 0)
}

}

impl<'input> SimpleIdentifierContextAttrs<'input> for SimpleIdentifierContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn simpleIdentifier(&mut self,)
	-> Result<Rc<SimpleIdentifierContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = SimpleIdentifierContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 344, RULE_simpleIdentifier);
        let mut _localctx: Rc<SimpleIdentifierContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(3503);
			_la = recog.base.input.la(1);
			if { !(((((_la - 63)) & !0x3f) == 0 && ((1usize << (_la - 63)) & ((1usize << (FILE - 63)) | (1usize << (FIELD - 63)) | (1usize << (PROPERTY - 63)) | (1usize << (GET - 63)) | (1usize << (SET - 63)) | (1usize << (RECEIVER - 63)) | (1usize << (PARAM - 63)) | (1usize << (SETPARAM - 63)) | (1usize << (DELEGATE - 63)) | (1usize << (IMPORT - 63)) | (1usize << (CONSTRUCTOR - 63)) | (1usize << (BY - 63)) | (1usize << (COMPANION - 63)) | (1usize << (INIT - 63)) | (1usize << (WHERE - 63)) | (1usize << (CATCH - 63)) | (1usize << (FINALLY - 63)) | (1usize << (OUT - 63)) | (1usize << (DYNAMIC - 63)) | (1usize << (PUBLIC - 63)) | (1usize << (PRIVATE - 63)) | (1usize << (PROTECTED - 63)) | (1usize << (INTERNAL - 63)) | (1usize << (ENUM - 63)) | (1usize << (SEALED - 63)) | (1usize << (ANNOTATION - 63)) | (1usize << (DATA - 63)) | (1usize << (INNER - 63)) | (1usize << (VALUE - 63)) | (1usize << (TAILREC - 63)) | (1usize << (OPERATOR - 63)) | (1usize << (INLINE - 63)) | (1usize << (INFIX - 63)) | (1usize << (EXTERNAL - 63)) | (1usize << (SUSPEND - 63)) | (1usize << (OVERRIDE - 63)) | (1usize << (ABSTRACT - 63)))) != 0) || ((((_la - 127)) & !0x3f) == 0 && ((1usize << (_la - 127)) & ((1usize << (FINAL - 127)) | (1usize << (OPEN - 127)) | (1usize << (CONST - 127)) | (1usize << (LATEINIT - 127)) | (1usize << (VARARG - 127)) | (1usize << (NOINLINE - 127)) | (1usize << (CROSSINLINE - 127)) | (1usize << (REIFIED - 127)) | (1usize << (EXPECT - 127)) | (1usize << (ACTUAL - 127)) | (1usize << (Identifier - 127)))) != 0)) } {
				recog.err_handler.recover_inline(&mut recog.base)?;

			}
			else {
				if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
				recog.err_handler.report_match(&mut recog.base);
				recog.base.consume(&mut recog.err_handler);
			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- identifier ----------------
pub type IdentifierContextAll<'input> = IdentifierContext<'input>;


pub type IdentifierContext<'input> = BaseParserRuleContext<'input,IdentifierContextExt<'input>>;

#[derive(Clone)]
pub struct IdentifierContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for IdentifierContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for IdentifierContext<'input>{
	fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_identifier(self);
	}
	fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
		listener.exit_identifier(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for IdentifierContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_identifier(self);
	}
}

impl<'input> CustomRuleContext<'input> for IdentifierContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_identifier }
	//fn type_rule_index() -> usize where Self: Sized { RULE_identifier }
}
antlr_rust::type_id!{IdentifierContextExt<'a>}

impl<'input> IdentifierContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<IdentifierContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,IdentifierContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait IdentifierContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<IdentifierContextExt<'input>>{

fn simpleIdentifier_all(&self) ->  Vec<Rc<SimpleIdentifierContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn simpleIdentifier(&self, i: usize) -> Option<Rc<SimpleIdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token DOT in current rule
fn DOT_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token DOT, starting from 0.
/// Returns `None` if number of children corresponding to token DOT is less or equal than `i`.
fn DOT(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(DOT, i)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}

}

impl<'input> IdentifierContextAttrs<'input> for IdentifierContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn identifier(&mut self,)
	-> Result<Rc<IdentifierContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = IdentifierContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 346, RULE_identifier);
        let mut _localctx: Rc<IdentifierContextAll> = _localctx;
		let mut _la: isize;
		let result: Result<(), ANTLRError> = try {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule simpleIdentifier*/
			recog.base.set_state(3505);
			recog.simpleIdentifier()?;

			recog.base.set_state(3516);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(541,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					recog.base.set_state(3509);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(3506);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(3511);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(3512);
					recog.base.match_token(DOT,&mut recog.err_handler)?;

					/*InvokeRule simpleIdentifier*/
					recog.base.set_state(3513);
					recog.simpleIdentifier()?;

					}
					} 
				}
				recog.base.set_state(3518);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(541,&mut recog.base)?;
			}
			}
		};
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}

lazy_static! {
    static ref _ATN: Arc<ATN> =
        Arc::new(ATNDeserializer::new(None).deserialize(_serializedATN.chars()));
    static ref _decision_to_DFA: Arc<Vec<antlr_rust::RwLock<DFA>>> = {
        let mut dfa = Vec::new();
        let size = _ATN.decision_to_state.len();
        for i in 0..size {
            dfa.push(DFA::new(
                _ATN.clone(),
                _ATN.get_decision_state(i),
                i as isize,
            ).into())
        }
        Arc::new(dfa)
    };
}



const _serializedATN:&'static str =
	"\x03\u{608b}\u{a72a}\u{8133}\u{b9ed}\u{417c}\u{3be7}\u{7786}\u{5964}\x03\
	\u{af}\u{dc2}\x04\x02\x09\x02\x04\x03\x09\x03\x04\x04\x09\x04\x04\x05\x09\
	\x05\x04\x06\x09\x06\x04\x07\x09\x07\x04\x08\x09\x08\x04\x09\x09\x09\x04\
	\x0a\x09\x0a\x04\x0b\x09\x0b\x04\x0c\x09\x0c\x04\x0d\x09\x0d\x04\x0e\x09\
	\x0e\x04\x0f\x09\x0f\x04\x10\x09\x10\x04\x11\x09\x11\x04\x12\x09\x12\x04\
	\x13\x09\x13\x04\x14\x09\x14\x04\x15\x09\x15\x04\x16\x09\x16\x04\x17\x09\
	\x17\x04\x18\x09\x18\x04\x19\x09\x19\x04\x1a\x09\x1a\x04\x1b\x09\x1b\x04\
	\x1c\x09\x1c\x04\x1d\x09\x1d\x04\x1e\x09\x1e\x04\x1f\x09\x1f\x04\x20\x09\
	\x20\x04\x21\x09\x21\x04\x22\x09\x22\x04\x23\x09\x23\x04\x24\x09\x24\x04\
	\x25\x09\x25\x04\x26\x09\x26\x04\x27\x09\x27\x04\x28\x09\x28\x04\x29\x09\
	\x29\x04\x2a\x09\x2a\x04\x2b\x09\x2b\x04\x2c\x09\x2c\x04\x2d\x09\x2d\x04\
	\x2e\x09\x2e\x04\x2f\x09\x2f\x04\x30\x09\x30\x04\x31\x09\x31\x04\x32\x09\
	\x32\x04\x33\x09\x33\x04\x34\x09\x34\x04\x35\x09\x35\x04\x36\x09\x36\x04\
	\x37\x09\x37\x04\x38\x09\x38\x04\x39\x09\x39\x04\x3a\x09\x3a\x04\x3b\x09\
	\x3b\x04\x3c\x09\x3c\x04\x3d\x09\x3d\x04\x3e\x09\x3e\x04\x3f\x09\x3f\x04\
	\x40\x09\x40\x04\x41\x09\x41\x04\x42\x09\x42\x04\x43\x09\x43\x04\x44\x09\
	\x44\x04\x45\x09\x45\x04\x46\x09\x46\x04\x47\x09\x47\x04\x48\x09\x48\x04\
	\x49\x09\x49\x04\x4a\x09\x4a\x04\x4b\x09\x4b\x04\x4c\x09\x4c\x04\x4d\x09\
	\x4d\x04\x4e\x09\x4e\x04\x4f\x09\x4f\x04\x50\x09\x50\x04\x51\x09\x51\x04\
	\x52\x09\x52\x04\x53\x09\x53\x04\x54\x09\x54\x04\x55\x09\x55\x04\x56\x09\
	\x56\x04\x57\x09\x57\x04\x58\x09\x58\x04\x59\x09\x59\x04\x5a\x09\x5a\x04\
	\x5b\x09\x5b\x04\x5c\x09\x5c\x04\x5d\x09\x5d\x04\x5e\x09\x5e\x04\x5f\x09\
	\x5f\x04\x60\x09\x60\x04\x61\x09\x61\x04\x62\x09\x62\x04\x63\x09\x63\x04\
	\x64\x09\x64\x04\x65\x09\x65\x04\x66\x09\x66\x04\x67\x09\x67\x04\x68\x09\
	\x68\x04\x69\x09\x69\x04\x6a\x09\x6a\x04\x6b\x09\x6b\x04\x6c\x09\x6c\x04\
	\x6d\x09\x6d\x04\x6e\x09\x6e\x04\x6f\x09\x6f\x04\x70\x09\x70\x04\x71\x09\
	\x71\x04\x72\x09\x72\x04\x73\x09\x73\x04\x74\x09\x74\x04\x75\x09\x75\x04\
	\x76\x09\x76\x04\x77\x09\x77\x04\x78\x09\x78\x04\x79\x09\x79\x04\x7a\x09\
	\x7a\x04\x7b\x09\x7b\x04\x7c\x09\x7c\x04\x7d\x09\x7d\x04\x7e\x09\x7e\x04\
	\x7f\x09\x7f\x04\u{80}\x09\u{80}\x04\u{81}\x09\u{81}\x04\u{82}\x09\u{82}\
	\x04\u{83}\x09\u{83}\x04\u{84}\x09\u{84}\x04\u{85}\x09\u{85}\x04\u{86}\x09\
	\u{86}\x04\u{87}\x09\u{87}\x04\u{88}\x09\u{88}\x04\u{89}\x09\u{89}\x04\u{8a}\
	\x09\u{8a}\x04\u{8b}\x09\u{8b}\x04\u{8c}\x09\u{8c}\x04\u{8d}\x09\u{8d}\x04\
	\u{8e}\x09\u{8e}\x04\u{8f}\x09\u{8f}\x04\u{90}\x09\u{90}\x04\u{91}\x09\u{91}\
	\x04\u{92}\x09\u{92}\x04\u{93}\x09\u{93}\x04\u{94}\x09\u{94}\x04\u{95}\x09\
	\u{95}\x04\u{96}\x09\u{96}\x04\u{97}\x09\u{97}\x04\u{98}\x09\u{98}\x04\u{99}\
	\x09\u{99}\x04\u{9a}\x09\u{9a}\x04\u{9b}\x09\u{9b}\x04\u{9c}\x09\u{9c}\x04\
	\u{9d}\x09\u{9d}\x04\u{9e}\x09\u{9e}\x04\u{9f}\x09\u{9f}\x04\u{a0}\x09\u{a0}\
	\x04\u{a1}\x09\u{a1}\x04\u{a2}\x09\u{a2}\x04\u{a3}\x09\u{a3}\x04\u{a4}\x09\
	\u{a4}\x04\u{a5}\x09\u{a5}\x04\u{a6}\x09\u{a6}\x04\u{a7}\x09\u{a7}\x04\u{a8}\
	\x09\u{a8}\x04\u{a9}\x09\u{a9}\x04\u{aa}\x09\u{aa}\x04\u{ab}\x09\u{ab}\x04\
	\u{ac}\x09\u{ac}\x04\u{ad}\x09\u{ad}\x04\u{ae}\x09\u{ae}\x04\u{af}\x09\u{af}\
	\x03\x02\x05\x02\u{160}\x0a\x02\x03\x02\x07\x02\u{163}\x0a\x02\x0c\x02\x0e\
	\x02\u{166}\x0b\x02\x03\x02\x07\x02\u{169}\x0a\x02\x0c\x02\x0e\x02\u{16c}\
	\x0b\x02\x03\x02\x03\x02\x03\x02\x07\x02\u{171}\x0a\x02\x0c\x02\x0e\x02\
	\u{174}\x0b\x02\x03\x02\x03\x02\x03\x03\x05\x03\u{179}\x0a\x03\x03\x03\x07\
	\x03\u{17c}\x0a\x03\x0c\x03\x0e\x03\u{17f}\x0b\x03\x03\x03\x07\x03\u{182}\
	\x0a\x03\x0c\x03\x0e\x03\u{185}\x0b\x03\x03\x03\x03\x03\x03\x03\x03\x03\
	\x03\x03\x07\x03\u{18c}\x0a\x03\x0c\x03\x0e\x03\u{18f}\x0b\x03\x03\x03\x03\
	\x03\x03\x04\x03\x04\x06\x04\u{195}\x0a\x04\x0d\x04\x0e\x04\u{196}\x03\x05\
	\x03\x05\x03\x05\x07\x05\u{19c}\x0a\x05\x0c\x05\x0e\x05\u{19f}\x0b\x05\x03\
	\x05\x03\x05\x07\x05\u{1a3}\x0a\x05\x0c\x05\x0e\x05\u{1a6}\x0b\x05\x03\x05\
	\x03\x05\x06\x05\u{1aa}\x0a\x05\x0d\x05\x0e\x05\u{1ab}\x03\x05\x03\x05\x03\
	\x05\x05\x05\u{1b1}\x0a\x05\x03\x05\x07\x05\u{1b4}\x0a\x05\x0c\x05\x0e\x05\
	\u{1b7}\x0b\x05\x03\x06\x03\x06\x03\x06\x05\x06\u{1bc}\x0a\x06\x05\x06\u{1be}\
	\x0a\x06\x03\x07\x07\x07\u{1c1}\x0a\x07\x0c\x07\x0e\x07\u{1c4}\x0b\x07\x03\
	\x08\x03\x08\x03\x08\x03\x08\x03\x08\x05\x08\u{1cb}\x0a\x08\x03\x08\x05\
	\x08\u{1ce}\x0a\x08\x03\x09\x03\x09\x03\x09\x03\x0a\x03\x0a\x05\x0a\u{1d5}\
	\x0a\x0a\x03\x0b\x05\x0b\u{1d8}\x0a\x0b\x03\x0b\x03\x0b\x07\x0b\u{1dc}\x0a\
	\x0b\x0c\x0b\x0e\x0b\u{1df}\x0b\x0b\x03\x0b\x03\x0b\x07\x0b\u{1e3}\x0a\x0b\
	\x0c\x0b\x0e\x0b\u{1e6}\x0b\x0b\x03\x0b\x05\x0b\u{1e9}\x0a\x0b\x03\x0b\x07\
	\x0b\u{1ec}\x0a\x0b\x0c\x0b\x0e\x0b\u{1ef}\x0b\x0b\x03\x0b\x03\x0b\x07\x0b\
	\u{1f3}\x0a\x0b\x0c\x0b\x0e\x0b\u{1f6}\x0b\x0b\x03\x0b\x03\x0b\x03\x0c\x03\
	\x0c\x03\x0c\x03\x0c\x03\x0c\x05\x0c\u{1ff}\x0a\x0c\x03\x0d\x05\x0d\u{202}\
	\x0a\x0d\x03\x0d\x03\x0d\x03\x0d\x07\x0d\u{207}\x0a\x0d\x0c\x0d\x0e\x0d\
	\u{20a}\x0b\x0d\x05\x0d\u{20c}\x0a\x0d\x03\x0d\x05\x0d\u{20f}\x0a\x0d\x03\
	\x0d\x07\x0d\u{212}\x0a\x0d\x0c\x0d\x0e\x0d\u{215}\x0b\x0d\x03\x0d\x03\x0d\
	\x07\x0d\u{219}\x0a\x0d\x0c\x0d\x0e\x0d\u{21c}\x0b\x0d\x03\x0d\x05\x0d\u{21f}\
	\x0a\x0d\x03\x0d\x07\x0d\u{222}\x0a\x0d\x0c\x0d\x0e\x0d\u{225}\x0b\x0d\x03\
	\x0d\x05\x0d\u{228}\x0a\x0d\x03\x0d\x07\x0d\u{22b}\x0a\x0d\x0c\x0d\x0e\x0d\
	\u{22e}\x0b\x0d\x03\x0d\x03\x0d\x07\x0d\u{232}\x0a\x0d\x0c\x0d\x0e\x0d\u{235}\
	\x0b\x0d\x03\x0d\x05\x0d\u{238}\x0a\x0d\x03\x0d\x07\x0d\u{23b}\x0a\x0d\x0c\
	\x0d\x0e\x0d\u{23e}\x0b\x0d\x03\x0d\x05\x0d\u{241}\x0a\x0d\x03\x0d\x07\x0d\
	\u{244}\x0a\x0d\x0c\x0d\x0e\x0d\u{247}\x0b\x0d\x03\x0d\x03\x0d\x07\x0d\u{24b}\
	\x0a\x0d\x0c\x0d\x0e\x0d\u{24e}\x0b\x0d\x03\x0d\x05\x0d\u{251}\x0a\x0d\x03\
	\x0e\x05\x0e\u{254}\x0a\x0e\x03\x0e\x03\x0e\x07\x0e\u{258}\x0a\x0e\x0c\x0e\
	\x0e\x0e\u{25b}\x0b\x0e\x05\x0e\u{25d}\x0a\x0e\x03\x0e\x03\x0e\x03\x0f\x03\
	\x0f\x07\x0f\u{263}\x0a\x0f\x0c\x0f\x0e\x0f\u{266}\x0b\x0f\x03\x0f\x03\x0f\
	\x07\x0f\u{26a}\x0a\x0f\x0c\x0f\x0e\x0f\u{26d}\x0b\x0f\x03\x0f\x03\x0f\x03\
	\x10\x03\x10\x07\x10\u{273}\x0a\x10\x0c\x10\x0e\x10\u{276}\x0b\x10\x03\x10\
	\x03\x10\x07\x10\u{27a}\x0a\x10\x0c\x10\x0e\x10\u{27d}\x0b\x10\x03\x10\x03\
	\x10\x07\x10\u{281}\x0a\x10\x0c\x10\x0e\x10\u{284}\x0b\x10\x03\x10\x07\x10\
	\u{287}\x0a\x10\x0c\x10\x0e\x10\u{28a}\x0b\x10\x03\x10\x07\x10\u{28d}\x0a\
	\x10\x0c\x10\x0e\x10\u{290}\x0b\x10\x03\x10\x05\x10\u{293}\x0a\x10\x05\x10\
	\u{295}\x0a\x10\x03\x10\x07\x10\u{298}\x0a\x10\x0c\x10\x0e\x10\u{29b}\x0b\
	\x10\x03\x10\x03\x10\x03\x11\x05\x11\u{2a0}\x0a\x11\x03\x11\x05\x11\u{2a3}\
	\x0a\x11\x03\x11\x07\x11\u{2a6}\x0a\x11\x0c\x11\x0e\x11\u{2a9}\x0b\x11\x03\
	\x11\x03\x11\x03\x11\x07\x11\u{2ae}\x0a\x11\x0c\x11\x0e\x11\u{2b1}\x0b\x11\
	\x03\x11\x03\x11\x07\x11\u{2b5}\x0a\x11\x0c\x11\x0e\x11\u{2b8}\x0b\x11\x03\
	\x11\x03\x11\x07\x11\u{2bc}\x0a\x11\x0c\x11\x0e\x11\u{2bf}\x0b\x11\x03\x11\
	\x05\x11\u{2c2}\x0a\x11\x03\x12\x03\x12\x07\x12\u{2c6}\x0a\x12\x0c\x12\x0e\
	\x12\u{2c9}\x0b\x12\x03\x12\x03\x12\x07\x12\u{2cd}\x0a\x12\x0c\x12\x0e\x12\
	\u{2d0}\x0b\x12\x03\x12\x07\x12\u{2d3}\x0a\x12\x0c\x12\x0e\x12\u{2d6}\x0b\
	\x12\x03\x13\x03\x13\x03\x13\x03\x13\x03\x13\x03\x13\x07\x13\u{2de}\x0a\
	\x13\x0c\x13\x0e\x13\u{2e1}\x0b\x13\x03\x13\x05\x13\u{2e4}\x0a\x13\x03\x14\
	\x03\x14\x07\x14\u{2e8}\x0a\x14\x0c\x14\x0e\x14\u{2eb}\x0b\x14\x03\x14\x03\
	\x14\x03\x15\x07\x15\u{2f0}\x0a\x15\x0c\x15\x0e\x15\u{2f3}\x0b\x15\x03\x15\
	\x07\x15\u{2f6}\x0a\x15\x0c\x15\x0e\x15\u{2f9}\x0b\x15\x03\x15\x03\x15\x03\
	\x16\x03\x16\x05\x16\u{2ff}\x0a\x16\x03\x16\x07\x16\u{302}\x0a\x16\x0c\x16\
	\x0e\x16\u{305}\x0b\x16\x03\x16\x03\x16\x07\x16\u{309}\x0a\x16\x0c\x16\x0e\
	\x16\u{30c}\x0b\x16\x03\x16\x03\x16\x03\x17\x03\x17\x07\x17\u{312}\x0a\x17\
	\x0c\x17\x0e\x17\u{315}\x0b\x17\x03\x17\x03\x17\x07\x17\u{319}\x0a\x17\x0c\
	\x17\x0e\x17\u{31c}\x0b\x17\x03\x17\x03\x17\x07\x17\u{320}\x0a\x17\x0c\x17\
	\x0e\x17\u{323}\x0b\x17\x03\x17\x07\x17\u{326}\x0a\x17\x0c\x17\x0e\x17\u{329}\
	\x0b\x17\x03\x17\x07\x17\u{32c}\x0a\x17\x0c\x17\x0e\x17\u{32f}\x0b\x17\x03\
	\x17\x05\x17\u{332}\x0a\x17\x03\x17\x07\x17\u{335}\x0a\x17\x0c\x17\x0e\x17\
	\u{338}\x0b\x17\x03\x17\x03\x17\x03\x18\x05\x18\u{33d}\x0a\x18\x03\x18\x07\
	\x18\u{340}\x0a\x18\x0c\x18\x0e\x18\u{343}\x0b\x18\x03\x18\x03\x18\x07\x18\
	\u{347}\x0a\x18\x0c\x18\x0e\x18\u{34a}\x0b\x18\x03\x18\x03\x18\x07\x18\u{34e}\
	\x0a\x18\x0c\x18\x0e\x18\u{351}\x0b\x18\x03\x18\x05\x18\u{354}\x0a\x18\x03\
	\x19\x03\x19\x07\x19\u{358}\x0a\x19\x0c\x19\x0e\x19\u{35b}\x0b\x19\x03\x19\
	\x03\x19\x07\x19\u{35f}\x0a\x19\x0c\x19\x0e\x19\u{362}\x0b\x19\x03\x19\x03\
	\x19\x07\x19\u{366}\x0a\x19\x0c\x19\x0e\x19\u{369}\x0b\x19\x03\x19\x07\x19\
	\u{36c}\x0a\x19\x0c\x19\x0e\x19\u{36f}\x0b\x19\x03\x1a\x07\x1a\u{372}\x0a\
	\x1a\x0c\x1a\x0e\x1a\u{375}\x0b\x1a\x03\x1a\x03\x1a\x07\x1a\u{379}\x0a\x1a\
	\x0c\x1a\x0e\x1a\u{37c}\x0b\x1a\x03\x1a\x03\x1a\x07\x1a\u{380}\x0a\x1a\x0c\
	\x1a\x0e\x1a\u{383}\x0b\x1a\x03\x1a\x03\x1a\x03\x1b\x03\x1b\x05\x1b\u{389}\
	\x0a\x1b\x07\x1b\u{38b}\x0a\x1b\x0c\x1b\x0e\x1b\u{38e}\x0b\x1b\x03\x1c\x03\
	\x1c\x03\x1c\x03\x1c\x05\x1c\u{394}\x0a\x1c\x03\x1d\x03\x1d\x07\x1d\u{398}\
	\x0a\x1d\x0c\x1d\x0e\x1d\u{39b}\x0b\x1d\x03\x1d\x03\x1d\x03\x1e\x05\x1e\
	\u{3a0}\x0a\x1e\x03\x1e\x03\x1e\x07\x1e\u{3a4}\x0a\x1e\x0c\x1e\x0e\x1e\u{3a7}\
	\x0b\x1e\x03\x1e\x05\x1e\u{3aa}\x0a\x1e\x03\x1e\x07\x1e\u{3ad}\x0a\x1e\x0c\
	\x1e\x0e\x1e\u{3b0}\x0b\x1e\x03\x1e\x03\x1e\x07\x1e\u{3b4}\x0a\x1e\x0c\x1e\
	\x0e\x1e\u{3b7}\x0b\x1e\x03\x1e\x05\x1e\u{3ba}\x0a\x1e\x03\x1e\x07\x1e\u{3bd}\
	\x0a\x1e\x0c\x1e\x0e\x1e\u{3c0}\x0b\x1e\x03\x1e\x03\x1e\x07\x1e\u{3c4}\x0a\
	\x1e\x0c\x1e\x0e\x1e\u{3c7}\x0b\x1e\x03\x1e\x05\x1e\u{3ca}\x0a\x1e\x03\x1e\
	\x07\x1e\u{3cd}\x0a\x1e\x0c\x1e\x0e\x1e\u{3d0}\x0b\x1e\x03\x1e\x05\x1e\u{3d3}\
	\x0a\x1e\x03\x1f\x03\x1f\x07\x1f\u{3d7}\x0a\x1f\x0c\x1f\x0e\x1f\u{3da}\x0b\
	\x1f\x03\x1f\x03\x1f\x07\x1f\u{3de}\x0a\x1f\x0c\x1f\x0e\x1f\u{3e1}\x0b\x1f\
	\x03\x1f\x03\x1f\x07\x1f\u{3e5}\x0a\x1f\x0c\x1f\x0e\x1f\u{3e8}\x0b\x1f\x03\
	\x1f\x07\x1f\u{3eb}\x0a\x1f\x0c\x1f\x0e\x1f\u{3ee}\x0b\x1f\x03\x1f\x07\x1f\
	\u{3f1}\x0a\x1f\x0c\x1f\x0e\x1f\u{3f4}\x0b\x1f\x03\x1f\x05\x1f\u{3f7}\x0a\
	\x1f\x05\x1f\u{3f9}\x0a\x1f\x03\x1f\x07\x1f\u{3fc}\x0a\x1f\x0c\x1f\x0e\x1f\
	\u{3ff}\x0b\x1f\x03\x1f\x03\x1f\x03\x20\x05\x20\u{404}\x0a\x20\x03\x20\x03\
	\x20\x07\x20\u{408}\x0a\x20\x0c\x20\x0e\x20\u{40b}\x0b\x20\x03\x20\x03\x20\
	\x07\x20\u{40f}\x0a\x20\x0c\x20\x0e\x20\u{412}\x0b\x20\x03\x20\x05\x20\u{415}\
	\x0a\x20\x03\x21\x05\x21\u{418}\x0a\x21\x03\x21\x03\x21\x07\x21\u{41c}\x0a\
	\x21\x0c\x21\x0e\x21\u{41f}\x0b\x21\x03\x21\x05\x21\u{422}\x0a\x21\x03\x21\
	\x07\x21\u{425}\x0a\x21\x0c\x21\x0e\x21\u{428}\x0b\x21\x03\x21\x03\x21\x07\
	\x21\u{42c}\x0a\x21\x0c\x21\x0e\x21\u{42f}\x0b\x21\x03\x21\x03\x21\x05\x21\
	\u{433}\x0a\x21\x03\x21\x07\x21\u{436}\x0a\x21\x0c\x21\x0e\x21\u{439}\x0b\
	\x21\x03\x21\x03\x21\x07\x21\u{43d}\x0a\x21\x0c\x21\x0e\x21\u{440}\x0b\x21\
	\x03\x21\x03\x21\x07\x21\u{444}\x0a\x21\x0c\x21\x0e\x21\u{447}\x0b\x21\x03\
	\x21\x03\x21\x07\x21\u{44b}\x0a\x21\x0c\x21\x0e\x21\u{44e}\x0b\x21\x03\x21\
	\x05\x21\u{451}\x0a\x21\x03\x21\x07\x21\u{454}\x0a\x21\x0c\x21\x0e\x21\u{457}\
	\x0b\x21\x03\x21\x05\x21\u{45a}\x0a\x21\x03\x21\x07\x21\u{45d}\x0a\x21\x0c\
	\x21\x0e\x21\u{460}\x0b\x21\x03\x21\x05\x21\u{463}\x0a\x21\x03\x22\x03\x22\
	\x03\x22\x07\x22\u{468}\x0a\x22\x0c\x22\x0e\x22\u{46b}\x0b\x22\x03\x22\x05\
	\x22\u{46e}\x0a\x22\x03\x23\x07\x23\u{471}\x0a\x23\x0c\x23\x0e\x23\u{474}\
	\x0b\x23\x03\x23\x07\x23\u{477}\x0a\x23\x0c\x23\x0e\x23\u{47a}\x0b\x23\x03\
	\x23\x03\x23\x07\x23\u{47e}\x0a\x23\x0c\x23\x0e\x23\u{481}\x0b\x23\x03\x23\
	\x03\x23\x07\x23\u{485}\x0a\x23\x0c\x23\x0e\x23\u{488}\x0b\x23\x03\x23\x05\
	\x23\u{48b}\x0a\x23\x03\x24\x03\x24\x07\x24\u{48f}\x0a\x24\x0c\x24\x0e\x24\
	\u{492}\x0b\x24\x03\x24\x03\x24\x07\x24\u{496}\x0a\x24\x0c\x24\x0e\x24\u{499}\
	\x0b\x24\x03\x24\x03\x24\x07\x24\u{49d}\x0a\x24\x0c\x24\x0e\x24\u{4a0}\x0b\
	\x24\x03\x24\x07\x24\u{4a3}\x0a\x24\x0c\x24\x0e\x24\u{4a6}\x0b\x24\x03\x24\
	\x07\x24\u{4a9}\x0a\x24\x0c\x24\x0e\x24\u{4ac}\x0b\x24\x03\x24\x05\x24\u{4af}\
	\x0a\x24\x03\x24\x07\x24\u{4b2}\x0a\x24\x0c\x24\x0e\x24\u{4b5}\x0b\x24\x03\
	\x24\x03\x24\x03\x25\x05\x25\u{4ba}\x0a\x25\x03\x25\x03\x25\x07\x25\u{4be}\
	\x0a\x25\x0c\x25\x0e\x25\u{4c1}\x0b\x25\x03\x25\x05\x25\u{4c4}\x0a\x25\x03\
	\x25\x07\x25\u{4c7}\x0a\x25\x0c\x25\x0e\x25\u{4ca}\x0b\x25\x03\x25\x03\x25\
	\x07\x25\u{4ce}\x0a\x25\x0c\x25\x0e\x25\u{4d1}\x0b\x25\x03\x25\x03\x25\x05\
	\x25\u{4d5}\x0a\x25\x03\x25\x07\x25\u{4d8}\x0a\x25\x0c\x25\x0e\x25\u{4db}\
	\x0b\x25\x03\x25\x03\x25\x05\x25\u{4df}\x0a\x25\x03\x25\x07\x25\u{4e2}\x0a\
	\x25\x0c\x25\x0e\x25\u{4e5}\x0b\x25\x03\x25\x05\x25\u{4e8}\x0a\x25\x03\x25\
	\x07\x25\u{4eb}\x0a\x25\x0c\x25\x0e\x25\u{4ee}\x0b\x25\x03\x25\x03\x25\x07\
	\x25\u{4f2}\x0a\x25\x0c\x25\x0e\x25\u{4f5}\x0b\x25\x03\x25\x03\x25\x05\x25\
	\u{4f9}\x0a\x25\x05\x25\u{4fb}\x0a\x25\x03\x25\x07\x25\u{4fe}\x0a\x25\x0c\
	\x25\x0e\x25\u{501}\x0b\x25\x03\x25\x05\x25\u{504}\x0a\x25\x03\x25\x07\x25\
	\u{507}\x0a\x25\x0c\x25\x0e\x25\u{50a}\x0b\x25\x03\x25\x05\x25\u{50d}\x0a\
	\x25\x03\x25\x07\x25\u{510}\x0a\x25\x0c\x25\x0e\x25\u{513}\x0b\x25\x03\x25\
	\x05\x25\u{516}\x0a\x25\x03\x25\x05\x25\u{519}\x0a\x25\x03\x25\x05\x25\u{51c}\
	\x0a\x25\x03\x25\x07\x25\u{51f}\x0a\x25\x0c\x25\x0e\x25\u{522}\x0b\x25\x03\
	\x25\x05\x25\u{525}\x0a\x25\x03\x25\x05\x25\u{528}\x0a\x25\x05\x25\u{52a}\
	\x0a\x25\x03\x26\x03\x26\x07\x26\u{52e}\x0a\x26\x0c\x26\x0e\x26\u{531}\x0b\
	\x26\x03\x26\x03\x26\x03\x27\x05\x27\u{536}\x0a\x27\x03\x27\x03\x27\x07\
	\x27\u{53a}\x0a\x27\x0c\x27\x0e\x27\u{53d}\x0b\x27\x03\x27\x03\x27\x07\x27\
	\u{541}\x0a\x27\x0c\x27\x0e\x27\u{544}\x0b\x27\x03\x27\x03\x27\x07\x27\u{548}\
	\x0a\x27\x0c\x27\x0e\x27\u{54b}\x0b\x27\x03\x27\x03\x27\x07\x27\u{54f}\x0a\
	\x27\x0c\x27\x0e\x27\u{552}\x0b\x27\x03\x27\x05\x27\u{555}\x0a\x27\x03\x27\
	\x07\x27\u{558}\x0a\x27\x0c\x27\x0e\x27\u{55b}\x0b\x27\x03\x27\x05\x27\u{55e}\
	\x0a\x27\x03\x28\x05\x28\u{561}\x0a\x28\x03\x28\x03\x28\x07\x28\u{565}\x0a\
	\x28\x0c\x28\x0e\x28\u{568}\x0b\x28\x03\x28\x03\x28\x07\x28\u{56c}\x0a\x28\
	\x0c\x28\x0e\x28\u{56f}\x0b\x28\x03\x28\x03\x28\x07\x28\u{573}\x0a\x28\x0c\
	\x28\x0e\x28\u{576}\x0b\x28\x03\x28\x05\x28\u{579}\x0a\x28\x03\x28\x07\x28\
	\u{57c}\x0a\x28\x0c\x28\x0e\x28\u{57f}\x0b\x28\x03\x28\x03\x28\x07\x28\u{583}\
	\x0a\x28\x0c\x28\x0e\x28\u{586}\x0b\x28\x03\x28\x03\x28\x07\x28\u{58a}\x0a\
	\x28\x0c\x28\x0e\x28\u{58d}\x0b\x28\x03\x28\x05\x28\u{590}\x0a\x28\x03\x28\
	\x07\x28\u{593}\x0a\x28\x0c\x28\x0e\x28\u{596}\x0b\x28\x03\x28\x03\x28\x05\
	\x28\u{59a}\x0a\x28\x03\x29\x03\x29\x07\x29\u{59e}\x0a\x29\x0c\x29\x0e\x29\
	\u{5a1}\x0b\x29\x03\x29\x03\x29\x07\x29\u{5a5}\x0a\x29\x0c\x29\x0e\x29\u{5a8}\
	\x0b\x29\x03\x29\x03\x29\x07\x29\u{5ac}\x0a\x29\x0c\x29\x0e\x29\u{5af}\x0b\
	\x29\x03\x29\x07\x29\u{5b2}\x0a\x29\x0c\x29\x0e\x29\u{5b5}\x0b\x29\x03\x29\
	\x07\x29\u{5b8}\x0a\x29\x0c\x29\x0e\x29\u{5bb}\x0b\x29\x03\x29\x05\x29\u{5be}\
	\x0a\x29\x05\x29\u{5c0}\x0a\x29\x03\x29\x07\x29\u{5c3}\x0a\x29\x0c\x29\x0e\
	\x29\u{5c6}\x0b\x29\x03\x29\x03\x29\x03\x2a\x05\x2a\u{5cb}\x0a\x2a\x03\x2a\
	\x03\x2a\x07\x2a\u{5cf}\x0a\x2a\x0c\x2a\x0e\x2a\u{5d2}\x0b\x2a\x03\x2a\x03\
	\x2a\x07\x2a\u{5d6}\x0a\x2a\x0c\x2a\x0e\x2a\u{5d9}\x0b\x2a\x03\x2a\x05\x2a\
	\u{5dc}\x0a\x2a\x03\x2b\x03\x2b\x07\x2b\u{5e0}\x0a\x2b\x0c\x2b\x0e\x2b\u{5e3}\
	\x0b\x2b\x03\x2b\x03\x2b\x07\x2b\u{5e7}\x0a\x2b\x0c\x2b\x0e\x2b\u{5ea}\x0b\
	\x2b\x03\x2b\x05\x2b\u{5ed}\x0a\x2b\x03\x2c\x03\x2c\x07\x2c\u{5f1}\x0a\x2c\
	\x0c\x2c\x0e\x2c\u{5f4}\x0b\x2c\x03\x2c\x03\x2c\x07\x2c\u{5f8}\x0a\x2c\x0c\
	\x2c\x0e\x2c\u{5fb}\x0b\x2c\x03\x2c\x03\x2c\x03\x2d\x05\x2d\u{600}\x0a\x2d\
	\x03\x2d\x03\x2d\x07\x2d\u{604}\x0a\x2d\x0c\x2d\x0e\x2d\u{607}\x0b\x2d\x03\
	\x2d\x03\x2d\x07\x2d\u{60b}\x0a\x2d\x0c\x2d\x0e\x2d\u{60e}\x0b\x2d\x03\x2d\
	\x03\x2d\x07\x2d\u{612}\x0a\x2d\x0c\x2d\x0e\x2d\u{615}\x0b\x2d\x03\x2d\x05\
	\x2d\u{618}\x0a\x2d\x03\x2d\x07\x2d\u{61b}\x0a\x2d\x0c\x2d\x0e\x2d\u{61e}\
	\x0b\x2d\x03\x2d\x05\x2d\u{621}\x0a\x2d\x03\x2e\x05\x2e\u{624}\x0a\x2e\x03\
	\x2e\x03\x2e\x07\x2e\u{628}\x0a\x2e\x0c\x2e\x0e\x2e\u{62b}\x0b\x2e\x03\x2e\
	\x03\x2e\x07\x2e\u{62f}\x0a\x2e\x0c\x2e\x0e\x2e\u{632}\x0b\x2e\x03\x2e\x03\
	\x2e\x07\x2e\u{636}\x0a\x2e\x0c\x2e\x0e\x2e\u{639}\x0b\x2e\x03\x2e\x05\x2e\
	\u{63c}\x0a\x2e\x03\x2e\x07\x2e\u{63f}\x0a\x2e\x0c\x2e\x0e\x2e\u{642}\x0b\
	\x2e\x03\x2e\x05\x2e\u{645}\x0a\x2e\x03\x2f\x03\x2f\x07\x2f\u{649}\x0a\x2f\
	\x0c\x2f\x0e\x2f\u{64c}\x0b\x2f\x03\x2f\x03\x2f\x03\x30\x03\x30\x07\x30\
	\u{652}\x0a\x30\x0c\x30\x0e\x30\u{655}\x0b\x30\x03\x30\x05\x30\u{658}\x0a\
	\x30\x03\x30\x07\x30\u{65b}\x0a\x30\x0c\x30\x0e\x30\u{65e}\x0b\x30\x03\x30\
	\x03\x30\x07\x30\u{662}\x0a\x30\x0c\x30\x0e\x30\u{665}\x0b\x30\x03\x30\x05\
	\x30\u{668}\x0a\x30\x03\x30\x07\x30\u{66b}\x0a\x30\x0c\x30\x0e\x30\u{66e}\
	\x0b\x30\x03\x30\x03\x30\x03\x31\x03\x31\x07\x31\u{674}\x0a\x31\x0c\x31\
	\x0e\x31\u{677}\x0b\x31\x03\x31\x03\x31\x07\x31\u{67b}\x0a\x31\x0c\x31\x0e\
	\x31\u{67e}\x0b\x31\x03\x31\x07\x31\u{681}\x0a\x31\x0c\x31\x0e\x31\u{684}\
	\x0b\x31\x03\x31\x07\x31\u{687}\x0a\x31\x0c\x31\x0e\x31\u{68a}\x0b\x31\x03\
	\x31\x05\x31\u{68d}\x0a\x31\x03\x32\x03\x32\x07\x32\u{691}\x0a\x32\x0c\x32\
	\x0e\x32\u{694}\x0b\x32\x05\x32\u{696}\x0a\x32\x03\x32\x03\x32\x07\x32\u{69a}\
	\x0a\x32\x0c\x32\x0e\x32\u{69d}\x0b\x32\x03\x32\x05\x32\u{6a0}\x0a\x32\x03\
	\x32\x07\x32\u{6a3}\x0a\x32\x0c\x32\x0e\x32\u{6a6}\x0b\x32\x03\x32\x05\x32\
	\u{6a9}\x0a\x32\x03\x33\x05\x33\u{6ac}\x0a\x33\x03\x33\x03\x33\x03\x33\x03\
	\x33\x03\x33\x05\x33\u{6b3}\x0a\x33\x03\x34\x03\x34\x05\x34\u{6b7}\x0a\x34\
	\x03\x35\x03\x35\x05\x35\u{6bb}\x0a\x35\x03\x35\x07\x35\u{6be}\x0a\x35\x0c\
	\x35\x0e\x35\u{6c1}\x0b\x35\x03\x35\x06\x35\u{6c4}\x0a\x35\x0d\x35\x0e\x35\
	\u{6c5}\x03\x36\x03\x36\x03\x37\x03\x37\x07\x37\u{6cc}\x0a\x37\x0c\x37\x0e\
	\x37\u{6cf}\x0b\x37\x03\x37\x03\x37\x07\x37\u{6d3}\x0a\x37\x0c\x37\x0e\x37\
	\u{6d6}\x0b\x37\x03\x37\x07\x37\u{6d9}\x0a\x37\x0c\x37\x0e\x37\u{6dc}\x0b\
	\x37\x03\x38\x03\x38\x07\x38\u{6e0}\x0a\x38\x0c\x38\x0e\x38\u{6e3}\x0b\x38\
	\x03\x38\x05\x38\u{6e6}\x0a\x38\x03\x39\x05\x39\u{6e9}\x0a\x39\x03\x39\x03\
	\x39\x05\x39\u{6ed}\x0a\x39\x03\x3a\x06\x3a\u{6f0}\x0a\x3a\x0d\x3a\x0e\x3a\
	\u{6f1}\x03\x3b\x03\x3b\x07\x3b\u{6f6}\x0a\x3b\x0c\x3b\x0e\x3b\u{6f9}\x0b\
	\x3b\x03\x3b\x05\x3b\u{6fc}\x0a\x3b\x03\x3c\x03\x3c\x07\x3c\u{700}\x0a\x3c\
	\x0c\x3c\x0e\x3c\u{703}\x0b\x3c\x03\x3c\x03\x3c\x07\x3c\u{707}\x0a\x3c\x0c\
	\x3c\x0e\x3c\u{70a}\x0b\x3c\x05\x3c\u{70c}\x0a\x3c\x03\x3c\x03\x3c\x07\x3c\
	\u{710}\x0a\x3c\x0c\x3c\x0e\x3c\u{713}\x0b\x3c\x03\x3c\x03\x3c\x07\x3c\u{717}\
	\x0a\x3c\x0c\x3c\x0e\x3c\u{71a}\x0b\x3c\x03\x3c\x03\x3c\x03\x3d\x03\x3d\
	\x07\x3d\u{720}\x0a\x3d\x0c\x3d\x0e\x3d\u{723}\x0b\x3d\x03\x3d\x03\x3d\x05\
	\x3d\u{727}\x0a\x3d\x03\x3d\x07\x3d\u{72a}\x0a\x3d\x0c\x3d\x0e\x3d\u{72d}\
	\x0b\x3d\x03\x3d\x03\x3d\x07\x3d\u{731}\x0a\x3d\x0c\x3d\x0e\x3d\u{734}\x0b\
	\x3d\x03\x3d\x03\x3d\x05\x3d\u{738}\x0a\x3d\x07\x3d\u{73a}\x0a\x3d\x0c\x3d\
	\x0e\x3d\u{73d}\x0b\x3d\x03\x3d\x07\x3d\u{740}\x0a\x3d\x0c\x3d\x0e\x3d\u{743}\
	\x0b\x3d\x03\x3d\x05\x3d\u{746}\x0a\x3d\x03\x3d\x07\x3d\u{749}\x0a\x3d\x0c\
	\x3d\x0e\x3d\u{74c}\x0b\x3d\x03\x3d\x03\x3d\x03\x3e\x03\x3e\x07\x3e\u{752}\
	\x0a\x3e\x0c\x3e\x0e\x3e\u{755}\x0b\x3e\x03\x3e\x03\x3e\x07\x3e\u{759}\x0a\
	\x3e\x0c\x3e\x0e\x3e\u{75c}\x0b\x3e\x03\x3e\x03\x3e\x03\x3f\x05\x3f\u{761}\
	\x0a\x3f\x03\x3f\x03\x3f\x03\x3f\x05\x3f\u{766}\x0a\x3f\x03\x40\x03\x40\
	\x07\x40\u{76a}\x0a\x40\x0c\x40\x0e\x40\u{76d}\x0b\x40\x03\x40\x03\x40\x05\
	\x40\u{771}\x0a\x40\x03\x40\x07\x40\u{774}\x0a\x40\x0c\x40\x0e\x40\u{777}\
	\x0b\x40\x03\x40\x03\x40\x03\x41\x05\x41\u{77c}\x0a\x41\x03\x41\x03\x41\
	\x05\x41\u{780}\x0a\x41\x03\x41\x07\x41\u{783}\x0a\x41\x0c\x41\x0e\x41\u{786}\
	\x0b\x41\x03\x41\x03\x41\x07\x41\u{78a}\x0a\x41\x0c\x41\x0e\x41\u{78d}\x0b\
	\x41\x03\x41\x05\x41\u{790}\x0a\x41\x03\x41\x03\x41\x05\x41\u{794}\x0a\x41\
	\x03\x42\x03\x42\x03\x42\x03\x42\x07\x42\u{79a}\x0a\x42\x0c\x42\x0e\x42\
	\u{79d}\x0b\x42\x05\x42\u{79f}\x0a\x42\x03\x42\x05\x42\u{7a2}\x0a\x42\x03\
	\x43\x03\x43\x07\x43\u{7a6}\x0a\x43\x0c\x43\x0e\x43\u{7a9}\x0b\x43\x03\x43\
	\x03\x43\x03\x43\x03\x43\x05\x43\u{7af}\x0a\x43\x03\x44\x03\x44\x03\x44\
	\x07\x44\u{7b4}\x0a\x44\x0c\x44\x0e\x44\u{7b7}\x0b\x44\x03\x45\x03\x45\x05\
	\x45\u{7bb}\x0a\x45\x03\x46\x03\x46\x07\x46\u{7bf}\x0a\x46\x0c\x46\x0e\x46\
	\u{7c2}\x0b\x46\x03\x46\x03\x46\x07\x46\u{7c6}\x0a\x46\x0c\x46\x0e\x46\u{7c9}\
	\x0b\x46\x03\x46\x03\x46\x03\x47\x03\x47\x03\x47\x05\x47\u{7d0}\x0a\x47\
	\x03\x48\x03\x48\x07\x48\u{7d4}\x0a\x48\x0c\x48\x0e\x48\u{7d7}\x0b\x48\x03\
	\x48\x03\x48\x07\x48\u{7db}\x0a\x48\x0c\x48\x0e\x48\u{7de}\x0b\x48\x03\x48\
	\x03\x48\x05\x48\u{7e2}\x0a\x48\x03\x48\x03\x48\x03\x48\x03\x48\x07\x48\
	\u{7e8}\x0a\x48\x0c\x48\x0e\x48\u{7eb}\x0b\x48\x03\x48\x05\x48\u{7ee}\x0a\
	\x48\x03\x49\x03\x49\x07\x49\u{7f2}\x0a\x49\x0c\x49\x0e\x49\u{7f5}\x0b\x49\
	\x03\x49\x03\x49\x03\x49\x03\x49\x07\x49\u{7fb}\x0a\x49\x0c\x49\x0e\x49\
	\u{7fe}\x0b\x49\x03\x49\x03\x49\x05\x49\u{802}\x0a\x49\x03\x4a\x03\x4a\x07\
	\x4a\u{806}\x0a\x4a\x0c\x4a\x0e\x4a\u{809}\x0b\x4a\x03\x4a\x05\x4a\u{80c}\
	\x0a\x4a\x03\x4a\x07\x4a\u{80f}\x0a\x4a\x0c\x4a\x0e\x4a\u{812}\x0b\x4a\x03\
	\x4a\x03\x4a\x07\x4a\u{816}\x0a\x4a\x0c\x4a\x0e\x4a\u{819}\x0b\x4a\x03\x4a\
	\x03\x4a\x03\x4a\x03\x4a\x03\x4b\x03\x4b\x03\x4b\x03\x4b\x03\x4b\x03\x4b\
	\x05\x4b\u{825}\x0a\x4b\x03\x4b\x07\x4b\u{828}\x0a\x4b\x0c\x4b\x0e\x4b\u{82b}\
	\x0b\x4b\x03\x4b\x03\x4b\x03\x4c\x03\x4c\x07\x4c\u{831}\x0a\x4c\x0c\x4c\
	\x0e\x4c\u{834}\x0b\x4c\x03\x4d\x06\x4d\u{837}\x0a\x4d\x0d\x4d\x0e\x4d\u{838}\
	\x03\x4e\x03\x4e\x03\x4f\x03\x4f\x07\x4f\u{83f}\x0a\x4f\x0c\x4f\x0e\x4f\
	\u{842}\x0b\x4f\x03\x4f\x03\x4f\x07\x4f\u{846}\x0a\x4f\x0c\x4f\x0e\x4f\u{849}\
	\x0b\x4f\x03\x4f\x07\x4f\u{84c}\x0a\x4f\x0c\x4f\x0e\x4f\u{84f}\x0b\x4f\x03\
	\x50\x03\x50\x07\x50\u{853}\x0a\x50\x0c\x50\x0e\x50\u{856}\x0b\x50\x03\x50\
	\x03\x50\x07\x50\u{85a}\x0a\x50\x0c\x50\x0e\x50\u{85d}\x0b\x50\x03\x50\x07\
	\x50\u{860}\x0a\x50\x0c\x50\x0e\x50\u{863}\x0b\x50\x03\x51\x03\x51\x03\x51\
	\x07\x51\u{868}\x0a\x51\x0c\x51\x0e\x51\u{86b}\x0b\x51\x03\x51\x03\x51\x07\
	\x51\u{86f}\x0a\x51\x0c\x51\x0e\x51\u{872}\x0b\x51\x03\x52\x03\x52\x03\x52\
	\x07\x52\u{877}\x0a\x52\x0c\x52\x0e\x52\u{87a}\x0b\x52\x03\x52\x03\x52\x07\
	\x52\u{87e}\x0a\x52\x0c\x52\x0e\x52\u{881}\x0b\x52\x03\x53\x03\x53\x07\x53\
	\u{885}\x0a\x53\x0c\x53\x0e\x53\u{888}\x0b\x53\x03\x54\x03\x54\x03\x54\x07\
	\x54\u{88d}\x0a\x54\x0c\x54\x0e\x54\u{890}\x0b\x54\x03\x54\x03\x54\x03\x54\
	\x03\x54\x07\x54\u{896}\x0a\x54\x0c\x54\x0e\x54\u{899}\x0b\x54\x03\x54\x03\
	\x54\x07\x54\u{89d}\x0a\x54\x0c\x54\x0e\x54\u{8a0}\x0b\x54\x03\x55\x03\x55\
	\x07\x55\u{8a4}\x0a\x55\x0c\x55\x0e\x55\u{8a7}\x0b\x55\x03\x55\x03\x55\x07\
	\x55\u{8ab}\x0a\x55\x0c\x55\x0e\x55\u{8ae}\x0b\x55\x03\x55\x03\x55\x07\x55\
	\u{8b2}\x0a\x55\x0c\x55\x0e\x55\u{8b5}\x0b\x55\x03\x56\x03\x56\x03\x56\x03\
	\x57\x03\x57\x03\x57\x07\x57\u{8bd}\x0a\x57\x0c\x57\x0e\x57\u{8c0}\x0b\x57\
	\x03\x57\x03\x57\x07\x57\u{8c4}\x0a\x57\x0c\x57\x0e\x57\u{8c7}\x0b\x57\x03\
	\x58\x03\x58\x03\x58\x07\x58\u{8cc}\x0a\x58\x0c\x58\x0e\x58\u{8cf}\x0b\x58\
	\x03\x58\x07\x58\u{8d2}\x0a\x58\x0c\x58\x0e\x58\u{8d5}\x0b\x58\x03\x59\x03\
	\x59\x03\x59\x07\x59\u{8da}\x0a\x59\x0c\x59\x0e\x59\u{8dd}\x0b\x59\x03\x59\
	\x03\x59\x07\x59\u{8e1}\x0a\x59\x0c\x59\x0e\x59\u{8e4}\x0b\x59\x03\x5a\x03\
	\x5a\x03\x5a\x07\x5a\u{8e9}\x0a\x5a\x0c\x5a\x0e\x5a\u{8ec}\x0b\x5a\x03\x5a\
	\x03\x5a\x07\x5a\u{8f0}\x0a\x5a\x0c\x5a\x0e\x5a\u{8f3}\x0b\x5a\x03\x5b\x03\
	\x5b\x07\x5b\u{8f7}\x0a\x5b\x0c\x5b\x0e\x5b\u{8fa}\x0b\x5b\x03\x5b\x03\x5b\
	\x07\x5b\u{8fe}\x0a\x5b\x0c\x5b\x0e\x5b\u{901}\x0b\x5b\x03\x5b\x03\x5b\x07\
	\x5b\u{905}\x0a\x5b\x0c\x5b\x0e\x5b\u{908}\x0b\x5b\x03\x5c\x07\x5c\u{90b}\
	\x0a\x5c\x0c\x5c\x0e\x5c\u{90e}\x0b\x5c\x03\x5c\x03\x5c\x03\x5d\x03\x5d\
	\x03\x5d\x03\x5d\x07\x5d\u{916}\x0a\x5d\x0c\x5d\x0e\x5d\u{919}\x0b\x5d\x05\
	\x5d\u{91b}\x0a\x5d\x03\x5e\x03\x5e\x07\x5e\u{91f}\x0a\x5e\x0c\x5e\x0e\x5e\
	\u{922}\x0b\x5e\x03\x5f\x03\x5f\x03\x5f\x03\x5f\x03\x5f\x05\x5f\u{929}\x0a\
	\x5f\x03\x60\x03\x60\x03\x60\x03\x60\x03\x60\x05\x60\u{930}\x0a\x60\x03\
	\x61\x03\x61\x07\x61\u{934}\x0a\x61\x0c\x61\x0e\x61\u{937}\x0b\x61\x03\x61\
	\x03\x61\x07\x61\u{93b}\x0a\x61\x0c\x61\x0e\x61\u{93e}\x0b\x61\x03\x61\x03\
	\x61\x03\x62\x03\x62\x05\x62\u{944}\x0a\x62\x03\x63\x03\x63\x07\x63\u{948}\
	\x0a\x63\x0c\x63\x0e\x63\u{94b}\x0b\x63\x03\x63\x03\x63\x07\x63\u{94f}\x0a\
	\x63\x0c\x63\x0e\x63\u{952}\x0b\x63\x03\x63\x03\x63\x03\x64\x03\x64\x03\
	\x64\x05\x64\u{959}\x0a\x64\x03\x65\x03\x65\x07\x65\u{95d}\x0a\x65\x0c\x65\
	\x0e\x65\u{960}\x0b\x65\x03\x65\x03\x65\x07\x65\u{964}\x0a\x65\x0c\x65\x0e\
	\x65\u{967}\x0b\x65\x03\x65\x03\x65\x07\x65\u{96b}\x0a\x65\x0c\x65\x0e\x65\
	\u{96e}\x0b\x65\x03\x65\x07\x65\u{971}\x0a\x65\x0c\x65\x0e\x65\u{974}\x0b\
	\x65\x03\x65\x07\x65\u{977}\x0a\x65\x0c\x65\x0e\x65\u{97a}\x0b\x65\x03\x65\
	\x05\x65\u{97d}\x0a\x65\x03\x65\x07\x65\u{980}\x0a\x65\x0c\x65\x0e\x65\u{983}\
	\x0b\x65\x03\x65\x03\x65\x03\x66\x03\x66\x07\x66\u{989}\x0a\x66\x0c\x66\
	\x0e\x66\u{98c}\x0b\x66\x03\x66\x03\x66\x03\x66\x05\x66\u{991}\x0a\x66\x03\
	\x67\x05\x67\u{994}\x0a\x67\x03\x67\x05\x67\u{997}\x0a\x67\x03\x67\x03\x67\
	\x05\x67\u{99b}\x0a\x67\x03\x68\x07\x68\u{99e}\x0a\x68\x0c\x68\x0e\x68\u{9a1}\
	\x0b\x68\x03\x68\x05\x68\u{9a4}\x0a\x68\x03\x68\x07\x68\u{9a7}\x0a\x68\x0c\
	\x68\x0e\x68\u{9aa}\x0b\x68\x03\x68\x03\x68\x03\x69\x03\x69\x07\x69\u{9b0}\
	\x0a\x69\x0c\x69\x0e\x69\u{9b3}\x0b\x69\x03\x69\x03\x69\x07\x69\u{9b7}\x0a\
	\x69\x0c\x69\x0e\x69\u{9ba}\x0b\x69\x03\x69\x03\x69\x07\x69\u{9be}\x0a\x69\
	\x0c\x69\x0e\x69\u{9c1}\x0b\x69\x03\x69\x07\x69\u{9c4}\x0a\x69\x0c\x69\x0e\
	\x69\u{9c7}\x0b\x69\x03\x69\x07\x69\u{9ca}\x0a\x69\x0c\x69\x0e\x69\u{9cd}\
	\x0b\x69\x03\x69\x05\x69\u{9d0}\x0a\x69\x03\x69\x07\x69\u{9d3}\x0a\x69\x0c\
	\x69\x0e\x69\u{9d6}\x0b\x69\x03\x69\x03\x69\x03\x6a\x03\x6a\x07\x6a\u{9dc}\
	\x0a\x6a\x0c\x6a\x0e\x6a\u{9df}\x0b\x6a\x03\x6a\x03\x6a\x07\x6a\u{9e3}\x0a\
	\x6a\x0c\x6a\x0e\x6a\u{9e6}\x0b\x6a\x03\x6a\x03\x6a\x07\x6a\u{9ea}\x0a\x6a\
	\x0c\x6a\x0e\x6a\u{9ed}\x0b\x6a\x03\x6a\x07\x6a\u{9f0}\x0a\x6a\x0c\x6a\x0e\
	\x6a\u{9f3}\x0b\x6a\x03\x6a\x07\x6a\u{9f6}\x0a\x6a\x0c\x6a\x0e\x6a\u{9f9}\
	\x0b\x6a\x03\x6a\x05\x6a\u{9fc}\x0a\x6a\x03\x6a\x07\x6a\u{9ff}\x0a\x6a\x0c\
	\x6a\x0e\x6a\u{a02}\x0b\x6a\x05\x6a\u{a04}\x0a\x6a\x03\x6a\x03\x6a\x03\x6b\
	\x05\x6b\u{a09}\x0a\x6b\x03\x6b\x07\x6b\u{a0c}\x0a\x6b\x0c\x6b\x0e\x6b\u{a0f}\
	\x0b\x6b\x03\x6b\x03\x6b\x07\x6b\u{a13}\x0a\x6b\x0c\x6b\x0e\x6b\u{a16}\x0b\
	\x6b\x03\x6b\x03\x6b\x07\x6b\u{a1a}\x0a\x6b\x0c\x6b\x0e\x6b\u{a1d}\x0b\x6b\
	\x05\x6b\u{a1f}\x0a\x6b\x03\x6b\x05\x6b\u{a22}\x0a\x6b\x03\x6b\x07\x6b\u{a25}\
	\x0a\x6b\x0c\x6b\x0e\x6b\u{a28}\x0b\x6b\x03\x6b\x03\x6b\x03\x6c\x03\x6c\
	\x03\x6c\x03\x6c\x03\x6c\x03\x6c\x03\x6c\x03\x6c\x03\x6c\x03\x6c\x03\x6c\
	\x03\x6c\x03\x6c\x03\x6c\x05\x6c\u{a3a}\x0a\x6c\x03\x6d\x03\x6d\x07\x6d\
	\u{a3e}\x0a\x6d\x0c\x6d\x0e\x6d\u{a41}\x0b\x6d\x03\x6d\x03\x6d\x07\x6d\u{a45}\
	\x0a\x6d\x0c\x6d\x0e\x6d\u{a48}\x0b\x6d\x03\x6d\x03\x6d\x03\x6e\x03\x6e\
	\x07\x6e\u{a4e}\x0a\x6e\x0c\x6e\x0e\x6e\u{a51}\x0b\x6e\x03\x6e\x03\x6e\x07\
	\x6e\u{a55}\x0a\x6e\x0c\x6e\x0e\x6e\u{a58}\x0b\x6e\x03\x6e\x03\x6e\x07\x6e\
	\u{a5c}\x0a\x6e\x0c\x6e\x0e\x6e\u{a5f}\x0b\x6e\x03\x6e\x07\x6e\u{a62}\x0a\
	\x6e\x0c\x6e\x0e\x6e\u{a65}\x0b\x6e\x03\x6e\x07\x6e\u{a68}\x0a\x6e\x0c\x6e\
	\x0e\x6e\u{a6b}\x0b\x6e\x03\x6e\x05\x6e\u{a6e}\x0a\x6e\x03\x6e\x07\x6e\u{a71}\
	\x0a\x6e\x0c\x6e\x0e\x6e\u{a74}\x0b\x6e\x05\x6e\u{a76}\x0a\x6e\x03\x6e\x03\
	\x6e\x03\x6f\x03\x6f\x03\x70\x03\x70\x05\x70\u{a7e}\x0a\x70\x03\x71\x03\
	\x71\x03\x71\x07\x71\u{a83}\x0a\x71\x0c\x71\x0e\x71\u{a86}\x0b\x71\x03\x71\
	\x03\x71\x03\x72\x03\x72\x03\x72\x03\x72\x07\x72\u{a8e}\x0a\x72\x0c\x72\
	\x0e\x72\u{a91}\x0b\x72\x03\x72\x03\x72\x03\x73\x03\x73\x03\x74\x03\x74\
	\x07\x74\u{a99}\x0a\x74\x0c\x74\x0e\x74\u{a9c}\x0b\x74\x03\x74\x03\x74\x07\
	\x74\u{aa0}\x0a\x74\x0c\x74\x0e\x74\u{aa3}\x0b\x74\x03\x74\x03\x74\x03\x75\
	\x03\x75\x03\x76\x03\x76\x07\x76\u{aab}\x0a\x76\x0c\x76\x0e\x76\u{aae}\x0b\
	\x76\x03\x76\x03\x76\x07\x76\u{ab2}\x0a\x76\x0c\x76\x0e\x76\u{ab5}\x0b\x76\
	\x03\x76\x03\x76\x03\x77\x03\x77\x07\x77\u{abb}\x0a\x77\x0c\x77\x0e\x77\
	\u{abe}\x0b\x77\x03\x77\x05\x77\u{ac1}\x0a\x77\x03\x77\x07\x77\u{ac4}\x0a\
	\x77\x0c\x77\x0e\x77\u{ac7}\x0b\x77\x03\x77\x03\x77\x07\x77\u{acb}\x0a\x77\
	\x0c\x77\x0e\x77\u{ace}\x0b\x77\x05\x77\u{ad0}\x0a\x77\x03\x77\x03\x77\x07\
	\x77\u{ad4}\x0a\x77\x0c\x77\x0e\x77\u{ad7}\x0b\x77\x03\x77\x03\x77\x03\x78\
	\x03\x78\x07\x78\u{add}\x0a\x78\x0c\x78\x0e\x78\u{ae0}\x0b\x78\x03\x78\x03\
	\x78\x07\x78\u{ae4}\x0a\x78\x0c\x78\x0e\x78\u{ae7}\x0b\x78\x03\x78\x07\x78\
	\u{aea}\x0a\x78\x0c\x78\x0e\x78\u{aed}\x0b\x78\x03\x78\x07\x78\u{af0}\x0a\
	\x78\x0c\x78\x0e\x78\u{af3}\x0b\x78\x03\x78\x05\x78\u{af6}\x0a\x78\x03\x79\
	\x03\x79\x03\x79\x07\x79\u{afb}\x0a\x79\x0c\x79\x0e\x79\u{afe}\x0b\x79\x03\
	\x79\x03\x79\x07\x79\u{b02}\x0a\x79\x0c\x79\x0e\x79\u{b05}\x0b\x79\x03\x79\
	\x05\x79\u{b08}\x0a\x79\x05\x79\u{b0a}\x0a\x79\x03\x7a\x05\x7a\u{b0d}\x0a\
	\x7a\x03\x7a\x07\x7a\u{b10}\x0a\x7a\x0c\x7a\x0e\x7a\u{b13}\x0b\x7a\x03\x7a\
	\x03\x7a\x07\x7a\u{b17}\x0a\x7a\x0c\x7a\x0e\x7a\u{b1a}\x0b\x7a\x03\x7a\x03\
	\x7a\x07\x7a\u{b1e}\x0a\x7a\x0c\x7a\x0e\x7a\u{b21}\x0b\x7a\x03\x7a\x03\x7a\
	\x05\x7a\u{b25}\x0a\x7a\x03\x7a\x07\x7a\u{b28}\x0a\x7a\x0c\x7a\x0e\x7a\u{b2b}\
	\x0b\x7a\x03\x7a\x03\x7a\x07\x7a\u{b2f}\x0a\x7a\x0c\x7a\x0e\x7a\u{b32}\x0b\
	\x7a\x03\x7a\x03\x7a\x07\x7a\u{b36}\x0a\x7a\x0c\x7a\x0e\x7a\u{b39}\x0b\x7a\
	\x03\x7a\x05\x7a\u{b3c}\x0a\x7a\x03\x7a\x07\x7a\u{b3f}\x0a\x7a\x0c\x7a\x0e\
	\x7a\u{b42}\x0b\x7a\x03\x7a\x05\x7a\u{b45}\x0a\x7a\x03\x7a\x07\x7a\u{b48}\
	\x0a\x7a\x0c\x7a\x0e\x7a\u{b4b}\x0b\x7a\x03\x7a\x05\x7a\u{b4e}\x0a\x7a\x03\
	\x7b\x03\x7b\x05\x7b\u{b52}\x0a\x7b\x03\x7c\x05\x7c\u{b55}\x0a\x7c\x03\x7c\
	\x07\x7c\u{b58}\x0a\x7c\x0c\x7c\x0e\x7c\u{b5b}\x0b\x7c\x03\x7c\x03\x7c\x07\
	\x7c\u{b5f}\x0a\x7c\x0c\x7c\x0e\x7c\u{b62}\x0b\x7c\x03\x7c\x03\x7c\x07\x7c\
	\u{b66}\x0a\x7c\x0c\x7c\x0e\x7c\u{b69}\x0b\x7c\x03\x7c\x03\x7c\x07\x7c\u{b6d}\
	\x0a\x7c\x0c\x7c\x0e\x7c\u{b70}\x0b\x7c\x05\x7c\u{b72}\x0a\x7c\x03\x7c\x07\
	\x7c\u{b75}\x0a\x7c\x0c\x7c\x0e\x7c\u{b78}\x0b\x7c\x03\x7c\x05\x7c\u{b7b}\
	\x0a\x7c\x03\x7d\x03\x7d\x03\x7e\x03\x7e\x03\x7e\x07\x7e\u{b82}\x0a\x7e\
	\x0c\x7e\x0e\x7e\u{b85}\x0b\x7e\x03\x7e\x03\x7e\x07\x7e\u{b89}\x0a\x7e\x0c\
	\x7e\x0e\x7e\u{b8c}\x0b\x7e\x03\x7e\x03\x7e\x05\x7e\u{b90}\x0a\x7e\x03\x7e\
	\x03\x7e\x05\x7e\u{b94}\x0a\x7e\x03\x7e\x05\x7e\u{b97}\x0a\x7e\x03\x7f\x03\
	\x7f\x07\x7f\u{b9b}\x0a\x7f\x0c\x7f\x0e\x7f\u{b9e}\x0b\x7f\x03\x7f\x03\x7f\
	\x07\x7f\u{ba2}\x0a\x7f\x0c\x7f\x0e\x7f\u{ba5}\x0b\x7f\x03\x7f\x03\x7f\x07\
	\x7f\u{ba9}\x0a\x7f\x0c\x7f\x0e\x7f\u{bac}\x0b\x7f\x03\x7f\x03\x7f\x07\x7f\
	\u{bb0}\x0a\x7f\x0c\x7f\x0e\x7f\u{bb3}\x0b\x7f\x03\x7f\x03\x7f\x05\x7f\u{bb7}\
	\x0a\x7f\x03\x7f\x07\x7f\u{bba}\x0a\x7f\x0c\x7f\x0e\x7f\u{bbd}\x0b\x7f\x03\
	\x7f\x05\x7f\u{bc0}\x0a\x7f\x03\x7f\x07\x7f\u{bc3}\x0a\x7f\x0c\x7f\x0e\x7f\
	\u{bc6}\x0b\x7f\x03\x7f\x03\x7f\x07\x7f\u{bca}\x0a\x7f\x0c\x7f\x0e\x7f\u{bcd}\
	\x0b\x7f\x03\x7f\x03\x7f\x05\x7f\u{bd1}\x0a\x7f\x03\x7f\x05\x7f\u{bd4}\x0a\
	\x7f\x03\u{80}\x03\u{80}\x07\u{80}\u{bd8}\x0a\u{80}\x0c\u{80}\x0e\u{80}\
	\u{bdb}\x0b\u{80}\x03\u{80}\x07\u{80}\u{bde}\x0a\u{80}\x0c\u{80}\x0e\u{80}\
	\u{be1}\x0b\u{80}\x03\u{80}\x03\u{80}\x07\u{80}\u{be5}\x0a\u{80}\x0c\u{80}\
	\x0e\u{80}\u{be8}\x0b\u{80}\x03\u{80}\x03\u{80}\x07\u{80}\u{bec}\x0a\u{80}\
	\x0c\u{80}\x0e\u{80}\u{bef}\x0b\u{80}\x03\u{80}\x03\u{80}\x07\u{80}\u{bf3}\
	\x0a\u{80}\x0c\u{80}\x0e\u{80}\u{bf6}\x0b\u{80}\x05\u{80}\u{bf8}\x0a\u{80}\
	\x03\u{80}\x03\u{80}\x03\u{80}\x03\u{81}\x03\u{81}\x07\u{81}\u{bff}\x0a\
	\u{81}\x0c\u{81}\x0e\u{81}\u{c02}\x0b\u{81}\x03\u{81}\x05\u{81}\u{c05}\x0a\
	\u{81}\x03\u{81}\x07\u{81}\u{c08}\x0a\u{81}\x0c\u{81}\x0e\u{81}\u{c0b}\x0b\
	\u{81}\x03\u{81}\x03\u{81}\x07\u{81}\u{c0f}\x0a\u{81}\x0c\u{81}\x0e\u{81}\
	\u{c12}\x0b\u{81}\x03\u{81}\x03\u{81}\x07\u{81}\u{c16}\x0a\u{81}\x0c\u{81}\
	\x0e\u{81}\u{c19}\x0b\u{81}\x07\u{81}\u{c1b}\x0a\u{81}\x0c\u{81}\x0e\u{81}\
	\u{c1e}\x0b\u{81}\x03\u{81}\x07\u{81}\u{c21}\x0a\u{81}\x0c\u{81}\x0e\u{81}\
	\u{c24}\x0b\u{81}\x03\u{81}\x03\u{81}\x03\u{82}\x03\u{82}\x07\u{82}\u{c2a}\
	\x0a\u{82}\x0c\u{82}\x0e\u{82}\u{c2d}\x0b\u{82}\x03\u{82}\x03\u{82}\x07\
	\u{82}\u{c31}\x0a\u{82}\x0c\u{82}\x0e\u{82}\u{c34}\x0b\u{82}\x03\u{82}\x07\
	\u{82}\u{c37}\x0a\u{82}\x0c\u{82}\x0e\u{82}\u{c3a}\x0b\u{82}\x03\u{82}\x07\
	\u{82}\u{c3d}\x0a\u{82}\x0c\u{82}\x0e\u{82}\u{c40}\x0b\u{82}\x03\u{82}\x05\
	\u{82}\u{c43}\x0a\u{82}\x03\u{82}\x07\u{82}\u{c46}\x0a\u{82}\x0c\u{82}\x0e\
	\u{82}\u{c49}\x0b\u{82}\x03\u{82}\x03\u{82}\x07\u{82}\u{c4d}\x0a\u{82}\x0c\
	\u{82}\x0e\u{82}\u{c50}\x0b\u{82}\x03\u{82}\x03\u{82}\x05\u{82}\u{c54}\x0a\
	\u{82}\x03\u{82}\x03\u{82}\x07\u{82}\u{c58}\x0a\u{82}\x0c\u{82}\x0e\u{82}\
	\u{c5b}\x0b\u{82}\x03\u{82}\x03\u{82}\x07\u{82}\u{c5f}\x0a\u{82}\x0c\u{82}\
	\x0e\u{82}\u{c62}\x0b\u{82}\x03\u{82}\x03\u{82}\x05\u{82}\u{c66}\x0a\u{82}\
	\x05\u{82}\u{c68}\x0a\u{82}\x03\u{83}\x03\u{83}\x03\u{83}\x05\u{83}\u{c6d}\
	\x0a\u{83}\x03\u{84}\x03\u{84}\x07\u{84}\u{c71}\x0a\u{84}\x0c\u{84}\x0e\
	\u{84}\u{c74}\x0b\u{84}\x03\u{84}\x03\u{84}\x03\u{85}\x03\u{85}\x07\u{85}\
	\u{c7a}\x0a\u{85}\x0c\u{85}\x0e\u{85}\u{c7d}\x0b\u{85}\x03\u{85}\x03\u{85}\
	\x03\u{86}\x03\u{86}\x07\u{86}\u{c83}\x0a\u{86}\x0c\u{86}\x0e\u{86}\u{c86}\
	\x0b\u{86}\x03\u{86}\x03\u{86}\x07\u{86}\u{c8a}\x0a\u{86}\x0c\u{86}\x0e\
	\u{86}\u{c8d}\x0b\u{86}\x03\u{86}\x06\u{86}\u{c90}\x0a\u{86}\x0d\u{86}\x0e\
	\u{86}\u{c91}\x03\u{86}\x07\u{86}\u{c95}\x0a\u{86}\x0c\u{86}\x0e\u{86}\u{c98}\
	\x0b\u{86}\x03\u{86}\x05\u{86}\u{c9b}\x0a\u{86}\x03\u{86}\x07\u{86}\u{c9e}\
	\x0a\u{86}\x0c\u{86}\x0e\u{86}\u{ca1}\x0b\u{86}\x03\u{86}\x05\u{86}\u{ca4}\
	\x0a\u{86}\x03\u{87}\x03\u{87}\x07\u{87}\u{ca8}\x0a\u{87}\x0c\u{87}\x0e\
	\u{87}\u{cab}\x0b\u{87}\x03\u{87}\x03\u{87}\x07\u{87}\u{caf}\x0a\u{87}\x0c\
	\u{87}\x0e\u{87}\u{cb2}\x0b\u{87}\x03\u{87}\x03\u{87}\x03\u{87}\x03\u{87}\
	\x07\u{87}\u{cb8}\x0a\u{87}\x0c\u{87}\x0e\u{87}\u{cbb}\x0b\u{87}\x03\u{87}\
	\x05\u{87}\u{cbe}\x0a\u{87}\x03\u{87}\x03\u{87}\x07\u{87}\u{cc2}\x0a\u{87}\
	\x0c\u{87}\x0e\u{87}\u{cc5}\x0b\u{87}\x03\u{87}\x03\u{87}\x03\u{88}\x03\
	\u{88}\x07\u{88}\u{ccb}\x0a\u{88}\x0c\u{88}\x0e\u{88}\u{cce}\x0b\u{88}\x03\
	\u{88}\x03\u{88}\x03\u{89}\x03\u{89}\x07\u{89}\u{cd4}\x0a\u{89}\x0c\u{89}\
	\x0e\u{89}\u{cd7}\x0b\u{89}\x03\u{89}\x03\u{89}\x03\u{89}\x05\u{89}\u{cdc}\
	\x0a\u{89}\x03\u{89}\x03\u{89}\x03\u{89}\x03\u{89}\x05\u{89}\u{ce2}\x0a\
	\u{89}\x03\u{8a}\x05\u{8a}\u{ce5}\x0a\u{8a}\x03\u{8a}\x03\u{8a}\x07\u{8a}\
	\u{ce9}\x0a\u{8a}\x0c\u{8a}\x0e\u{8a}\u{cec}\x0b\u{8a}\x03\u{8a}\x03\u{8a}\
	\x05\u{8a}\u{cf0}\x0a\u{8a}\x03\u{8b}\x03\u{8b}\x03\u{8c}\x03\u{8c}\x03\
	\u{8d}\x03\u{8d}\x03\u{8e}\x03\u{8e}\x03\u{8f}\x03\u{8f}\x03\u{90}\x03\u{90}\
	\x03\u{91}\x03\u{91}\x03\u{92}\x03\u{92}\x03\u{93}\x03\u{93}\x03\u{93}\x03\
	\u{93}\x03\u{93}\x05\u{93}\u{d07}\x0a\u{93}\x03\u{94}\x03\u{94}\x03\u{94}\
	\x03\u{94}\x05\u{94}\u{d0d}\x0a\u{94}\x03\u{95}\x03\u{95}\x03\u{96}\x07\
	\u{96}\u{d12}\x0a\u{96}\x0c\u{96}\x0e\u{96}\u{d15}\x0b\u{96}\x03\u{96}\x03\
	\u{96}\x07\u{96}\u{d19}\x0a\u{96}\x0c\u{96}\x0e\u{96}\u{d1c}\x0b\u{96}\x03\
	\u{96}\x03\u{96}\x05\u{96}\u{d20}\x0a\u{96}\x03\u{97}\x03\u{97}\x03\u{97}\
	\x03\u{98}\x03\u{98}\x06\u{98}\u{d27}\x0a\u{98}\x0d\u{98}\x0e\u{98}\u{d28}\
	\x03\u{99}\x03\u{99}\x06\u{99}\u{d2d}\x0a\u{99}\x0d\u{99}\x0e\u{99}\u{d2e}\
	\x03\u{9a}\x03\u{9a}\x03\u{9a}\x03\u{9a}\x03\u{9a}\x03\u{9a}\x03\u{9a}\x03\
	\u{9a}\x05\u{9a}\u{d39}\x0a\u{9a}\x03\u{9a}\x07\u{9a}\u{d3c}\x0a\u{9a}\x0c\
	\u{9a}\x0e\u{9a}\u{d3f}\x0b\u{9a}\x03\u{9b}\x06\u{9b}\u{d42}\x0a\u{9b}\x0d\
	\u{9b}\x0e\u{9b}\u{d43}\x03\u{9c}\x03\u{9c}\x03\u{9c}\x07\u{9c}\u{d49}\x0a\
	\u{9c}\x0c\u{9c}\x0e\u{9c}\u{d4c}\x0b\u{9c}\x05\u{9c}\u{d4e}\x0a\u{9c}\x03\
	\u{9d}\x03\u{9d}\x03\u{9e}\x03\u{9e}\x03\u{9f}\x03\u{9f}\x03\u{a0}\x03\u{a0}\
	\x03\u{a1}\x06\u{a1}\u{d59}\x0a\u{a1}\x0d\u{a1}\x0e\u{a1}\u{d5a}\x03\u{a2}\
	\x03\u{a2}\x07\u{a2}\u{d5f}\x0a\u{a2}\x0c\u{a2}\x0e\u{a2}\u{d62}\x0b\u{a2}\
	\x03\u{a2}\x03\u{a2}\x07\u{a2}\u{d66}\x0a\u{a2}\x0c\u{a2}\x0e\u{a2}\u{d69}\
	\x0b\u{a2}\x03\u{a2}\x05\u{a2}\u{d6c}\x0a\u{a2}\x03\u{a3}\x03\u{a3}\x03\
	\u{a4}\x03\u{a4}\x03\u{a5}\x03\u{a5}\x03\u{a6}\x03\u{a6}\x03\u{a7}\x03\u{a7}\
	\x03\u{a8}\x03\u{a8}\x03\u{a9}\x03\u{a9}\x05\u{a9}\u{d7c}\x0a\u{a9}\x03\
	\u{a9}\x07\u{a9}\u{d7f}\x0a\u{a9}\x0c\u{a9}\x0e\u{a9}\u{d82}\x0b\u{a9}\x03\
	\u{aa}\x03\u{aa}\x07\u{aa}\u{d86}\x0a\u{aa}\x0c\u{aa}\x0e\u{aa}\u{d89}\x0b\
	\u{aa}\x03\u{aa}\x03\u{aa}\x05\u{aa}\u{d8d}\x0a\u{aa}\x03\u{aa}\x03\u{aa}\
	\x03\u{ab}\x03\u{ab}\x07\u{ab}\u{d93}\x0a\u{ab}\x0c\u{ab}\x0e\u{ab}\u{d96}\
	\x0b\u{ab}\x03\u{ab}\x03\u{ab}\x05\u{ab}\u{d9a}\x0a\u{ab}\x03\u{ab}\x03\
	\u{ab}\x06\u{ab}\u{d9e}\x0a\u{ab}\x0d\u{ab}\x0e\u{ab}\u{d9f}\x03\u{ab}\x03\
	\u{ab}\x03\u{ac}\x03\u{ac}\x03\u{ac}\x07\u{ac}\u{da7}\x0a\u{ac}\x0c\u{ac}\
	\x0e\u{ac}\u{daa}\x0b\u{ac}\x03\u{ac}\x03\u{ac}\x03\u{ad}\x03\u{ad}\x05\
	\u{ad}\u{db0}\x0a\u{ad}\x03\u{ae}\x03\u{ae}\x03\u{af}\x03\u{af}\x07\u{af}\
	\u{db6}\x0a\u{af}\x0c\u{af}\x0e\u{af}\u{db9}\x0b\u{af}\x03\u{af}\x03\u{af}\
	\x07\u{af}\u{dbd}\x0a\u{af}\x0c\u{af}\x0e\u{af}\u{dc0}\x0b\u{af}\x03\u{af}\
	\x02\x02\u{b0}\x02\x04\x06\x08\x0a\x0c\x0e\x10\x12\x14\x16\x18\x1a\x1c\x1e\
	\x20\x22\x24\x26\x28\x2a\x2c\x2e\x30\x32\x34\x36\x38\x3a\x3c\x3e\x40\x42\
	\x44\x46\x48\x4a\x4c\x4e\x50\x52\x54\x56\x58\x5a\x5c\x5e\x60\x62\x64\x66\
	\x68\x6a\x6c\x6e\x70\x72\x74\x76\x78\x7a\x7c\x7e\u{80}\u{82}\u{84}\u{86}\
	\u{88}\u{8a}\u{8c}\u{8e}\u{90}\u{92}\u{94}\u{96}\u{98}\u{9a}\u{9c}\u{9e}\
	\u{a0}\u{a2}\u{a4}\u{a6}\u{a8}\u{aa}\u{ac}\u{ae}\u{b0}\u{b2}\u{b4}\u{b6}\
	\u{b8}\u{ba}\u{bc}\u{be}\u{c0}\u{c2}\u{c4}\u{c6}\u{c8}\u{ca}\u{cc}\u{ce}\
	\u{d0}\u{d2}\u{d4}\u{d6}\u{d8}\u{da}\u{dc}\u{de}\u{e0}\u{e2}\u{e4}\u{e6}\
	\u{e8}\u{ea}\u{ec}\u{ee}\u{f0}\u{f2}\u{f4}\u{f6}\u{f8}\u{fa}\u{fc}\u{fe}\
	\u{100}\u{102}\u{104}\u{106}\u{108}\u{10a}\u{10c}\u{10e}\u{110}\u{112}\u{114}\
	\u{116}\u{118}\u{11a}\u{11c}\u{11e}\u{120}\u{122}\u{124}\u{126}\u{128}\u{12a}\
	\u{12c}\u{12e}\u{130}\u{132}\u{134}\u{136}\u{138}\u{13a}\u{13c}\u{13e}\u{140}\
	\u{142}\u{144}\u{146}\u{148}\u{14a}\u{14c}\u{14e}\u{150}\u{152}\u{154}\u{156}\
	\u{158}\u{15a}\u{15c}\x02\x21\x04\x02\x2b\x2b\x2d\x2d\x03\x02\x50\x51\x03\
	\x02\x57\x58\x03\x02\x2f\x30\x03\x02\x2b\x2c\x04\x02\x07\x07\x1d\x1d\x03\
	\x02\x26\x27\x04\x02\u{8b}\u{8b}\u{8e}\u{95}\x03\x02\u{a3}\u{a5}\x03\x02\
	\u{a8}\u{aa}\x04\x02\x3f\x3f\x57\x57\x04\x02\x3c\x3c\x65\x65\x03\x02\x1f\
	\x23\x04\x02\x35\x36\x38\x39\x03\x02\x31\x34\x04\x02\x6a\x6a\x6c\x6c\x04\
	\x02\x69\x69\x6b\x6b\x03\x02\x14\x15\x03\x02\x11\x13\x04\x02\x37\x37\x68\
	\x68\x03\x02\x1a\x1b\x03\x02\x73\x78\x04\x02\x7f\x7f\u{84}\u{84}\x03\x02\
	\x6f\x72\x04\x02\x6a\x6a\x6d\x6d\x03\x02\x79\x7e\x03\x02\u{80}\u{82}\x03\
	\x02\u{85}\u{87}\x03\x02\u{89}\u{8a}\x03\x02\x42\x49\x09\x02\x41\x49\x4b\
	\x4b\x53\x56\x5a\x5a\x5f\x60\x6d\u{8a}\u{96}\u{96}\x02\u{f6b}\x02\u{15f}\
	\x03\x02\x02\x02\x04\u{178}\x03\x02\x02\x02\x06\u{192}\x03\x02\x02\x02\x08\
	\u{198}\x03\x02\x02\x02\x0a\u{1bd}\x03\x02\x02\x02\x0c\u{1c2}\x03\x02\x02\
	\x02\x0e\u{1c5}\x03\x02\x02\x02\x10\u{1cf}\x03\x02\x02\x02\x12\u{1d2}\x03\
	\x02\x02\x02\x14\u{1d7}\x03\x02\x02\x02\x16\u{1fe}\x03\x02\x02\x02\x18\u{201}\
	\x03\x02\x02\x02\x1a\u{25c}\x03\x02\x02\x02\x1c\u{260}\x03\x02\x02\x02\x1e\
	\u{270}\x03\x02\x02\x02\x20\u{29f}\x03\x02\x02\x02\x22\u{2c3}\x03\x02\x02\
	\x02\x24\u{2e3}\x03\x02\x02\x02\x26\u{2e5}\x03\x02\x02\x02\x28\u{2f1}\x03\
	\x02\x02\x02\x2a\u{2fe}\x03\x02\x02\x02\x2c\u{30f}\x03\x02\x02\x02\x2e\u{33c}\
	\x03\x02\x02\x02\x30\u{355}\x03\x02\x02\x02\x32\u{373}\x03\x02\x02\x02\x34\
	\u{38c}\x03\x02\x02\x02\x36\u{393}\x03\x02\x02\x02\x38\u{395}\x03\x02\x02\
	\x02\x3a\u{39f}\x03\x02\x02\x02\x3c\u{3d4}\x03\x02\x02\x02\x3e\u{403}\x03\
	\x02\x02\x02\x40\u{417}\x03\x02\x02\x02\x42\u{46d}\x03\x02\x02\x02\x44\u{472}\
	\x03\x02\x02\x02\x46\u{48c}\x03\x02\x02\x02\x48\u{4b9}\x03\x02\x02\x02\x4a\
	\u{52b}\x03\x02\x02\x02\x4c\u{535}\x03\x02\x02\x02\x4e\u{560}\x03\x02\x02\
	\x02\x50\u{59b}\x03\x02\x02\x02\x52\u{5ca}\x03\x02\x02\x02\x54\u{5dd}\x03\
	\x02\x02\x02\x56\u{5ee}\x03\x02\x02\x02\x58\u{5ff}\x03\x02\x02\x02\x5a\u{623}\
	\x03\x02\x02\x02\x5c\u{646}\x03\x02\x02\x02\x5e\u{64f}\x03\x02\x02\x02\x60\
	\u{671}\x03\x02\x02\x02\x62\u{695}\x03\x02\x02\x02\x64\u{6ab}\x03\x02\x02\
	\x02\x66\u{6b6}\x03\x02\x02\x02\x68\u{6ba}\x03\x02\x02\x02\x6a\u{6c7}\x03\
	\x02\x02\x02\x6c\u{6c9}\x03\x02\x02\x02\x6e\u{6dd}\x03\x02\x02\x02\x70\u{6ec}\
	\x03\x02\x02\x02\x72\u{6ef}\x03\x02\x02\x02\x74\u{6fb}\x03\x02\x02\x02\x76\
	\u{70b}\x03\x02\x02\x02\x78\u{71d}\x03\x02\x02\x02\x7a\u{74f}\x03\x02\x02\
	\x02\x7c\u{760}\x03\x02\x02\x02\x7e\u{767}\x03\x02\x02\x02\u{80}\u{77b}\
	\x03\x02\x02\x02\u{82}\u{79e}\x03\x02\x02\x02\u{84}\u{7a7}\x03\x02\x02\x02\
	\u{86}\u{7b0}\x03\x02\x02\x02\u{88}\u{7ba}\x03\x02\x02\x02\u{8a}\u{7bc}\
	\x03\x02\x02\x02\u{8c}\u{7cf}\x03\x02\x02\x02\u{8e}\u{7d1}\x03\x02\x02\x02\
	\u{90}\u{7ef}\x03\x02\x02\x02\u{92}\u{803}\x03\x02\x02\x02\u{94}\u{824}\
	\x03\x02\x02\x02\u{96}\u{82e}\x03\x02\x02\x02\u{98}\u{836}\x03\x02\x02\x02\
	\u{9a}\u{83a}\x03\x02\x02\x02\u{9c}\u{83c}\x03\x02\x02\x02\u{9e}\u{850}\
	\x03\x02\x02\x02\u{a0}\u{864}\x03\x02\x02\x02\u{a2}\u{873}\x03\x02\x02\x02\
	\u{a4}\u{882}\x03\x02\x02\x02\u{a6}\u{889}\x03\x02\x02\x02\u{a8}\u{8a1}\
	\x03\x02\x02\x02\u{aa}\u{8b6}\x03\x02\x02\x02\u{ac}\u{8b9}\x03\x02\x02\x02\
	\u{ae}\u{8c8}\x03\x02\x02\x02\u{b0}\u{8d6}\x03\x02\x02\x02\u{b2}\u{8e5}\
	\x03\x02\x02\x02\u{b4}\u{8f4}\x03\x02\x02\x02\u{b6}\u{90c}\x03\x02\x02\x02\
	\u{b8}\u{91a}\x03\x02\x02\x02\u{ba}\u{91c}\x03\x02\x02\x02\u{bc}\u{928}\
	\x03\x02\x02\x02\u{be}\u{92f}\x03\x02\x02\x02\u{c0}\u{931}\x03\x02\x02\x02\
	\u{c2}\u{943}\x03\x02\x02\x02\u{c4}\u{945}\x03\x02\x02\x02\u{c6}\u{958}\
	\x03\x02\x02\x02\u{c8}\u{95a}\x03\x02\x02\x02\u{ca}\u{986}\x03\x02\x02\x02\
	\u{cc}\u{993}\x03\x02\x02\x02\u{ce}\u{99f}\x03\x02\x02\x02\u{d0}\u{9ad}\
	\x03\x02\x02\x02\u{d2}\u{9d9}\x03\x02\x02\x02\u{d4}\u{a08}\x03\x02\x02\x02\
	\u{d6}\u{a39}\x03\x02\x02\x02\u{d8}\u{a3b}\x03\x02\x02\x02\u{da}\u{a4b}\
	\x03\x02\x02\x02\u{dc}\u{a79}\x03\x02\x02\x02\u{de}\u{a7d}\x03\x02\x02\x02\
	\u{e0}\u{a7f}\x03\x02\x02\x02\u{e2}\u{a89}\x03\x02\x02\x02\u{e4}\u{a94}\
	\x03\x02\x02\x02\u{e6}\u{a96}\x03\x02\x02\x02\u{e8}\u{aa6}\x03\x02\x02\x02\
	\u{ea}\u{aa8}\x03\x02\x02\x02\u{ec}\u{ab8}\x03\x02\x02\x02\u{ee}\u{ada}\
	\x03\x02\x02\x02\u{f0}\u{b09}\x03\x02\x02\x02\u{f2}\u{b0c}\x03\x02\x02\x02\
	\u{f4}\u{b51}\x03\x02\x02\x02\u{f6}\u{b54}\x03\x02\x02\x02\u{f8}\u{b7c}\
	\x03\x02\x02\x02\u{fa}\u{b96}\x03\x02\x02\x02\u{fc}\u{b98}\x03\x02\x02\x02\
	\u{fe}\u{bd5}\x03\x02\x02\x02\u{100}\u{bfc}\x03\x02\x02\x02\u{102}\u{c67}\
	\x03\x02\x02\x02\u{104}\u{c6c}\x03\x02\x02\x02\u{106}\u{c6e}\x03\x02\x02\
	\x02\u{108}\u{c77}\x03\x02\x02\x02\u{10a}\u{c80}\x03\x02\x02\x02\u{10c}\
	\u{ca5}\x03\x02\x02\x02\u{10e}\u{cc8}\x03\x02\x02\x02\u{110}\u{ce1}\x03\
	\x02\x02\x02\u{112}\u{ce4}\x03\x02\x02\x02\u{114}\u{cf1}\x03\x02\x02\x02\
	\u{116}\u{cf3}\x03\x02\x02\x02\u{118}\u{cf5}\x03\x02\x02\x02\u{11a}\u{cf7}\
	\x03\x02\x02\x02\u{11c}\u{cf9}\x03\x02\x02\x02\u{11e}\u{cfb}\x03\x02\x02\
	\x02\u{120}\u{cfd}\x03\x02\x02\x02\u{122}\u{cff}\x03\x02\x02\x02\u{124}\
	\u{d06}\x03\x02\x02\x02\u{126}\u{d0c}\x03\x02\x02\x02\u{128}\u{d0e}\x03\
	\x02\x02\x02\u{12a}\u{d1f}\x03\x02\x02\x02\u{12c}\u{d21}\x03\x02\x02\x02\
	\u{12e}\u{d26}\x03\x02\x02\x02\u{130}\u{d2c}\x03\x02\x02\x02\u{132}\u{d38}\
	\x03\x02\x02\x02\u{134}\u{d41}\x03\x02\x02\x02\u{136}\u{d4d}\x03\x02\x02\
	\x02\u{138}\u{d4f}\x03\x02\x02\x02\u{13a}\u{d51}\x03\x02\x02\x02\u{13c}\
	\u{d53}\x03\x02\x02\x02\u{13e}\u{d55}\x03\x02\x02\x02\u{140}\u{d58}\x03\
	\x02\x02\x02\u{142}\u{d6b}\x03\x02\x02\x02\u{144}\u{d6d}\x03\x02\x02\x02\
	\u{146}\u{d6f}\x03\x02\x02\x02\u{148}\u{d71}\x03\x02\x02\x02\u{14a}\u{d73}\
	\x03\x02\x02\x02\u{14c}\u{d75}\x03\x02\x02\x02\u{14e}\u{d77}\x03\x02\x02\
	\x02\u{150}\u{d7b}\x03\x02\x02\x02\u{152}\u{d8c}\x03\x02\x02\x02\u{154}\
	\u{d99}\x03\x02\x02\x02\u{156}\u{da3}\x03\x02\x02\x02\u{158}\u{daf}\x03\
	\x02\x02\x02\u{15a}\u{db1}\x03\x02\x02\x02\u{15c}\u{db3}\x03\x02\x02\x02\
	\u{15e}\u{160}\x05\x06\x04\x02\u{15f}\u{15e}\x03\x02\x02\x02\u{15f}\u{160}\
	\x03\x02\x02\x02\u{160}\u{164}\x03\x02\x02\x02\u{161}\u{163}\x07\x07\x02\
	\x02\u{162}\u{161}\x03\x02\x02\x02\u{163}\u{166}\x03\x02\x02\x02\u{164}\
	\u{162}\x03\x02\x02\x02\u{164}\u{165}\x03\x02\x02\x02\u{165}\u{16a}\x03\
	\x02\x02\x02\u{166}\u{164}\x03\x02\x02\x02\u{167}\u{169}\x05\x08\x05\x02\
	\u{168}\u{167}\x03\x02\x02\x02\u{169}\u{16c}\x03\x02\x02\x02\u{16a}\u{168}\
	\x03\x02\x02\x02\u{16a}\u{16b}\x03\x02\x02\x02\u{16b}\u{16d}\x03\x02\x02\
	\x02\u{16c}\u{16a}\x03\x02\x02\x02\u{16d}\u{16e}\x05\x0a\x06\x02\u{16e}\
	\u{172}\x05\x0c\x07\x02\u{16f}\u{171}\x05\x12\x0a\x02\u{170}\u{16f}\x03\
	\x02\x02\x02\u{171}\u{174}\x03\x02\x02\x02\u{172}\u{170}\x03\x02\x02\x02\
	\u{172}\u{173}\x03\x02\x02\x02\u{173}\u{175}\x03\x02\x02\x02\u{174}\u{172}\
	\x03\x02\x02\x02\u{175}\u{176}\x07\x02\x02\x03\u{176}\x03\x03\x02\x02\x02\
	\u{177}\u{179}\x05\x06\x04\x02\u{178}\u{177}\x03\x02\x02\x02\u{178}\u{179}\
	\x03\x02\x02\x02\u{179}\u{17d}\x03\x02\x02\x02\u{17a}\u{17c}\x07\x07\x02\
	\x02\u{17b}\u{17a}\x03\x02\x02\x02\u{17c}\u{17f}\x03\x02\x02\x02\u{17d}\
	\u{17b}\x03\x02\x02\x02\u{17d}\u{17e}\x03\x02\x02\x02\u{17e}\u{183}\x03\
	\x02\x02\x02\u{17f}\u{17d}\x03\x02\x02\x02\u{180}\u{182}\x05\x08\x05\x02\
	\u{181}\u{180}\x03\x02\x02\x02\u{182}\u{185}\x03\x02\x02\x02\u{183}\u{181}\
	\x03\x02\x02\x02\u{183}\u{184}\x03\x02\x02\x02\u{184}\u{186}\x03\x02\x02\
	\x02\u{185}\u{183}\x03\x02\x02\x02\u{186}\u{187}\x05\x0a\x06\x02\u{187}\
	\u{18d}\x05\x0c\x07\x02\u{188}\u{189}\x05\u{84}\x43\x02\u{189}\u{18a}\x05\
	\u{96}\x4c\x02\u{18a}\u{18c}\x03\x02\x02\x02\u{18b}\u{188}\x03\x02\x02\x02\
	\u{18c}\u{18f}\x03\x02\x02\x02\u{18d}\u{18b}\x03\x02\x02\x02\u{18d}\u{18e}\
	\x03\x02\x02\x02\u{18e}\u{190}\x03\x02\x02\x02\u{18f}\u{18d}\x03\x02\x02\
	\x02\u{190}\u{191}\x07\x02\x02\x03\u{191}\x05\x03\x02\x02\x02\u{192}\u{194}\
	\x07\x03\x02\x02\u{193}\u{195}\x07\x07\x02\x02\u{194}\u{193}\x03\x02\x02\
	\x02\u{195}\u{196}\x03\x02\x02\x02\u{196}\u{194}\x03\x02\x02\x02\u{196}\
	\u{197}\x03\x02\x02\x02\u{197}\x07\x03\x02\x02\x02\u{198}\u{199}\x09\x02\
	\x02\x02\u{199}\u{19d}\x07\x41\x02\x02\u{19a}\u{19c}\x07\x07\x02\x02\u{19b}\
	\u{19a}\x03\x02\x02\x02\u{19c}\u{19f}\x03\x02\x02\x02\u{19d}\u{19b}\x03\
	\x02\x02\x02\u{19d}\u{19e}\x03\x02\x02\x02\u{19e}\u{1a0}\x03\x02\x02\x02\
	\u{19f}\u{19d}\x03\x02\x02\x02\u{1a0}\u{1a4}\x07\x1c\x02\x02\u{1a1}\u{1a3}\
	\x07\x07\x02\x02\u{1a2}\u{1a1}\x03\x02\x02\x02\u{1a3}\u{1a6}\x03\x02\x02\
	\x02\u{1a4}\u{1a2}\x03\x02\x02\x02\u{1a4}\u{1a5}\x03\x02\x02\x02\u{1a5}\
	\u{1b0}\x03\x02\x02\x02\u{1a6}\u{1a4}\x03\x02\x02\x02\u{1a7}\u{1a9}\x07\
	\x0d\x02\x02\u{1a8}\u{1aa}\x05\u{158}\u{ad}\x02\u{1a9}\u{1a8}\x03\x02\x02\
	\x02\u{1aa}\u{1ab}\x03\x02\x02\x02\u{1ab}\u{1a9}\x03\x02\x02\x02\u{1ab}\
	\u{1ac}\x03\x02\x02\x02\u{1ac}\u{1ad}\x03\x02\x02\x02\u{1ad}\u{1ae}\x07\
	\x0e\x02\x02\u{1ae}\u{1b1}\x03\x02\x02\x02\u{1af}\u{1b1}\x05\u{158}\u{ad}\
	\x02\u{1b0}\u{1a7}\x03\x02\x02\x02\u{1b0}\u{1af}\x03\x02\x02\x02\u{1b1}\
	\u{1b5}\x03\x02\x02\x02\u{1b2}\u{1b4}\x07\x07\x02\x02\u{1b3}\u{1b2}\x03\
	\x02\x02\x02\u{1b4}\u{1b7}\x03\x02\x02\x02\u{1b5}\u{1b3}\x03\x02\x02\x02\
	\u{1b5}\u{1b6}\x03\x02\x02\x02\u{1b6}\x09\x03\x02\x02\x02\u{1b7}\u{1b5}\
	\x03\x02\x02\x02\u{1b8}\u{1b9}\x07\x4a\x02\x02\u{1b9}\u{1bb}\x05\u{15c}\
	\u{af}\x02\u{1ba}\u{1bc}\x05\u{96}\x4c\x02\u{1bb}\u{1ba}\x03\x02\x02\x02\
	\u{1bb}\u{1bc}\x03\x02\x02\x02\u{1bc}\u{1be}\x03\x02\x02\x02\u{1bd}\u{1b8}\
	\x03\x02\x02\x02\u{1bd}\u{1be}\x03\x02\x02\x02\u{1be}\x0b\x03\x02\x02\x02\
	\u{1bf}\u{1c1}\x05\x0e\x08\x02\u{1c0}\u{1bf}\x03\x02\x02\x02\u{1c1}\u{1c4}\
	\x03\x02\x02\x02\u{1c2}\u{1c0}\x03\x02\x02\x02\u{1c2}\u{1c3}\x03\x02\x02\
	\x02\u{1c3}\x0d\x03\x02\x02\x02\u{1c4}\u{1c2}\x03\x02\x02\x02\u{1c5}\u{1c6}\
	\x07\x4b\x02\x02\u{1c6}\u{1ca}\x05\u{15c}\u{af}\x02\u{1c7}\u{1c8}\x07\x09\
	\x02\x02\u{1c8}\u{1cb}\x07\x11\x02\x02\u{1c9}\u{1cb}\x05\x10\x09\x02\u{1ca}\
	\u{1c7}\x03\x02\x02\x02\u{1ca}\u{1c9}\x03\x02\x02\x02\u{1ca}\u{1cb}\x03\
	\x02\x02\x02\u{1cb}\u{1cd}\x03\x02\x02\x02\u{1cc}\u{1ce}\x05\u{96}\x4c\x02\
	\u{1cd}\u{1cc}\x03\x02\x02\x02\u{1cd}\u{1ce}\x03\x02\x02\x02\u{1ce}\x0f\
	\x03\x02\x02\x02\u{1cf}\u{1d0}\x07\x68\x02\x02\u{1d0}\u{1d1}\x05\u{15a}\
	\u{ae}\x02\u{1d1}\x11\x03\x02\x02\x02\u{1d2}\u{1d4}\x05\x16\x0c\x02\u{1d3}\
	\u{1d5}\x05\u{98}\x4d\x02\u{1d4}\u{1d3}\x03\x02\x02\x02\u{1d4}\u{1d5}\x03\
	\x02\x02\x02\u{1d5}\x13\x03\x02\x02\x02\u{1d6}\u{1d8}\x05\u{12e}\u{98}\x02\
	\u{1d7}\u{1d6}\x03\x02\x02\x02\u{1d7}\u{1d8}\x03\x02\x02\x02\u{1d8}\u{1d9}\
	\x03\x02\x02\x02\u{1d9}\u{1dd}\x07\x52\x02\x02\u{1da}\u{1dc}\x07\x07\x02\
	\x02\u{1db}\u{1da}\x03\x02\x02\x02\u{1dc}\u{1df}\x03\x02\x02\x02\u{1dd}\
	\u{1db}\x03\x02\x02\x02\u{1dd}\u{1de}\x03\x02\x02\x02\u{1de}\u{1e0}\x03\
	\x02\x02\x02\u{1df}\u{1dd}\x03\x02\x02\x02\u{1e0}\u{1e8}\x05\u{15a}\u{ae}\
	\x02\u{1e1}\u{1e3}\x07\x07\x02\x02\u{1e2}\u{1e1}\x03\x02\x02\x02\u{1e3}\
	\u{1e6}\x03\x02\x02\x02\u{1e4}\u{1e2}\x03\x02\x02\x02\u{1e4}\u{1e5}\x03\
	\x02\x02\x02\u{1e5}\u{1e7}\x03\x02\x02\x02\u{1e6}\u{1e4}\x03\x02\x02\x02\
	\u{1e7}\u{1e9}\x05\x2c\x17\x02\u{1e8}\u{1e4}\x03\x02\x02\x02\u{1e8}\u{1e9}\
	\x03\x02\x02\x02\u{1e9}\u{1ed}\x03\x02\x02\x02\u{1ea}\u{1ec}\x07\x07\x02\
	\x02\u{1eb}\u{1ea}\x03\x02\x02\x02\u{1ec}\u{1ef}\x03\x02\x02\x02\u{1ed}\
	\u{1eb}\x03\x02\x02\x02\u{1ed}\u{1ee}\x03\x02\x02\x02\u{1ee}\u{1f0}\x03\
	\x02\x02\x02\u{1ef}\u{1ed}\x03\x02\x02\x02\u{1f0}\u{1f4}\x07\x1e\x02\x02\
	\u{1f1}\u{1f3}\x07\x07\x02\x02\u{1f2}\u{1f1}\x03\x02\x02\x02\u{1f3}\u{1f6}\
	\x03\x02\x02\x02\u{1f4}\u{1f2}\x03\x02\x02\x02\u{1f4}\u{1f5}\x03\x02\x02\
	\x02\u{1f5}\u{1f7}\x03\x02\x02\x02\u{1f6}\u{1f4}\x03\x02\x02\x02\u{1f7}\
	\u{1f8}\x05\x64\x33\x02\u{1f8}\x15\x03\x02\x02\x02\u{1f9}\u{1ff}\x05\x18\
	\x0d\x02\u{1fa}\u{1ff}\x05\x58\x2d\x02\u{1fb}\u{1ff}\x05\x40\x21\x02\u{1fc}\
	\u{1ff}\x05\x48\x25\x02\u{1fd}\u{1ff}\x05\x14\x0b\x02\u{1fe}\u{1f9}\x03\
	\x02\x02\x02\u{1fe}\u{1fa}\x03\x02\x02\x02\u{1fe}\u{1fb}\x03\x02\x02\x02\
	\u{1fe}\u{1fc}\x03\x02\x02\x02\u{1fe}\u{1fd}\x03\x02\x02\x02\u{1ff}\x17\
	\x03\x02\x02\x02\u{200}\u{202}\x05\u{12e}\u{98}\x02\u{201}\u{200}\x03\x02\
	\x02\x02\u{201}\u{202}\x03\x02\x02\x02\u{202}\u{20e}\x03\x02\x02\x02\u{203}\
	\u{20f}\x07\x4c\x02\x02\u{204}\u{208}\x07\x4e\x02\x02\u{205}\u{207}\x07\
	\x07\x02\x02\u{206}\u{205}\x03\x02\x02\x02\u{207}\u{20a}\x03\x02\x02\x02\
	\u{208}\u{206}\x03\x02\x02\x02\u{208}\u{209}\x03\x02\x02\x02\u{209}\u{20c}\
	\x03\x02\x02\x02\u{20a}\u{208}\x03\x02\x02\x02\u{20b}\u{204}\x03\x02\x02\
	\x02\u{20b}\u{20c}\x03\x02\x02\x02\u{20c}\u{20d}\x03\x02\x02\x02\u{20d}\
	\u{20f}\x07\x4d\x02\x02\u{20e}\u{203}\x03\x02\x02\x02\u{20e}\u{20b}\x03\
	\x02\x02\x02\u{20f}\u{213}\x03\x02\x02\x02\u{210}\u{212}\x07\x07\x02\x02\
	\u{211}\u{210}\x03\x02\x02\x02\u{212}\u{215}\x03\x02\x02\x02\u{213}\u{211}\
	\x03\x02\x02\x02\u{213}\u{214}\x03\x02\x02\x02\u{214}\u{216}\x03\x02\x02\
	\x02\u{215}\u{213}\x03\x02\x02\x02\u{216}\u{21e}\x05\u{15a}\u{ae}\x02\u{217}\
	\u{219}\x07\x07\x02\x02\u{218}\u{217}\x03\x02\x02\x02\u{219}\u{21c}\x03\
	\x02\x02\x02\u{21a}\u{218}\x03\x02\x02\x02\u{21a}\u{21b}\x03\x02\x02\x02\
	\u{21b}\u{21d}\x03\x02\x02\x02\u{21c}\u{21a}\x03\x02\x02\x02\u{21d}\u{21f}\
	\x05\x2c\x17\x02\u{21e}\u{21a}\x03\x02\x02\x02\u{21e}\u{21f}\x03\x02\x02\
	\x02\u{21f}\u{227}\x03\x02\x02\x02\u{220}\u{222}\x07\x07\x02\x02\u{221}\
	\u{220}\x03\x02\x02\x02\u{222}\u{225}\x03\x02\x02\x02\u{223}\u{221}\x03\
	\x02\x02\x02\u{223}\u{224}\x03\x02\x02\x02\u{224}\u{226}\x03\x02\x02\x02\
	\u{225}\u{223}\x03\x02\x02\x02\u{226}\u{228}\x05\x1a\x0e\x02\u{227}\u{223}\
	\x03\x02\x02\x02\u{227}\u{228}\x03\x02\x02\x02\u{228}\u{237}\x03\x02\x02\
	\x02\u{229}\u{22b}\x07\x07\x02\x02\u{22a}\u{229}\x03\x02\x02\x02\u{22b}\
	\u{22e}\x03\x02\x02\x02\u{22c}\u{22a}\x03\x02\x02\x02\u{22c}\u{22d}\x03\
	\x02\x02\x02\u{22d}\u{22f}\x03\x02\x02\x02\u{22e}\u{22c}\x03\x02\x02\x02\
	\u{22f}\u{233}\x07\x1c\x02\x02\u{230}\u{232}\x07\x07\x02\x02\u{231}\u{230}\
	\x03\x02\x02\x02\u{232}\u{235}\x03\x02\x02\x02\u{233}\u{231}\x03\x02\x02\
	\x02\u{233}\u{234}\x03\x02\x02\x02\u{234}\u{236}\x03\x02\x02\x02\u{235}\
	\u{233}\x03\x02\x02\x02\u{236}\u{238}\x05\x22\x12\x02\u{237}\u{22c}\x03\
	\x02\x02\x02\u{237}\u{238}\x03\x02\x02\x02\u{238}\u{240}\x03\x02\x02\x02\
	\u{239}\u{23b}\x07\x07\x02\x02\u{23a}\u{239}\x03\x02\x02\x02\u{23b}\u{23e}\
	\x03\x02\x02\x02\u{23c}\u{23a}\x03\x02\x02\x02\u{23c}\u{23d}\x03\x02\x02\
	\x02\u{23d}\u{23f}\x03\x02\x02\x02\u{23e}\u{23c}\x03\x02\x02\x02\u{23f}\
	\u{241}\x05\x30\x19\x02\u{240}\u{23c}\x03\x02\x02\x02\u{240}\u{241}\x03\
	\x02\x02\x02\u{241}\u{250}\x03\x02\x02\x02\u{242}\u{244}\x07\x07\x02\x02\
	\u{243}\u{242}\x03\x02\x02\x02\u{244}\u{247}\x03\x02\x02\x02\u{245}\u{243}\
	\x03\x02\x02\x02\u{245}\u{246}\x03\x02\x02\x02\u{246}\u{248}\x03\x02\x02\
	\x02\u{247}\u{245}\x03\x02\x02\x02\u{248}\u{251}\x05\x1c\x0f\x02\u{249}\
	\u{24b}\x07\x07\x02\x02\u{24a}\u{249}\x03\x02\x02\x02\u{24b}\u{24e}\x03\
	\x02\x02\x02\u{24c}\u{24a}\x03\x02\x02\x02\u{24c}\u{24d}\x03\x02\x02\x02\
	\u{24d}\u{24f}\x03\x02\x02\x02\u{24e}\u{24c}\x03\x02\x02\x02\u{24f}\u{251}\
	\x05\x5e\x30\x02\u{250}\u{245}\x03\x02\x02\x02\u{250}\u{24c}\x03\x02\x02\
	\x02\u{250}\u{251}\x03\x02\x02\x02\u{251}\x19\x03\x02\x02\x02\u{252}\u{254}\
	\x05\u{12e}\u{98}\x02\u{253}\u{252}\x03\x02\x02\x02\u{253}\u{254}\x03\x02\
	\x02\x02\u{254}\u{255}\x03\x02\x02\x02\u{255}\u{259}\x07\x53\x02\x02\u{256}\
	\u{258}\x07\x07\x02\x02\u{257}\u{256}\x03\x02\x02\x02\u{258}\u{25b}\x03\
	\x02\x02\x02\u{259}\u{257}\x03\x02\x02\x02\u{259}\u{25a}\x03\x02\x02\x02\
	\u{25a}\u{25d}\x03\x02\x02\x02\u{25b}\u{259}\x03\x02\x02\x02\u{25c}\u{253}\
	\x03\x02\x02\x02\u{25c}\u{25d}\x03\x02\x02\x02\u{25d}\u{25e}\x03\x02\x02\
	\x02\u{25e}\u{25f}\x05\x1e\x10\x02\u{25f}\x1b\x03\x02\x02\x02\u{260}\u{264}\
	\x07\x0f\x02\x02\u{261}\u{263}\x07\x07\x02\x02\u{262}\u{261}\x03\x02\x02\
	\x02\u{263}\u{266}\x03\x02\x02\x02\u{264}\u{262}\x03\x02\x02\x02\u{264}\
	\u{265}\x03\x02\x02\x02\u{265}\u{267}\x03\x02\x02\x02\u{266}\u{264}\x03\
	\x02\x02\x02\u{267}\u{26b}\x05\x34\x1b\x02\u{268}\u{26a}\x07\x07\x02\x02\
	\u{269}\u{268}\x03\x02\x02\x02\u{26a}\u{26d}\x03\x02\x02\x02\u{26b}\u{269}\
	\x03\x02\x02\x02\u{26b}\u{26c}\x03\x02\x02\x02\u{26c}\u{26e}\x03\x02\x02\
	\x02\u{26d}\u{26b}\x03\x02\x02\x02\u{26e}\u{26f}\x07\x10\x02\x02\u{26f}\
	\x1d\x03\x02\x02\x02\u{270}\u{274}\x07\x0b\x02\x02\u{271}\u{273}\x07\x07\
	\x02\x02\u{272}\u{271}\x03\x02\x02\x02\u{273}\u{276}\x03\x02\x02\x02\u{274}\
	\u{272}\x03\x02\x02\x02\u{274}\u{275}\x03\x02\x02\x02\u{275}\u{294}\x03\
	\x02\x02\x02\u{276}\u{274}\x03\x02\x02\x02\u{277}\u{288}\x05\x20\x11\x02\
	\u{278}\u{27a}\x07\x07\x02\x02\u{279}\u{278}\x03\x02\x02\x02\u{27a}\u{27d}\
	\x03\x02\x02\x02\u{27b}\u{279}\x03\x02\x02\x02\u{27b}\u{27c}\x03\x02\x02\
	\x02\u{27c}\u{27e}\x03\x02\x02\x02\u{27d}\u{27b}\x03\x02\x02\x02\u{27e}\
	\u{282}\x07\x0a\x02\x02\u{27f}\u{281}\x07\x07\x02\x02\u{280}\u{27f}\x03\
	\x02\x02\x02\u{281}\u{284}\x03\x02\x02\x02\u{282}\u{280}\x03\x02\x02\x02\
	\u{282}\u{283}\x03\x02\x02\x02\u{283}\u{285}\x03\x02\x02\x02\u{284}\u{282}\
	\x03\x02\x02\x02\u{285}\u{287}\x05\x20\x11\x02\u{286}\u{27b}\x03\x02\x02\
	\x02\u{287}\u{28a}\x03\x02\x02\x02\u{288}\u{286}\x03\x02\x02\x02\u{288}\
	\u{289}\x03\x02\x02\x02\u{289}\u{292}\x03\x02\x02\x02\u{28a}\u{288}\x03\
	\x02\x02\x02\u{28b}\u{28d}\x07\x07\x02\x02\u{28c}\u{28b}\x03\x02\x02\x02\
	\u{28d}\u{290}\x03\x02\x02\x02\u{28e}\u{28c}\x03\x02\x02\x02\u{28e}\u{28f}\
	\x03\x02\x02\x02\u{28f}\u{291}\x03\x02\x02\x02\u{290}\u{28e}\x03\x02\x02\
	\x02\u{291}\u{293}\x07\x0a\x02\x02\u{292}\u{28e}\x03\x02\x02\x02\u{292}\
	\u{293}\x03\x02\x02\x02\u{293}\u{295}\x03\x02\x02\x02\u{294}\u{277}\x03\
	\x02\x02\x02\u{294}\u{295}\x03\x02\x02\x02\u{295}\u{299}\x03\x02\x02\x02\
	\u{296}\u{298}\x07\x07\x02\x02\u{297}\u{296}\x03\x02\x02\x02\u{298}\u{29b}\
	\x03\x02\x02\x02\u{299}\u{297}\x03\x02\x02\x02\u{299}\u{29a}\x03\x02\x02\
	\x02\u{29a}\u{29c}\x03\x02\x02\x02\u{29b}\u{299}\x03\x02\x02\x02\u{29c}\
	\u{29d}\x07\x0c\x02\x02\u{29d}\x1f\x03\x02\x02\x02\u{29e}\u{2a0}\x05\u{12e}\
	\u{98}\x02\u{29f}\u{29e}\x03\x02\x02\x02\u{29f}\u{2a0}\x03\x02\x02\x02\u{2a0}\
	\u{2a2}\x03\x02\x02\x02\u{2a1}\u{2a3}\x09\x03\x02\x02\u{2a2}\u{2a1}\x03\
	\x02\x02\x02\u{2a2}\u{2a3}\x03\x02\x02\x02\u{2a3}\u{2a7}\x03\x02\x02\x02\
	\u{2a4}\u{2a6}\x07\x07\x02\x02\u{2a5}\u{2a4}\x03\x02\x02\x02\u{2a6}\u{2a9}\
	\x03\x02\x02\x02\u{2a7}\u{2a5}\x03\x02\x02\x02\u{2a7}\u{2a8}\x03\x02\x02\
	\x02\u{2a8}\u{2aa}\x03\x02\x02\x02\u{2a9}\u{2a7}\x03\x02\x02\x02\u{2aa}\
	\u{2ab}\x05\u{15a}\u{ae}\x02\u{2ab}\u{2af}\x07\x1c\x02\x02\u{2ac}\u{2ae}\
	\x07\x07\x02\x02\u{2ad}\u{2ac}\x03\x02\x02\x02\u{2ae}\u{2b1}\x03\x02\x02\
	\x02\u{2af}\u{2ad}\x03\x02\x02\x02\u{2af}\u{2b0}\x03\x02\x02\x02\u{2b0}\
	\u{2b2}\x03\x02\x02\x02\u{2b1}\u{2af}\x03\x02\x02\x02\u{2b2}\u{2c1}\x05\
	\x64\x33\x02\u{2b3}\u{2b5}\x07\x07\x02\x02\u{2b4}\u{2b3}\x03\x02\x02\x02\
	\u{2b5}\u{2b8}\x03\x02\x02\x02\u{2b6}\u{2b4}\x03\x02\x02\x02\u{2b6}\u{2b7}\
	\x03\x02\x02\x02\u{2b7}\u{2b9}\x03\x02\x02\x02\u{2b8}\u{2b6}\x03\x02\x02\
	\x02\u{2b9}\u{2bd}\x07\x1e\x02\x02\u{2ba}\u{2bc}\x07\x07\x02\x02\u{2bb}\
	\u{2ba}\x03\x02\x02\x02\u{2bc}\u{2bf}\x03\x02\x02\x02\u{2bd}\u{2bb}\x03\
	\x02\x02\x02\u{2bd}\u{2be}\x03\x02\x02\x02\u{2be}\u{2c0}\x03\x02\x02\x02\
	\u{2bf}\u{2bd}\x03\x02\x02\x02\u{2c0}\u{2c2}\x05\u{9a}\x4e\x02\u{2c1}\u{2b6}\
	\x03\x02\x02\x02\u{2c1}\u{2c2}\x03\x02\x02\x02\u{2c2}\x21\x03\x02\x02\x02\
	\u{2c3}\u{2d4}\x05\x28\x15\x02\u{2c4}\u{2c6}\x07\x07\x02\x02\u{2c5}\u{2c4}\
	\x03\x02\x02\x02\u{2c6}\u{2c9}\x03\x02\x02\x02\u{2c7}\u{2c5}\x03\x02\x02\
	\x02\u{2c7}\u{2c8}\x03\x02\x02\x02\u{2c8}\u{2ca}\x03\x02\x02\x02\u{2c9}\
	\u{2c7}\x03\x02\x02\x02\u{2ca}\u{2ce}\x07\x0a\x02\x02\u{2cb}\u{2cd}\x07\
	\x07\x02\x02\u{2cc}\u{2cb}\x03\x02\x02\x02\u{2cd}\u{2d0}\x03\x02\x02\x02\
	\u{2ce}\u{2cc}\x03\x02\x02\x02\u{2ce}\u{2cf}\x03\x02\x02\x02\u{2cf}\u{2d1}\
	\x03\x02\x02\x02\u{2d0}\u{2ce}\x03\x02\x02\x02\u{2d1}\u{2d3}\x05\x28\x15\
	\x02\u{2d2}\u{2c7}\x03\x02\x02\x02\u{2d3}\u{2d6}\x03\x02\x02\x02\u{2d4}\
	\u{2d2}\x03\x02\x02\x02\u{2d4}\u{2d5}\x03\x02\x02\x02\u{2d5}\x23\x03\x02\
	\x02\x02\u{2d6}\u{2d4}\x03\x02\x02\x02\u{2d7}\u{2e4}\x05\x26\x14\x02\u{2d8}\
	\u{2e4}\x05\x2a\x16\x02\u{2d9}\u{2e4}\x05\x6c\x37\x02\u{2da}\u{2e4}\x05\
	\x76\x3c\x02\u{2db}\u{2df}\x07\x7e\x02\x02\u{2dc}\u{2de}\x07\x07\x02\x02\
	\u{2dd}\u{2dc}\x03\x02\x02\x02\u{2de}\u{2e1}\x03\x02\x02\x02\u{2df}\u{2dd}\
	\x03\x02\x02\x02\u{2df}\u{2e0}\x03\x02\x02\x02\u{2e0}\u{2e2}\x03\x02\x02\
	\x02\u{2e1}\u{2df}\x03\x02\x02\x02\u{2e2}\u{2e4}\x05\x76\x3c\x02\u{2e3}\
	\u{2d7}\x03\x02\x02\x02\u{2e3}\u{2d8}\x03\x02\x02\x02\u{2e3}\u{2d9}\x03\
	\x02\x02\x02\u{2e3}\u{2da}\x03\x02\x02\x02\u{2e3}\u{2db}\x03\x02\x02\x02\
	\u{2e4}\x25\x03\x02\x02\x02\u{2e5}\u{2e9}\x05\x6c\x37\x02\u{2e6}\u{2e8}\
	\x07\x07\x02\x02\u{2e7}\u{2e6}\x03\x02\x02\x02\u{2e8}\u{2eb}\x03\x02\x02\
	\x02\u{2e9}\u{2e7}\x03\x02\x02\x02\u{2e9}\u{2ea}\x03\x02\x02\x02\u{2ea}\
	\u{2ec}\x03\x02\x02\x02\u{2eb}\u{2e9}\x03\x02\x02\x02\u{2ec}\u{2ed}\x05\
	\u{d2}\x6a\x02\u{2ed}\x27\x03\x02\x02\x02\u{2ee}\u{2f0}\x05\u{150}\u{a9}\
	\x02\u{2ef}\u{2ee}\x03\x02\x02\x02\u{2f0}\u{2f3}\x03\x02\x02\x02\u{2f1}\
	\u{2ef}\x03\x02\x02\x02\u{2f1}\u{2f2}\x03\x02\x02\x02\u{2f2}\u{2f7}\x03\
	\x02\x02\x02\u{2f3}\u{2f1}\x03\x02\x02\x02\u{2f4}\u{2f6}\x07\x07\x02\x02\
	\u{2f5}\u{2f4}\x03\x02\x02\x02\u{2f6}\u{2f9}\x03\x02\x02\x02\u{2f7}\u{2f5}\
	\x03\x02\x02\x02\u{2f7}\u{2f8}\x03\x02\x02\x02\u{2f8}\u{2fa}\x03\x02\x02\
	\x02\u{2f9}\u{2f7}\x03\x02\x02\x02\u{2fa}\u{2fb}\x05\x24\x13\x02\u{2fb}\
	\x29\x03\x02\x02\x02\u{2fc}\u{2ff}\x05\x6c\x37\x02\u{2fd}\u{2ff}\x05\x76\
	\x3c\x02\u{2fe}\u{2fc}\x03\x02\x02\x02\u{2fe}\u{2fd}\x03\x02\x02\x02\u{2ff}\
	\u{303}\x03\x02\x02\x02\u{300}\u{302}\x07\x07\x02\x02\u{301}\u{300}\x03\
	\x02\x02\x02\u{302}\u{305}\x03\x02\x02\x02\u{303}\u{301}\x03\x02\x02\x02\
	\u{303}\u{304}\x03\x02\x02\x02\u{304}\u{306}\x03\x02\x02\x02\u{305}\u{303}\
	\x03\x02\x02\x02\u{306}\u{30a}\x07\x54\x02\x02\u{307}\u{309}\x07\x07\x02\
	\x02\u{308}\u{307}\x03\x02\x02\x02\u{309}\u{30c}\x03\x02\x02\x02\u{30a}\
	\u{308}\x03\x02\x02\x02\u{30a}\u{30b}\x03\x02\x02\x02\u{30b}\u{30d}\x03\
	\x02\x02\x02\u{30c}\u{30a}\x03\x02\x02\x02\u{30d}\u{30e}\x05\u{9a}\x4e\x02\
	\u{30e}\x2b\x03\x02\x02\x02\u{30f}\u{313}\x07\x31\x02\x02\u{310}\u{312}\
	\x07\x07\x02\x02\u{311}\u{310}\x03\x02\x02\x02\u{312}\u{315}\x03\x02\x02\
	\x02\u{313}\u{311}\x03\x02\x02\x02\u{313}\u{314}\x03\x02\x02\x02\u{314}\
	\u{316}\x03\x02\x02\x02\u{315}\u{313}\x03\x02\x02\x02\u{316}\u{327}\x05\
	\x2e\x18\x02\u{317}\u{319}\x07\x07\x02\x02\u{318}\u{317}\x03\x02\x02\x02\
	\u{319}\u{31c}\x03\x02\x02\x02\u{31a}\u{318}\x03\x02\x02\x02\u{31a}\u{31b}\
	\x03\x02\x02\x02\u{31b}\u{31d}\x03\x02\x02\x02\u{31c}\u{31a}\x03\x02\x02\
	\x02\u{31d}\u{321}\x07\x0a\x02\x02\u{31e}\u{320}\x07\x07\x02\x02\u{31f}\
	\u{31e}\x03\x02\x02\x02\u{320}\u{323}\x03\x02\x02\x02\u{321}\u{31f}\x03\
	\x02\x02\x02\u{321}\u{322}\x03\x02\x02\x02\u{322}\u{324}\x03\x02\x02\x02\
	\u{323}\u{321}\x03\x02\x02\x02\u{324}\u{326}\x05\x2e\x18\x02\u{325}\u{31a}\
	\x03\x02\x02\x02\u{326}\u{329}\x03\x02\x02\x02\u{327}\u{325}\x03\x02\x02\
	\x02\u{327}\u{328}\x03\x02\x02\x02\u{328}\u{331}\x03\x02\x02\x02\u{329}\
	\u{327}\x03\x02\x02\x02\u{32a}\u{32c}\x07\x07\x02\x02\u{32b}\u{32a}\x03\
	\x02\x02\x02\u{32c}\u{32f}\x03\x02\x02\x02\u{32d}\u{32b}\x03\x02\x02\x02\
	\u{32d}\u{32e}\x03\x02\x02\x02\u{32e}\u{330}\x03\x02\x02\x02\u{32f}\u{32d}\
	\x03\x02\x02\x02\u{330}\u{332}\x07\x0a\x02\x02\u{331}\u{32d}\x03\x02\x02\
	\x02\u{331}\u{332}\x03\x02\x02\x02\u{332}\u{336}\x03\x02\x02\x02\u{333}\
	\u{335}\x07\x07\x02\x02\u{334}\u{333}\x03\x02\x02\x02\u{335}\u{338}\x03\
	\x02\x02\x02\u{336}\u{334}\x03\x02\x02\x02\u{336}\u{337}\x03\x02\x02\x02\
	\u{337}\u{339}\x03\x02\x02\x02\u{338}\u{336}\x03\x02\x02\x02\u{339}\u{33a}\
	\x07\x32\x02\x02\u{33a}\x2d\x03\x02\x02\x02\u{33b}\u{33d}\x05\u{140}\u{a1}\
	\x02\u{33c}\u{33b}\x03\x02\x02\x02\u{33c}\u{33d}\x03\x02\x02\x02\u{33d}\
	\u{341}\x03\x02\x02\x02\u{33e}\u{340}\x07\x07\x02\x02\u{33f}\u{33e}\x03\
	\x02\x02\x02\u{340}\u{343}\x03\x02\x02\x02\u{341}\u{33f}\x03\x02\x02\x02\
	\u{341}\u{342}\x03\x02\x02\x02\u{342}\u{344}\x03\x02\x02\x02\u{343}\u{341}\
	\x03\x02\x02\x02\u{344}\u{353}\x05\u{15a}\u{ae}\x02\u{345}\u{347}\x07\x07\
	\x02\x02\u{346}\u{345}\x03\x02\x02\x02\u{347}\u{34a}\x03\x02\x02\x02\u{348}\
	\u{346}\x03\x02\x02\x02\u{348}\u{349}\x03\x02\x02\x02\u{349}\u{34b}\x03\
	\x02\x02\x02\u{34a}\u{348}\x03\x02\x02\x02\u{34b}\u{34f}\x07\x1c\x02\x02\
	\u{34c}\u{34e}\x07\x07\x02\x02\u{34d}\u{34c}\x03\x02\x02\x02\u{34e}\u{351}\
	\x03\x02\x02\x02\u{34f}\u{34d}\x03\x02\x02\x02\u{34f}\u{350}\x03\x02\x02\
	\x02\u{350}\u{352}\x03\x02\x02\x02\u{351}\u{34f}\x03\x02\x02\x02\u{352}\
	\u{354}\x05\x64\x33\x02\u{353}\u{348}\x03\x02\x02\x02\u{353}\u{354}\x03\
	\x02\x02\x02\u{354}\x2f\x03\x02\x02\x02\u{355}\u{359}\x07\x5a\x02\x02\u{356}\
	\u{358}\x07\x07\x02\x02\u{357}\u{356}\x03\x02\x02\x02\u{358}\u{35b}\x03\
	\x02\x02\x02\u{359}\u{357}\x03\x02\x02\x02\u{359}\u{35a}\x03\x02\x02\x02\
	\u{35a}\u{35c}\x03\x02\x02\x02\u{35b}\u{359}\x03\x02\x02\x02\u{35c}\u{36d}\
	\x05\x32\x1a\x02\u{35d}\u{35f}\x07\x07\x02\x02\u{35e}\u{35d}\x03\x02\x02\
	\x02\u{35f}\u{362}\x03\x02\x02\x02\u{360}\u{35e}\x03\x02\x02\x02\u{360}\
	\u{361}\x03\x02\x02\x02\u{361}\u{363}\x03\x02\x02\x02\u{362}\u{360}\x03\
	\x02\x02\x02\u{363}\u{367}\x07\x0a\x02\x02\u{364}\u{366}\x07\x07\x02\x02\
	\u{365}\u{364}\x03\x02\x02\x02\u{366}\u{369}\x03\x02\x02\x02\u{367}\u{365}\
	\x03\x02\x02\x02\u{367}\u{368}\x03\x02\x02\x02\u{368}\u{36a}\x03\x02\x02\
	\x02\u{369}\u{367}\x03\x02\x02\x02\u{36a}\u{36c}\x05\x32\x1a\x02\u{36b}\
	\u{360}\x03\x02\x02\x02\u{36c}\u{36f}\x03\x02\x02\x02\u{36d}\u{36b}\x03\
	\x02\x02\x02\u{36d}\u{36e}\x03\x02\x02\x02\u{36e}\x31\x03\x02\x02\x02\u{36f}\
	\u{36d}\x03\x02\x02\x02\u{370}\u{372}\x05\u{150}\u{a9}\x02\u{371}\u{370}\
	\x03\x02\x02\x02\u{372}\u{375}\x03\x02\x02\x02\u{373}\u{371}\x03\x02\x02\
	\x02\u{373}\u{374}\x03\x02\x02\x02\u{374}\u{376}\x03\x02\x02\x02\u{375}\
	\u{373}\x03\x02\x02\x02\u{376}\u{37a}\x05\u{15a}\u{ae}\x02\u{377}\u{379}\
	\x07\x07\x02\x02\u{378}\u{377}\x03\x02\x02\x02\u{379}\u{37c}\x03\x02\x02\
	\x02\u{37a}\u{378}\x03\x02\x02\x02\u{37a}\u{37b}\x03\x02\x02\x02\u{37b}\
	\u{37d}\x03\x02\x02\x02\u{37c}\u{37a}\x03\x02\x02\x02\u{37d}\u{381}\x07\
	\x1c\x02\x02\u{37e}\u{380}\x07\x07\x02\x02\u{37f}\u{37e}\x03\x02\x02\x02\
	\u{380}\u{383}\x03\x02\x02\x02\u{381}\u{37f}\x03\x02\x02\x02\u{381}\u{382}\
	\x03\x02\x02\x02\u{382}\u{384}\x03\x02\x02\x02\u{383}\u{381}\x03\x02\x02\
	\x02\u{384}\u{385}\x05\x64\x33\x02\u{385}\x33\x03\x02\x02\x02\u{386}\u{388}\
	\x05\x36\x1c\x02\u{387}\u{389}\x05\u{98}\x4d\x02\u{388}\u{387}\x03\x02\x02\
	\x02\u{388}\u{389}\x03\x02\x02\x02\u{389}\u{38b}\x03\x02\x02\x02\u{38a}\
	\u{386}\x03\x02\x02\x02\u{38b}\u{38e}\x03\x02\x02\x02\u{38c}\u{38a}\x03\
	\x02\x02\x02\u{38c}\u{38d}\x03\x02\x02\x02\u{38d}\x35\x03\x02\x02\x02\u{38e}\
	\u{38c}\x03\x02\x02\x02\u{38f}\u{394}\x05\x16\x0c\x02\u{390}\u{394}\x05\
	\x3a\x1e\x02\u{391}\u{394}\x05\x38\x1d\x02\u{392}\u{394}\x05\x5a\x2e\x02\
	\u{393}\u{38f}\x03\x02\x02\x02\u{393}\u{390}\x03\x02\x02\x02\u{393}\u{391}\
	\x03\x02\x02\x02\u{393}\u{392}\x03\x02\x02\x02\u{394}\x37\x03\x02\x02\x02\
	\u{395}\u{399}\x07\x56\x02\x02\u{396}\u{398}\x07\x07\x02\x02\u{397}\u{396}\
	\x03\x02\x02\x02\u{398}\u{39b}\x03\x02\x02\x02\u{399}\u{397}\x03\x02\x02\
	\x02\u{399}\u{39a}\x03\x02\x02\x02\u{39a}\u{39c}\x03\x02\x02\x02\u{39b}\
	\u{399}\x03\x02\x02\x02\u{39c}\u{39d}\x05\u{8a}\x46\x02\u{39d}\x39\x03\x02\
	\x02\x02\u{39e}\u{3a0}\x05\u{12e}\u{98}\x02\u{39f}\u{39e}\x03\x02\x02\x02\
	\u{39f}\u{3a0}\x03\x02\x02\x02\u{3a0}\u{3a1}\x03\x02\x02\x02\u{3a1}\u{3a5}\
	\x07\x55\x02\x02\u{3a2}\u{3a4}\x07\x07\x02\x02\u{3a3}\u{3a2}\x03\x02\x02\
	\x02\u{3a4}\u{3a7}\x03\x02\x02\x02\u{3a5}\u{3a3}\x03\x02\x02\x02\u{3a5}\
	\u{3a6}\x03\x02\x02\x02\u{3a6}\u{3a9}\x03\x02\x02\x02\u{3a7}\u{3a5}\x03\
	\x02\x02\x02\u{3a8}\u{3aa}\x07\x76\x02\x02\u{3a9}\u{3a8}\x03\x02\x02\x02\
	\u{3a9}\u{3aa}\x03\x02\x02\x02\u{3aa}\u{3ae}\x03\x02\x02\x02\u{3ab}\u{3ad}\
	\x07\x07\x02\x02\u{3ac}\u{3ab}\x03\x02\x02\x02\u{3ad}\u{3b0}\x03\x02\x02\
	\x02\u{3ae}\u{3ac}\x03\x02\x02\x02\u{3ae}\u{3af}\x03\x02\x02\x02\u{3af}\
	\u{3b1}\x03\x02\x02\x02\u{3b0}\u{3ae}\x03\x02\x02\x02\u{3b1}\u{3b9}\x07\
	\x4f\x02\x02\u{3b2}\u{3b4}\x07\x07\x02\x02\u{3b3}\u{3b2}\x03\x02\x02\x02\
	\u{3b4}\u{3b7}\x03\x02\x02\x02\u{3b5}\u{3b3}\x03\x02\x02\x02\u{3b5}\u{3b6}\
	\x03\x02\x02\x02\u{3b6}\u{3b8}\x03\x02\x02\x02\u{3b7}\u{3b5}\x03\x02\x02\
	\x02\u{3b8}\u{3ba}\x05\u{15a}\u{ae}\x02\u{3b9}\u{3b5}\x03\x02\x02\x02\u{3b9}\
	\u{3ba}\x03\x02\x02\x02\u{3ba}\u{3c9}\x03\x02\x02\x02\u{3bb}\u{3bd}\x07\
	\x07\x02\x02\u{3bc}\u{3bb}\x03\x02\x02\x02\u{3bd}\u{3c0}\x03\x02\x02\x02\
	\u{3be}\u{3bc}\x03\x02\x02\x02\u{3be}\u{3bf}\x03\x02\x02\x02\u{3bf}\u{3c1}\
	\x03\x02\x02\x02\u{3c0}\u{3be}\x03\x02\x02\x02\u{3c1}\u{3c5}\x07\x1c\x02\
	\x02\u{3c2}\u{3c4}\x07\x07\x02\x02\u{3c3}\u{3c2}\x03\x02\x02\x02\u{3c4}\
	\u{3c7}\x03\x02\x02\x02\u{3c5}\u{3c3}\x03\x02\x02\x02\u{3c5}\u{3c6}\x03\
	\x02\x02\x02\u{3c6}\u{3c8}\x03\x02\x02\x02\u{3c7}\u{3c5}\x03\x02\x02\x02\
	\u{3c8}\u{3ca}\x05\x22\x12\x02\u{3c9}\u{3be}\x03\x02\x02\x02\u{3c9}\u{3ca}\
	\x03\x02\x02\x02\u{3ca}\u{3d2}\x03\x02\x02\x02\u{3cb}\u{3cd}\x07\x07\x02\
	\x02\u{3cc}\u{3cb}\x03\x02\x02\x02\u{3cd}\u{3d0}\x03\x02\x02\x02\u{3ce}\
	\u{3cc}\x03\x02\x02\x02\u{3ce}\u{3cf}\x03\x02\x02\x02\u{3cf}\u{3d1}\x03\
	\x02\x02\x02\u{3d0}\u{3ce}\x03\x02\x02\x02\u{3d1}\u{3d3}\x05\x1c\x0f\x02\
	\u{3d2}\u{3ce}\x03\x02\x02\x02\u{3d2}\u{3d3}\x03\x02\x02\x02\u{3d3}\x3b\
	\x03\x02\x02\x02\u{3d4}\u{3d8}\x07\x0b\x02\x02\u{3d5}\u{3d7}\x07\x07\x02\
	\x02\u{3d6}\u{3d5}\x03\x02\x02\x02\u{3d7}\u{3da}\x03\x02\x02\x02\u{3d8}\
	\u{3d6}\x03\x02\x02\x02\u{3d8}\u{3d9}\x03\x02\x02\x02\u{3d9}\u{3f8}\x03\
	\x02\x02\x02\u{3da}\u{3d8}\x03\x02\x02\x02\u{3db}\u{3ec}\x05\x3e\x20\x02\
	\u{3dc}\u{3de}\x07\x07\x02\x02\u{3dd}\u{3dc}\x03\x02\x02\x02\u{3de}\u{3e1}\
	\x03\x02\x02\x02\u{3df}\u{3dd}\x03\x02\x02\x02\u{3df}\u{3e0}\x03\x02\x02\
	\x02\u{3e0}\u{3e2}\x03\x02\x02\x02\u{3e1}\u{3df}\x03\x02\x02\x02\u{3e2}\
	\u{3e6}\x07\x0a\x02\x02\u{3e3}\u{3e5}\x07\x07\x02\x02\u{3e4}\u{3e3}\x03\
	\x02\x02\x02\u{3e5}\u{3e8}\x03\x02\x02\x02\u{3e6}\u{3e4}\x03\x02\x02\x02\
	\u{3e6}\u{3e7}\x03\x02\x02\x02\u{3e7}\u{3e9}\x03\x02\x02\x02\u{3e8}\u{3e6}\
	\x03\x02\x02\x02\u{3e9}\u{3eb}\x05\x3e\x20\x02\u{3ea}\u{3df}\x03\x02\x02\
	\x02\u{3eb}\u{3ee}\x03\x02\x02\x02\u{3ec}\u{3ea}\x03\x02\x02\x02\u{3ec}\
	\u{3ed}\x03\x02\x02\x02\u{3ed}\u{3f6}\x03\x02\x02\x02\u{3ee}\u{3ec}\x03\
	\x02\x02\x02\u{3ef}\u{3f1}\x07\x07\x02\x02\u{3f0}\u{3ef}\x03\x02\x02\x02\
	\u{3f1}\u{3f4}\x03\x02\x02\x02\u{3f2}\u{3f0}\x03\x02\x02\x02\u{3f2}\u{3f3}\
	\x03\x02\x02\x02\u{3f3}\u{3f5}\x03\x02\x02\x02\u{3f4}\u{3f2}\x03\x02\x02\
	\x02\u{3f5}\u{3f7}\x07\x0a\x02\x02\u{3f6}\u{3f2}\x03\x02\x02\x02\u{3f6}\
	\u{3f7}\x03\x02\x02\x02\u{3f7}\u{3f9}\x03\x02\x02\x02\u{3f8}\u{3db}\x03\
	\x02\x02\x02\u{3f8}\u{3f9}\x03\x02\x02\x02\u{3f9}\u{3fd}\x03\x02\x02\x02\
	\u{3fa}\u{3fc}\x07\x07\x02\x02\u{3fb}\u{3fa}\x03\x02\x02\x02\u{3fc}\u{3ff}\
	\x03\x02\x02\x02\u{3fd}\u{3fb}\x03\x02\x02\x02\u{3fd}\u{3fe}\x03\x02\x02\
	\x02\u{3fe}\u{400}\x03\x02\x02\x02\u{3ff}\u{3fd}\x03\x02\x02\x02\u{400}\
	\u{401}\x07\x0c\x02\x02\u{401}\x3d\x03\x02\x02\x02\u{402}\u{404}\x05\u{130}\
	\u{99}\x02\u{403}\u{402}\x03\x02\x02\x02\u{403}\u{404}\x03\x02\x02\x02\u{404}\
	\u{405}\x03\x02\x02\x02\u{405}\u{414}\x05\x56\x2c\x02\u{406}\u{408}\x07\
	\x07\x02\x02\u{407}\u{406}\x03\x02\x02\x02\u{408}\u{40b}\x03\x02\x02\x02\
	\u{409}\u{407}\x03\x02\x02\x02\u{409}\u{40a}\x03\x02\x02\x02\u{40a}\u{40c}\
	\x03\x02\x02\x02\u{40b}\u{409}\x03\x02\x02\x02\u{40c}\u{410}\x07\x1e\x02\
	\x02\u{40d}\u{40f}\x07\x07\x02\x02\u{40e}\u{40d}\x03\x02\x02\x02\u{40f}\
	\u{412}\x03\x02\x02\x02\u{410}\u{40e}\x03\x02\x02\x02\u{410}\u{411}\x03\
	\x02\x02\x02\u{411}\u{413}\x03\x02\x02\x02\u{412}\u{410}\x03\x02\x02\x02\
	\u{413}\u{415}\x05\u{9a}\x4e\x02\u{414}\u{409}\x03\x02\x02\x02\u{414}\u{415}\
	\x03\x02\x02\x02\u{415}\x3f\x03\x02\x02\x02\u{416}\u{418}\x05\u{12e}\u{98}\
	\x02\u{417}\u{416}\x03\x02\x02\x02\u{417}\u{418}\x03\x02\x02\x02\u{418}\
	\u{419}\x03\x02\x02\x02\u{419}\u{421}\x07\x4e\x02\x02\u{41a}\u{41c}\x07\
	\x07\x02\x02\u{41b}\u{41a}\x03\x02\x02\x02\u{41c}\u{41f}\x03\x02\x02\x02\
	\u{41d}\u{41b}\x03\x02\x02\x02\u{41d}\u{41e}\x03\x02\x02\x02\u{41e}\u{420}\
	\x03\x02\x02\x02\u{41f}\u{41d}\x03\x02\x02\x02\u{420}\u{422}\x05\x2c\x17\
	\x02\u{421}\u{41d}\x03\x02\x02\x02\u{421}\u{422}\x03\x02\x02\x02\u{422}\
	\u{432}\x03\x02\x02\x02\u{423}\u{425}\x07\x07\x02\x02\u{424}\u{423}\x03\
	\x02\x02\x02\u{425}\u{428}\x03\x02\x02\x02\u{426}\u{424}\x03\x02\x02\x02\
	\u{426}\u{427}\x03\x02\x02\x02\u{427}\u{429}\x03\x02\x02\x02\u{428}\u{426}\
	\x03\x02\x02\x02\u{429}\u{42d}\x05\x7c\x3f\x02\u{42a}\u{42c}\x07\x07\x02\
	\x02\u{42b}\u{42a}\x03\x02\x02\x02\u{42c}\u{42f}\x03\x02\x02\x02\u{42d}\
	\u{42b}\x03\x02\x02\x02\u{42d}\u{42e}\x03\x02\x02\x02\u{42e}\u{430}\x03\
	\x02\x02\x02\u{42f}\u{42d}\x03\x02\x02\x02\u{430}\u{431}\x07\x09\x02\x02\
	\u{431}\u{433}\x03\x02\x02\x02\u{432}\u{426}\x03\x02\x02\x02\u{432}\u{433}\
	\x03\x02\x02\x02\u{433}\u{437}\x03\x02\x02\x02\u{434}\u{436}\x07\x07\x02\
	\x02\u{435}\u{434}\x03\x02\x02\x02\u{436}\u{439}\x03\x02\x02\x02\u{437}\
	\u{435}\x03\x02\x02\x02\u{437}\u{438}\x03\x02\x02\x02\u{438}\u{43a}\x03\
	\x02\x02\x02\u{439}\u{437}\x03\x02\x02\x02\u{43a}\u{43e}\x05\u{15a}\u{ae}\
	\x02\u{43b}\u{43d}\x07\x07\x02\x02\u{43c}\u{43b}\x03\x02\x02\x02\u{43d}\
	\u{440}\x03\x02\x02\x02\u{43e}\u{43c}\x03\x02\x02\x02\u{43e}\u{43f}\x03\
	\x02\x02\x02\u{43f}\u{441}\x03\x02\x02\x02\u{440}\u{43e}\x03\x02\x02\x02\
	\u{441}\u{450}\x05\x3c\x1f\x02\u{442}\u{444}\x07\x07\x02\x02\u{443}\u{442}\
	\x03\x02\x02\x02\u{444}\u{447}\x03\x02\x02\x02\u{445}\u{443}\x03\x02\x02\
	\x02\u{445}\u{446}\x03\x02\x02\x02\u{446}\u{448}\x03\x02\x02\x02\u{447}\
	\u{445}\x03\x02\x02\x02\u{448}\u{44c}\x07\x1c\x02\x02\u{449}\u{44b}\x07\
	\x07\x02\x02\u{44a}\u{449}\x03\x02\x02\x02\u{44b}\u{44e}\x03\x02\x02\x02\
	\u{44c}\u{44a}\x03\x02\x02\x02\u{44c}\u{44d}\x03\x02\x02\x02\u{44d}\u{44f}\
	\x03\x02\x02\x02\u{44e}\u{44c}\x03\x02\x02\x02\u{44f}\u{451}\x05\x64\x33\
	\x02\u{450}\u{445}\x03\x02\x02\x02\u{450}\u{451}\x03\x02\x02\x02\u{451}\
	\u{459}\x03\x02\x02\x02\u{452}\u{454}\x07\x07\x02\x02\u{453}\u{452}\x03\
	\x02\x02\x02\u{454}\u{457}\x03\x02\x02\x02\u{455}\u{453}\x03\x02\x02\x02\
	\u{455}\u{456}\x03\x02\x02\x02\u{456}\u{458}\x03\x02\x02\x02\u{457}\u{455}\
	\x03\x02\x02\x02\u{458}\u{45a}\x05\x30\x19\x02\u{459}\u{455}\x03\x02\x02\
	\x02\u{459}\u{45a}\x03\x02\x02\x02\u{45a}\u{462}\x03\x02\x02\x02\u{45b}\
	\u{45d}\x07\x07\x02\x02\u{45c}\u{45b}\x03\x02\x02\x02\u{45d}\u{460}\x03\
	\x02\x02\x02\u{45e}\u{45c}\x03\x02\x02\x02\u{45e}\u{45f}\x03\x02\x02\x02\
	\u{45f}\u{461}\x03\x02\x02\x02\u{460}\u{45e}\x03\x02\x02\x02\u{461}\u{463}\
	\x05\x42\x22\x02\u{462}\u{45e}\x03\x02\x02\x02\u{462}\u{463}\x03\x02\x02\
	\x02\u{463}\x41\x03\x02\x02\x02\u{464}\u{46e}\x05\u{8a}\x46\x02\u{465}\u{469}\
	\x07\x1e\x02\x02\u{466}\u{468}\x07\x07\x02\x02\u{467}\u{466}\x03\x02\x02\
	\x02\u{468}\u{46b}\x03\x02\x02\x02\u{469}\u{467}\x03\x02\x02\x02\u{469}\
	\u{46a}\x03\x02\x02\x02\u{46a}\u{46c}\x03\x02\x02\x02\u{46b}\u{469}\x03\
	\x02\x02\x02\u{46c}\u{46e}\x05\u{9a}\x4e\x02\u{46d}\u{464}\x03\x02\x02\x02\
	\u{46d}\u{465}\x03\x02\x02\x02\u{46e}\x43\x03\x02\x02\x02\u{46f}\u{471}\
	\x05\u{150}\u{a9}\x02\u{470}\u{46f}\x03\x02\x02\x02\u{471}\u{474}\x03\x02\
	\x02\x02\u{472}\u{470}\x03\x02\x02\x02\u{472}\u{473}\x03\x02\x02\x02\u{473}\
	\u{478}\x03\x02\x02\x02\u{474}\u{472}\x03\x02\x02\x02\u{475}\u{477}\x07\
	\x07\x02\x02\u{476}\u{475}\x03\x02\x02\x02\u{477}\u{47a}\x03\x02\x02\x02\
	\u{478}\u{476}\x03\x02\x02\x02\u{478}\u{479}\x03\x02\x02\x02\u{479}\u{47b}\
	\x03\x02\x02\x02\u{47a}\u{478}\x03\x02\x02\x02\u{47b}\u{48a}\x05\u{15a}\
	\u{ae}\x02\u{47c}\u{47e}\x07\x07\x02\x02\u{47d}\u{47c}\x03\x02\x02\x02\u{47e}\
	\u{481}\x03\x02\x02\x02\u{47f}\u{47d}\x03\x02\x02\x02\u{47f}\u{480}\x03\
	\x02\x02\x02\u{480}\u{482}\x03\x02\x02\x02\u{481}\u{47f}\x03\x02\x02\x02\
	\u{482}\u{486}\x07\x1c\x02\x02\u{483}\u{485}\x07\x07\x02\x02\u{484}\u{483}\
	\x03\x02\x02\x02\u{485}\u{488}\x03\x02\x02\x02\u{486}\u{484}\x03\x02\x02\
	\x02\u{486}\u{487}\x03\x02\x02\x02\u{487}\u{489}\x03\x02\x02\x02\u{488}\
	\u{486}\x03\x02\x02\x02\u{489}\u{48b}\x05\x64\x33\x02\u{48a}\u{47f}\x03\
	\x02\x02\x02\u{48a}\u{48b}\x03\x02\x02\x02\u{48b}\x45\x03\x02\x02\x02\u{48c}\
	\u{490}\x07\x0b\x02\x02\u{48d}\u{48f}\x07\x07\x02\x02\u{48e}\u{48d}\x03\
	\x02\x02\x02\u{48f}\u{492}\x03\x02\x02\x02\u{490}\u{48e}\x03\x02\x02\x02\
	\u{490}\u{491}\x03\x02\x02\x02\u{491}\u{493}\x03\x02\x02\x02\u{492}\u{490}\
	\x03\x02\x02\x02\u{493}\u{4a4}\x05\x44\x23\x02\u{494}\u{496}\x07\x07\x02\
	\x02\u{495}\u{494}\x03\x02\x02\x02\u{496}\u{499}\x03\x02\x02\x02\u{497}\
	\u{495}\x03\x02\x02\x02\u{497}\u{498}\x03\x02\x02\x02\u{498}\u{49a}\x03\
	\x02\x02\x02\u{499}\u{497}\x03\x02\x02\x02\u{49a}\u{49e}\x07\x0a\x02\x02\
	\u{49b}\u{49d}\x07\x07\x02\x02\u{49c}\u{49b}\x03\x02\x02\x02\u{49d}\u{4a0}\
	\x03\x02\x02\x02\u{49e}\u{49c}\x03\x02\x02\x02\u{49e}\u{49f}\x03\x02\x02\
	\x02\u{49f}\u{4a1}\x03\x02\x02\x02\u{4a0}\u{49e}\x03\x02\x02\x02\u{4a1}\
	\u{4a3}\x05\x44\x23\x02\u{4a2}\u{497}\x03\x02\x02\x02\u{4a3}\u{4a6}\x03\
	\x02\x02\x02\u{4a4}\u{4a2}\x03\x02\x02\x02\u{4a4}\u{4a5}\x03\x02\x02\x02\
	\u{4a5}\u{4ae}\x03\x02\x02\x02\u{4a6}\u{4a4}\x03\x02\x02\x02\u{4a7}\u{4a9}\
	\x07\x07\x02\x02\u{4a8}\u{4a7}\x03\x02\x02\x02\u{4a9}\u{4ac}\x03\x02\x02\
	\x02\u{4aa}\u{4a8}\x03\x02\x02\x02\u{4aa}\u{4ab}\x03\x02\x02\x02\u{4ab}\
	\u{4ad}\x03\x02\x02\x02\u{4ac}\u{4aa}\x03\x02\x02\x02\u{4ad}\u{4af}\x07\
	\x0a\x02\x02\u{4ae}\u{4aa}\x03\x02\x02\x02\u{4ae}\u{4af}\x03\x02\x02\x02\
	\u{4af}\u{4b3}\x03\x02\x02\x02\u{4b0}\u{4b2}\x07\x07\x02\x02\u{4b1}\u{4b0}\
	\x03\x02\x02\x02\u{4b2}\u{4b5}\x03\x02\x02\x02\u{4b3}\u{4b1}\x03\x02\x02\
	\x02\u{4b3}\u{4b4}\x03\x02\x02\x02\u{4b4}\u{4b6}\x03\x02\x02\x02\u{4b5}\
	\u{4b3}\x03\x02\x02\x02\u{4b6}\u{4b7}\x07\x0c\x02\x02\u{4b7}\x47\x03\x02\
	\x02\x02\u{4b8}\u{4ba}\x05\u{12e}\u{98}\x02\u{4b9}\u{4b8}\x03\x02\x02\x02\
	\u{4b9}\u{4ba}\x03\x02\x02\x02\u{4ba}\u{4bb}\x03\x02\x02\x02\u{4bb}\u{4c3}\
	\x09\x03\x02\x02\u{4bc}\u{4be}\x07\x07\x02\x02\u{4bd}\u{4bc}\x03\x02\x02\
	\x02\u{4be}\u{4c1}\x03\x02\x02\x02\u{4bf}\u{4bd}\x03\x02\x02\x02\u{4bf}\
	\u{4c0}\x03\x02\x02\x02\u{4c0}\u{4c2}\x03\x02\x02\x02\u{4c1}\u{4bf}\x03\
	\x02\x02\x02\u{4c2}\u{4c4}\x05\x2c\x17\x02\u{4c3}\u{4bf}\x03\x02\x02\x02\
	\u{4c3}\u{4c4}\x03\x02\x02\x02\u{4c4}\u{4d4}\x03\x02\x02\x02\u{4c5}\u{4c7}\
	\x07\x07\x02\x02\u{4c6}\u{4c5}\x03\x02\x02\x02\u{4c7}\u{4ca}\x03\x02\x02\
	\x02\u{4c8}\u{4c6}\x03\x02\x02\x02\u{4c8}\u{4c9}\x03\x02\x02\x02\u{4c9}\
	\u{4cb}\x03\x02\x02\x02\u{4ca}\u{4c8}\x03\x02\x02\x02\u{4cb}\u{4cf}\x05\
	\x7c\x3f\x02\u{4cc}\u{4ce}\x07\x07\x02\x02\u{4cd}\u{4cc}\x03\x02\x02\x02\
	\u{4ce}\u{4d1}\x03\x02\x02\x02\u{4cf}\u{4cd}\x03\x02\x02\x02\u{4cf}\u{4d0}\
	\x03\x02\x02\x02\u{4d0}\u{4d2}\x03\x02\x02\x02\u{4d1}\u{4cf}\x03\x02\x02\
	\x02\u{4d2}\u{4d3}\x07\x09\x02\x02\u{4d3}\u{4d5}\x03\x02\x02\x02\u{4d4}\
	\u{4c8}\x03\x02\x02\x02\u{4d4}\u{4d5}\x03\x02\x02\x02\u{4d5}\u{4d9}\x03\
	\x02\x02\x02\u{4d6}\u{4d8}\x07\x07\x02\x02\u{4d7}\u{4d6}\x03\x02\x02\x02\
	\u{4d8}\u{4db}\x03\x02\x02\x02\u{4d9}\u{4d7}\x03\x02\x02\x02\u{4d9}\u{4da}\
	\x03\x02\x02\x02\u{4da}\u{4de}\x03\x02\x02\x02\u{4db}\u{4d9}\x03\x02\x02\
	\x02\u{4dc}\u{4df}\x05\x46\x24\x02\u{4dd}\u{4df}\x05\x44\x23\x02\u{4de}\
	\u{4dc}\x03\x02\x02\x02\u{4de}\u{4dd}\x03\x02\x02\x02\u{4df}\u{4e7}\x03\
	\x02\x02\x02\u{4e0}\u{4e2}\x07\x07\x02\x02\u{4e1}\u{4e0}\x03\x02\x02\x02\
	\u{4e2}\u{4e5}\x03\x02\x02\x02\u{4e3}\u{4e1}\x03\x02\x02\x02\u{4e3}\u{4e4}\
	\x03\x02\x02\x02\u{4e4}\u{4e6}\x03\x02\x02\x02\u{4e5}\u{4e3}\x03\x02\x02\
	\x02\u{4e6}\u{4e8}\x05\x30\x19\x02\u{4e7}\u{4e3}\x03\x02\x02\x02\u{4e7}\
	\u{4e8}\x03\x02\x02\x02\u{4e8}\u{4fa}\x03\x02\x02\x02\u{4e9}\u{4eb}\x07\
	\x07\x02\x02\u{4ea}\u{4e9}\x03\x02\x02\x02\u{4eb}\u{4ee}\x03\x02\x02\x02\
	\u{4ec}\u{4ea}\x03\x02\x02\x02\u{4ec}\u{4ed}\x03\x02\x02\x02\u{4ed}\u{4f8}\
	\x03\x02\x02\x02\u{4ee}\u{4ec}\x03\x02\x02\x02\u{4ef}\u{4f3}\x07\x1e\x02\
	\x02\u{4f0}\u{4f2}\x07\x07\x02\x02\u{4f1}\u{4f0}\x03\x02\x02\x02\u{4f2}\
	\u{4f5}\x03\x02\x02\x02\u{4f3}\u{4f1}\x03\x02\x02\x02\u{4f3}\u{4f4}\x03\
	\x02\x02\x02\u{4f4}\u{4f6}\x03\x02\x02\x02\u{4f5}\u{4f3}\x03\x02\x02\x02\
	\u{4f6}\u{4f9}\x05\u{9a}\x4e\x02\u{4f7}\u{4f9}\x05\x4a\x26\x02\u{4f8}\u{4ef}\
	\x03\x02\x02\x02\u{4f8}\u{4f7}\x03\x02\x02\x02\u{4f9}\u{4fb}\x03\x02\x02\
	\x02\u{4fa}\u{4ec}\x03\x02\x02\x02\u{4fa}\u{4fb}\x03\x02\x02\x02\u{4fb}\
	\u{503}\x03\x02\x02\x02\u{4fc}\u{4fe}\x07\x07\x02\x02\u{4fd}\u{4fc}\x03\
	\x02\x02\x02\u{4fe}\u{501}\x03\x02\x02\x02\u{4ff}\u{4fd}\x03\x02\x02\x02\
	\u{4ff}\u{500}\x03\x02\x02\x02\u{500}\u{502}\x03\x02\x02\x02\u{501}\u{4ff}\
	\x03\x02\x02\x02\u{502}\u{504}\x07\x1d\x02\x02\u{503}\u{4ff}\x03\x02\x02\
	\x02\u{503}\u{504}\x03\x02\x02\x02\u{504}\u{508}\x03\x02\x02\x02\u{505}\
	\u{507}\x07\x07\x02\x02\u{506}\u{505}\x03\x02\x02\x02\u{507}\u{50a}\x03\
	\x02\x02\x02\u{508}\u{506}\x03\x02\x02\x02\u{508}\u{509}\x03\x02\x02\x02\
	\u{509}\u{529}\x03\x02\x02\x02\u{50a}\u{508}\x03\x02\x02\x02\u{50b}\u{50d}\
	\x05\x4c\x27\x02\u{50c}\u{50b}\x03\x02\x02\x02\u{50c}\u{50d}\x03\x02\x02\
	\x02\u{50d}\u{518}\x03\x02\x02\x02\u{50e}\u{510}\x07\x07\x02\x02\u{50f}\
	\u{50e}\x03\x02\x02\x02\u{510}\u{513}\x03\x02\x02\x02\u{511}\u{50f}\x03\
	\x02\x02\x02\u{511}\u{512}\x03\x02\x02\x02\u{512}\u{515}\x03\x02\x02\x02\
	\u{513}\u{511}\x03\x02\x02\x02\u{514}\u{516}\x05\u{96}\x4c\x02\u{515}\u{514}\
	\x03\x02\x02\x02\u{515}\u{516}\x03\x02\x02\x02\u{516}\u{517}\x03\x02\x02\
	\x02\u{517}\u{519}\x05\x4e\x28\x02\u{518}\u{511}\x03\x02\x02\x02\u{518}\
	\u{519}\x03\x02\x02\x02\u{519}\u{52a}\x03\x02\x02\x02\u{51a}\u{51c}\x05\
	\x4e\x28\x02\u{51b}\u{51a}\x03\x02\x02\x02\u{51b}\u{51c}\x03\x02\x02\x02\
	\u{51c}\u{527}\x03\x02\x02\x02\u{51d}\u{51f}\x07\x07\x02\x02\u{51e}\u{51d}\
	\x03\x02\x02\x02\u{51f}\u{522}\x03\x02\x02\x02\u{520}\u{51e}\x03\x02\x02\
	\x02\u{520}\u{521}\x03\x02\x02\x02\u{521}\u{524}\x03\x02\x02\x02\u{522}\
	\u{520}\x03\x02\x02\x02\u{523}\u{525}\x05\u{96}\x4c\x02\u{524}\u{523}\x03\
	\x02\x02\x02\u{524}\u{525}\x03\x02\x02\x02\u{525}\u{526}\x03\x02\x02\x02\
	\u{526}\u{528}\x05\x4c\x27\x02\u{527}\u{520}\x03\x02\x02\x02\u{527}\u{528}\
	\x03\x02\x02\x02\u{528}\u{52a}\x03\x02\x02\x02\u{529}\u{50c}\x03\x02\x02\
	\x02\u{529}\u{51b}\x03\x02\x02\x02\u{52a}\x49\x03\x02\x02\x02\u{52b}\u{52f}\
	\x07\x54\x02\x02\u{52c}\u{52e}\x07\x07\x02\x02\u{52d}\u{52c}\x03\x02\x02\
	\x02\u{52e}\u{531}\x03\x02\x02\x02\u{52f}\u{52d}\x03\x02\x02\x02\u{52f}\
	\u{530}\x03\x02\x02\x02\u{530}\u{532}\x03\x02\x02\x02\u{531}\u{52f}\x03\
	\x02\x02\x02\u{532}\u{533}\x05\u{9a}\x4e\x02\u{533}\x4b\x03\x02\x02\x02\
	\u{534}\u{536}\x05\u{12e}\u{98}\x02\u{535}\u{534}\x03\x02\x02\x02\u{535}\
	\u{536}\x03\x02\x02\x02\u{536}\u{537}\x03\x02\x02\x02\u{537}\u{55d}\x07\
	\x44\x02\x02\u{538}\u{53a}\x07\x07\x02\x02\u{539}\u{538}\x03\x02\x02\x02\
	\u{53a}\u{53d}\x03\x02\x02\x02\u{53b}\u{539}\x03\x02\x02\x02\u{53b}\u{53c}\
	\x03\x02\x02\x02\u{53c}\u{53e}\x03\x02\x02\x02\u{53d}\u{53b}\x03\x02\x02\
	\x02\u{53e}\u{542}\x07\x0b\x02\x02\u{53f}\u{541}\x07\x07\x02\x02\u{540}\
	\u{53f}\x03\x02\x02\x02\u{541}\u{544}\x03\x02\x02\x02\u{542}\u{540}\x03\
	\x02\x02\x02\u{542}\u{543}\x03\x02\x02\x02\u{543}\u{545}\x03\x02\x02\x02\
	\u{544}\u{542}\x03\x02\x02\x02\u{545}\u{554}\x07\x0c\x02\x02\u{546}\u{548}\
	\x07\x07\x02\x02\u{547}\u{546}\x03\x02\x02\x02\u{548}\u{54b}\x03\x02\x02\
	\x02\u{549}\u{547}\x03\x02\x02\x02\u{549}\u{54a}\x03\x02\x02\x02\u{54a}\
	\u{54c}\x03\x02\x02\x02\u{54b}\u{549}\x03\x02\x02\x02\u{54c}\u{550}\x07\
	\x1c\x02\x02\u{54d}\u{54f}\x07\x07\x02\x02\u{54e}\u{54d}\x03\x02\x02\x02\
	\u{54f}\u{552}\x03\x02\x02\x02\u{550}\u{54e}\x03\x02\x02\x02\u{550}\u{551}\
	\x03\x02\x02\x02\u{551}\u{553}\x03\x02\x02\x02\u{552}\u{550}\x03\x02\x02\
	\x02\u{553}\u{555}\x05\x64\x33\x02\u{554}\u{549}\x03\x02\x02\x02\u{554}\
	\u{555}\x03\x02\x02\x02\u{555}\u{559}\x03\x02\x02\x02\u{556}\u{558}\x07\
	\x07\x02\x02\u{557}\u{556}\x03\x02\x02\x02\u{558}\u{55b}\x03\x02\x02\x02\
	\u{559}\u{557}\x03\x02\x02\x02\u{559}\u{55a}\x03\x02\x02\x02\u{55a}\u{55c}\
	\x03\x02\x02\x02\u{55b}\u{559}\x03\x02\x02\x02\u{55c}\u{55e}\x05\x42\x22\
	\x02\u{55d}\u{53b}\x03\x02\x02\x02\u{55d}\u{55e}\x03\x02\x02\x02\u{55e}\
	\x4d\x03\x02\x02\x02\u{55f}\u{561}\x05\u{12e}\u{98}\x02\u{560}\u{55f}\x03\
	\x02\x02\x02\u{560}\u{561}\x03\x02\x02\x02\u{561}\u{562}\x03\x02\x02\x02\
	\u{562}\u{599}\x07\x45\x02\x02\u{563}\u{565}\x07\x07\x02\x02\u{564}\u{563}\
	\x03\x02\x02\x02\u{565}\u{568}\x03\x02\x02\x02\u{566}\u{564}\x03\x02\x02\
	\x02\u{566}\u{567}\x03\x02\x02\x02\u{567}\u{569}\x03\x02\x02\x02\u{568}\
	\u{566}\x03\x02\x02\x02\u{569}\u{56d}\x07\x0b\x02\x02\u{56a}\u{56c}\x07\
	\x07\x02\x02\u{56b}\u{56a}\x03\x02\x02\x02\u{56c}\u{56f}\x03\x02\x02\x02\
	\u{56d}\u{56b}\x03\x02\x02\x02\u{56d}\u{56e}\x03\x02\x02\x02\u{56e}\u{570}\
	\x03\x02\x02\x02\u{56f}\u{56d}\x03\x02\x02\x02\u{570}\u{578}\x05\x52\x2a\
	\x02\u{571}\u{573}\x07\x07\x02\x02\u{572}\u{571}\x03\x02\x02\x02\u{573}\
	\u{576}\x03\x02\x02\x02\u{574}\u{572}\x03\x02\x02\x02\u{574}\u{575}\x03\
	\x02\x02\x02\u{575}\u{577}\x03\x02\x02\x02\u{576}\u{574}\x03\x02\x02\x02\
	\u{577}\u{579}\x07\x0a\x02\x02\u{578}\u{574}\x03\x02\x02\x02\u{578}\u{579}\
	\x03\x02\x02\x02\u{579}\u{57d}\x03\x02\x02\x02\u{57a}\u{57c}\x07\x07\x02\
	\x02\u{57b}\u{57a}\x03\x02\x02\x02\u{57c}\u{57f}\x03\x02\x02\x02\u{57d}\
	\u{57b}\x03\x02\x02\x02\u{57d}\u{57e}\x03\x02\x02\x02\u{57e}\u{580}\x03\
	\x02\x02\x02\u{57f}\u{57d}\x03\x02\x02\x02\u{580}\u{58f}\x07\x0c\x02\x02\
	\u{581}\u{583}\x07\x07\x02\x02\u{582}\u{581}\x03\x02\x02\x02\u{583}\u{586}\
	\x03\x02\x02\x02\u{584}\u{582}\x03\x02\x02\x02\u{584}\u{585}\x03\x02\x02\
	\x02\u{585}\u{587}\x03\x02\x02\x02\u{586}\u{584}\x03\x02\x02\x02\u{587}\
	\u{58b}\x07\x1c\x02\x02\u{588}\u{58a}\x07\x07\x02\x02\u{589}\u{588}\x03\
	\x02\x02\x02\u{58a}\u{58d}\x03\x02\x02\x02\u{58b}\u{589}\x03\x02\x02\x02\
	\u{58b}\u{58c}\x03\x02\x02\x02\u{58c}\u{58e}\x03\x02\x02\x02\u{58d}\u{58b}\
	\x03\x02\x02\x02\u{58e}\u{590}\x05\x64\x33\x02\u{58f}\u{584}\x03\x02\x02\
	\x02\u{58f}\u{590}\x03\x02\x02\x02\u{590}\u{594}\x03\x02\x02\x02\u{591}\
	\u{593}\x07\x07\x02\x02\u{592}\u{591}\x03\x02\x02\x02\u{593}\u{596}\x03\
	\x02\x02\x02\u{594}\u{592}\x03\x02\x02\x02\u{594}\u{595}\x03\x02\x02\x02\
	\u{595}\u{597}\x03\x02\x02\x02\u{596}\u{594}\x03\x02\x02\x02\u{597}\u{598}\
	\x05\x42\x22\x02\u{598}\u{59a}\x03\x02\x02\x02\u{599}\u{566}\x03\x02\x02\
	\x02\u{599}\u{59a}\x03\x02\x02\x02\u{59a}\x4f\x03\x02\x02\x02\u{59b}\u{59f}\
	\x07\x0b\x02\x02\u{59c}\u{59e}\x07\x07\x02\x02\u{59d}\u{59c}\x03\x02\x02\
	\x02\u{59e}\u{5a1}\x03\x02\x02\x02\u{59f}\u{59d}\x03\x02\x02\x02\u{59f}\
	\u{5a0}\x03\x02\x02\x02\u{5a0}\u{5bf}\x03\x02\x02\x02\u{5a1}\u{59f}\x03\
	\x02\x02\x02\u{5a2}\u{5b3}\x05\x52\x2a\x02\u{5a3}\u{5a5}\x07\x07\x02\x02\
	\u{5a4}\u{5a3}\x03\x02\x02\x02\u{5a5}\u{5a8}\x03\x02\x02\x02\u{5a6}\u{5a4}\
	\x03\x02\x02\x02\u{5a6}\u{5a7}\x03\x02\x02\x02\u{5a7}\u{5a9}\x03\x02\x02\
	\x02\u{5a8}\u{5a6}\x03\x02\x02\x02\u{5a9}\u{5ad}\x07\x0a\x02\x02\u{5aa}\
	\u{5ac}\x07\x07\x02\x02\u{5ab}\u{5aa}\x03\x02\x02\x02\u{5ac}\u{5af}\x03\
	\x02\x02\x02\u{5ad}\u{5ab}\x03\x02\x02\x02\u{5ad}\u{5ae}\x03\x02\x02\x02\
	\u{5ae}\u{5b0}\x03\x02\x02\x02\u{5af}\u{5ad}\x03\x02\x02\x02\u{5b0}\u{5b2}\
	\x05\x52\x2a\x02\u{5b1}\u{5a6}\x03\x02\x02\x02\u{5b2}\u{5b5}\x03\x02\x02\
	\x02\u{5b3}\u{5b1}\x03\x02\x02\x02\u{5b3}\u{5b4}\x03\x02\x02\x02\u{5b4}\
	\u{5bd}\x03\x02\x02\x02\u{5b5}\u{5b3}\x03\x02\x02\x02\u{5b6}\u{5b8}\x07\
	\x07\x02\x02\u{5b7}\u{5b6}\x03\x02\x02\x02\u{5b8}\u{5bb}\x03\x02\x02\x02\
	\u{5b9}\u{5b7}\x03\x02\x02\x02\u{5b9}\u{5ba}\x03\x02\x02\x02\u{5ba}\u{5bc}\
	\x03\x02\x02\x02\u{5bb}\u{5b9}\x03\x02\x02\x02\u{5bc}\u{5be}\x07\x0a\x02\
	\x02\u{5bd}\u{5b9}\x03\x02\x02\x02\u{5bd}\u{5be}\x03\x02\x02\x02\u{5be}\
	\u{5c0}\x03\x02\x02\x02\u{5bf}\u{5a2}\x03\x02\x02\x02\u{5bf}\u{5c0}\x03\
	\x02\x02\x02\u{5c0}\u{5c4}\x03\x02\x02\x02\u{5c1}\u{5c3}\x07\x07\x02\x02\
	\u{5c2}\u{5c1}\x03\x02\x02\x02\u{5c3}\u{5c6}\x03\x02\x02\x02\u{5c4}\u{5c2}\
	\x03\x02\x02\x02\u{5c4}\u{5c5}\x03\x02\x02\x02\u{5c5}\u{5c7}\x03\x02\x02\
	\x02\u{5c6}\u{5c4}\x03\x02\x02\x02\u{5c7}\u{5c8}\x07\x0c\x02\x02\u{5c8}\
	\x51\x03\x02\x02\x02\u{5c9}\u{5cb}\x05\u{130}\u{99}\x02\u{5ca}\u{5c9}\x03\
	\x02\x02\x02\u{5ca}\u{5cb}\x03\x02\x02\x02\u{5cb}\u{5cc}\x03\x02\x02\x02\
	\u{5cc}\u{5db}\x05\x54\x2b\x02\u{5cd}\u{5cf}\x07\x07\x02\x02\u{5ce}\u{5cd}\
	\x03\x02\x02\x02\u{5cf}\u{5d2}\x03\x02\x02\x02\u{5d0}\u{5ce}\x03\x02\x02\
	\x02\u{5d0}\u{5d1}\x03\x02\x02\x02\u{5d1}\u{5d3}\x03\x02\x02\x02\u{5d2}\
	\u{5d0}\x03\x02\x02\x02\u{5d3}\u{5d7}\x07\x1e\x02\x02\u{5d4}\u{5d6}\x07\
	\x07\x02\x02\u{5d5}\u{5d4}\x03\x02\x02\x02\u{5d6}\u{5d9}\x03\x02\x02\x02\
	\u{5d7}\u{5d5}\x03\x02\x02\x02\u{5d7}\u{5d8}\x03\x02\x02\x02\u{5d8}\u{5da}\
	\x03\x02\x02\x02\u{5d9}\u{5d7}\x03\x02\x02\x02\u{5da}\u{5dc}\x05\u{9a}\x4e\
	\x02\u{5db}\u{5d0}\x03\x02\x02\x02\u{5db}\u{5dc}\x03\x02\x02\x02\u{5dc}\
	\x53\x03\x02\x02\x02\u{5dd}\u{5e1}\x05\u{15a}\u{ae}\x02\u{5de}\u{5e0}\x07\
	\x07\x02\x02\u{5df}\u{5de}\x03\x02\x02\x02\u{5e0}\u{5e3}\x03\x02\x02\x02\
	\u{5e1}\u{5df}\x03\x02\x02\x02\u{5e1}\u{5e2}\x03\x02\x02\x02\u{5e2}\u{5ec}\
	\x03\x02\x02\x02\u{5e3}\u{5e1}\x03\x02\x02\x02\u{5e4}\u{5e8}\x07\x1c\x02\
	\x02\u{5e5}\u{5e7}\x07\x07\x02\x02\u{5e6}\u{5e5}\x03\x02\x02\x02\u{5e7}\
	\u{5ea}\x03\x02\x02\x02\u{5e8}\u{5e6}\x03\x02\x02\x02\u{5e8}\u{5e9}\x03\
	\x02\x02\x02\u{5e9}\u{5eb}\x03\x02\x02\x02\u{5ea}\u{5e8}\x03\x02\x02\x02\
	\u{5eb}\u{5ed}\x05\x64\x33\x02\u{5ec}\u{5e4}\x03\x02\x02\x02\u{5ec}\u{5ed}\
	\x03\x02\x02\x02\u{5ed}\x55\x03\x02\x02\x02\u{5ee}\u{5f2}\x05\u{15a}\u{ae}\
	\x02\u{5ef}\u{5f1}\x07\x07\x02\x02\u{5f0}\u{5ef}\x03\x02\x02\x02\u{5f1}\
	\u{5f4}\x03\x02\x02\x02\u{5f2}\u{5f0}\x03\x02\x02\x02\u{5f2}\u{5f3}\x03\
	\x02\x02\x02\u{5f3}\u{5f5}\x03\x02\x02\x02\u{5f4}\u{5f2}\x03\x02\x02\x02\
	\u{5f5}\u{5f9}\x07\x1c\x02\x02\u{5f6}\u{5f8}\x07\x07\x02\x02\u{5f7}\u{5f6}\
	\x03\x02\x02\x02\u{5f8}\u{5fb}\x03\x02\x02\x02\u{5f9}\u{5f7}\x03\x02\x02\
	\x02\u{5f9}\u{5fa}\x03\x02\x02\x02\u{5fa}\u{5fc}\x03\x02\x02\x02\u{5fb}\
	\u{5f9}\x03\x02\x02\x02\u{5fc}\u{5fd}\x05\x64\x33\x02\u{5fd}\x57\x03\x02\
	\x02\x02\u{5fe}\u{600}\x05\u{12e}\u{98}\x02\u{5ff}\u{5fe}\x03\x02\x02\x02\
	\u{5ff}\u{600}\x03\x02\x02\x02\u{600}\u{601}\x03\x02\x02\x02\u{601}\u{605}\
	\x07\x4f\x02\x02\u{602}\u{604}\x07\x07\x02\x02\u{603}\u{602}\x03\x02\x02\
	\x02\u{604}\u{607}\x03\x02\x02\x02\u{605}\u{603}\x03\x02\x02\x02\u{605}\
	\u{606}\x03\x02\x02\x02\u{606}\u{608}\x03\x02\x02\x02\u{607}\u{605}\x03\
	\x02\x02\x02\u{608}\u{617}\x05\u{15a}\u{ae}\x02\u{609}\u{60b}\x07\x07\x02\
	\x02\u{60a}\u{609}\x03\x02\x02\x02\u{60b}\u{60e}\x03\x02\x02\x02\u{60c}\
	\u{60a}\x03\x02\x02\x02\u{60c}\u{60d}\x03\x02\x02\x02\u{60d}\u{60f}\x03\
	\x02\x02\x02\u{60e}\u{60c}\x03\x02\x02\x02\u{60f}\u{613}\x07\x1c\x02\x02\
	\u{610}\u{612}\x07\x07\x02\x02\u{611}\u{610}\x03\x02\x02\x02\u{612}\u{615}\
	\x03\x02\x02\x02\u{613}\u{611}\x03\x02\x02\x02\u{613}\u{614}\x03\x02\x02\
	\x02\u{614}\u{616}\x03\x02\x02\x02\u{615}\u{613}\x03\x02\x02\x02\u{616}\
	\u{618}\x05\x22\x12\x02\u{617}\u{60c}\x03\x02\x02\x02\u{617}\u{618}\x03\
	\x02\x02\x02\u{618}\u{620}\x03\x02\x02\x02\u{619}\u{61b}\x07\x07\x02\x02\
	\u{61a}\u{619}\x03\x02\x02\x02\u{61b}\u{61e}\x03\x02\x02\x02\u{61c}\u{61a}\
	\x03\x02\x02\x02\u{61c}\u{61d}\x03\x02\x02\x02\u{61d}\u{61f}\x03\x02\x02\
	\x02\u{61e}\u{61c}\x03\x02\x02\x02\u{61f}\u{621}\x05\x1c\x0f\x02\u{620}\
	\u{61c}\x03\x02\x02\x02\u{620}\u{621}\x03\x02\x02\x02\u{621}\x59\x03\x02\
	\x02\x02\u{622}\u{624}\x05\u{12e}\u{98}\x02\u{623}\u{622}\x03\x02\x02\x02\
	\u{623}\u{624}\x03\x02\x02\x02\u{624}\u{625}\x03\x02\x02\x02\u{625}\u{629}\
	\x07\x53\x02\x02\u{626}\u{628}\x07\x07\x02\x02\u{627}\u{626}\x03\x02\x02\
	\x02\u{628}\u{62b}\x03\x02\x02\x02\u{629}\u{627}\x03\x02\x02\x02\u{629}\
	\u{62a}\x03\x02\x02\x02\u{62a}\u{62c}\x03\x02\x02\x02\u{62b}\u{629}\x03\
	\x02\x02\x02\u{62c}\u{63b}\x05\x3c\x1f\x02\u{62d}\u{62f}\x07\x07\x02\x02\
	\u{62e}\u{62d}\x03\x02\x02\x02\u{62f}\u{632}\x03\x02\x02\x02\u{630}\u{62e}\
	\x03\x02\x02\x02\u{630}\u{631}\x03\x02\x02\x02\u{631}\u{633}\x03\x02\x02\
	\x02\u{632}\u{630}\x03\x02\x02\x02\u{633}\u{637}\x07\x1c\x02\x02\u{634}\
	\u{636}\x07\x07\x02\x02\u{635}\u{634}\x03\x02\x02\x02\u{636}\u{639}\x03\
	\x02\x02\x02\u{637}\u{635}\x03\x02\x02\x02\u{637}\u{638}\x03\x02\x02\x02\
	\u{638}\u{63a}\x03\x02\x02\x02\u{639}\u{637}\x03\x02\x02\x02\u{63a}\u{63c}\
	\x05\x5c\x2f\x02\u{63b}\u{630}\x03\x02\x02\x02\u{63b}\u{63c}\x03\x02\x02\
	\x02\u{63c}\u{640}\x03\x02\x02\x02\u{63d}\u{63f}\x07\x07\x02\x02\u{63e}\
	\u{63d}\x03\x02\x02\x02\u{63f}\u{642}\x03\x02\x02\x02\u{640}\u{63e}\x03\
	\x02\x02\x02\u{640}\u{641}\x03\x02\x02\x02\u{641}\u{644}\x03\x02\x02\x02\
	\u{642}\u{640}\x03\x02\x02\x02\u{643}\u{645}\x05\u{8a}\x46\x02\u{644}\u{643}\
	\x03\x02\x02\x02\u{644}\u{645}\x03\x02\x02\x02\u{645}\x5b\x03\x02\x02\x02\
	\u{646}\u{64a}\x09\x04\x02\x02\u{647}\u{649}\x07\x07\x02\x02\u{648}\u{647}\
	\x03\x02\x02\x02\u{649}\u{64c}\x03\x02\x02\x02\u{64a}\u{648}\x03\x02\x02\
	\x02\u{64a}\u{64b}\x03\x02\x02\x02\u{64b}\u{64d}\x03\x02\x02\x02\u{64c}\
	\u{64a}\x03\x02\x02\x02\u{64d}\u{64e}\x05\u{d2}\x6a\x02\u{64e}\x5d\x03\x02\
	\x02\x02\u{64f}\u{653}\x07\x0f\x02\x02\u{650}\u{652}\x07\x07\x02\x02\u{651}\
	\u{650}\x03\x02\x02\x02\u{652}\u{655}\x03\x02\x02\x02\u{653}\u{651}\x03\
	\x02\x02\x02\u{653}\u{654}\x03\x02\x02\x02\u{654}\u{657}\x03\x02\x02\x02\
	\u{655}\u{653}\x03\x02\x02\x02\u{656}\u{658}\x05\x60\x31\x02\u{657}\u{656}\
	\x03\x02\x02\x02\u{657}\u{658}\x03\x02\x02\x02\u{658}\u{667}\x03\x02\x02\
	\x02\u{659}\u{65b}\x07\x07\x02\x02\u{65a}\u{659}\x03\x02\x02\x02\u{65b}\
	\u{65e}\x03\x02\x02\x02\u{65c}\u{65a}\x03\x02\x02\x02\u{65c}\u{65d}\x03\
	\x02\x02\x02\u{65d}\u{65f}\x03\x02\x02\x02\u{65e}\u{65c}\x03\x02\x02\x02\
	\u{65f}\u{663}\x07\x1d\x02\x02\u{660}\u{662}\x07\x07\x02\x02\u{661}\u{660}\
	\x03\x02\x02\x02\u{662}\u{665}\x03\x02\x02\x02\u{663}\u{661}\x03\x02\x02\
	\x02\u{663}\u{664}\x03\x02\x02\x02\u{664}\u{666}\x03\x02\x02\x02\u{665}\
	\u{663}\x03\x02\x02\x02\u{666}\u{668}\x05\x34\x1b\x02\u{667}\u{65c}\x03\
	\x02\x02\x02\u{667}\u{668}\x03\x02\x02\x02\u{668}\u{66c}\x03\x02\x02\x02\
	\u{669}\u{66b}\x07\x07\x02\x02\u{66a}\u{669}\x03\x02\x02\x02\u{66b}\u{66e}\
	\x03\x02\x02\x02\u{66c}\u{66a}\x03\x02\x02\x02\u{66c}\u{66d}\x03\x02\x02\
	\x02\u{66d}\u{66f}\x03\x02\x02\x02\u{66e}\u{66c}\x03\x02\x02\x02\u{66f}\
	\u{670}\x07\x10\x02\x02\u{670}\x5f\x03\x02\x02\x02\u{671}\u{682}\x05\x62\
	\x32\x02\u{672}\u{674}\x07\x07\x02\x02\u{673}\u{672}\x03\x02\x02\x02\u{674}\
	\u{677}\x03\x02\x02\x02\u{675}\u{673}\x03\x02\x02\x02\u{675}\u{676}\x03\
	\x02\x02\x02\u{676}\u{678}\x03\x02\x02\x02\u{677}\u{675}\x03\x02\x02\x02\
	\u{678}\u{67c}\x07\x0a\x02\x02\u{679}\u{67b}\x07\x07\x02\x02\u{67a}\u{679}\
	\x03\x02\x02\x02\u{67b}\u{67e}\x03\x02\x02\x02\u{67c}\u{67a}\x03\x02\x02\
	\x02\u{67c}\u{67d}\x03\x02\x02\x02\u{67d}\u{67f}\x03\x02\x02\x02\u{67e}\
	\u{67c}\x03\x02\x02\x02\u{67f}\u{681}\x05\x62\x32\x02\u{680}\u{675}\x03\
	\x02\x02\x02\u{681}\u{684}\x03\x02\x02\x02\u{682}\u{680}\x03\x02\x02\x02\
	\u{682}\u{683}\x03\x02\x02\x02\u{683}\u{688}\x03\x02\x02\x02\u{684}\u{682}\
	\x03\x02\x02\x02\u{685}\u{687}\x07\x07\x02\x02\u{686}\u{685}\x03\x02\x02\
	\x02\u{687}\u{68a}\x03\x02\x02\x02\u{688}\u{686}\x03\x02\x02\x02\u{688}\
	\u{689}\x03\x02\x02\x02\u{689}\u{68c}\x03\x02\x02\x02\u{68a}\u{688}\x03\
	\x02\x02\x02\u{68b}\u{68d}\x07\x0a\x02\x02\u{68c}\u{68b}\x03\x02\x02\x02\
	\u{68c}\u{68d}\x03\x02\x02\x02\u{68d}\x61\x03\x02\x02\x02\u{68e}\u{692}\
	\x05\u{12e}\u{98}\x02\u{68f}\u{691}\x07\x07\x02\x02\u{690}\u{68f}\x03\x02\
	\x02\x02\u{691}\u{694}\x03\x02\x02\x02\u{692}\u{690}\x03\x02\x02\x02\u{692}\
	\u{693}\x03\x02\x02\x02\u{693}\u{696}\x03\x02\x02\x02\u{694}\u{692}\x03\
	\x02\x02\x02\u{695}\u{68e}\x03\x02\x02\x02\u{695}\u{696}\x03\x02\x02\x02\
	\u{696}\u{697}\x03\x02\x02\x02\u{697}\u{69f}\x05\u{15a}\u{ae}\x02\u{698}\
	\u{69a}\x07\x07\x02\x02\u{699}\u{698}\x03\x02\x02\x02\u{69a}\u{69d}\x03\
	\x02\x02\x02\u{69b}\u{699}\x03\x02\x02\x02\u{69b}\u{69c}\x03\x02\x02\x02\
	\u{69c}\u{69e}\x03\x02\x02\x02\u{69d}\u{69b}\x03\x02\x02\x02\u{69e}\u{6a0}\
	\x05\u{d2}\x6a\x02\u{69f}\u{69b}\x03\x02\x02\x02\u{69f}\u{6a0}\x03\x02\x02\
	\x02\u{6a0}\u{6a8}\x03\x02\x02\x02\u{6a1}\u{6a3}\x07\x07\x02\x02\u{6a2}\
	\u{6a1}\x03\x02\x02\x02\u{6a3}\u{6a6}\x03\x02\x02\x02\u{6a4}\u{6a2}\x03\
	\x02\x02\x02\u{6a4}\u{6a5}\x03\x02\x02\x02\u{6a5}\u{6a7}\x03\x02\x02\x02\
	\u{6a6}\u{6a4}\x03\x02\x02\x02\u{6a7}\u{6a9}\x05\x1c\x0f\x02\u{6a8}\u{6a4}\
	\x03\x02\x02\x02\u{6a8}\u{6a9}\x03\x02\x02\x02\u{6a9}\x63\x03\x02\x02\x02\
	\u{6aa}\u{6ac}\x05\u{134}\u{9b}\x02\u{6ab}\u{6aa}\x03\x02\x02\x02\u{6ab}\
	\u{6ac}\x03\x02\x02\x02\u{6ac}\u{6b2}\x03\x02\x02\x02\u{6ad}\u{6b3}\x05\
	\x76\x3c\x02\u{6ae}\u{6b3}\x05\x7a\x3e\x02\u{6af}\u{6b3}\x05\x68\x35\x02\
	\u{6b0}\u{6b3}\x05\x66\x34\x02\u{6b1}\u{6b3}\x05\u{80}\x41\x02\u{6b2}\u{6ad}\
	\x03\x02\x02\x02\u{6b2}\u{6ae}\x03\x02\x02\x02\u{6b2}\u{6af}\x03\x02\x02\
	\x02\u{6b2}\u{6b0}\x03\x02\x02\x02\u{6b2}\u{6b1}\x03\x02\x02\x02\u{6b3}\
	\x65\x03\x02\x02\x02\u{6b4}\u{6b7}\x05\x6c\x37\x02\u{6b5}\u{6b7}\x07\x6e\
	\x02\x02\u{6b6}\u{6b4}\x03\x02\x02\x02\u{6b6}\u{6b5}\x03\x02\x02\x02\u{6b7}\
	\x67\x03\x02\x02\x02\u{6b8}\u{6bb}\x05\x66\x34\x02\u{6b9}\u{6bb}\x05\x7a\
	\x3e\x02\u{6ba}\u{6b8}\x03\x02\x02\x02\u{6ba}\u{6b9}\x03\x02\x02\x02\u{6bb}\
	\u{6bf}\x03\x02\x02\x02\u{6bc}\u{6be}\x07\x07\x02\x02\u{6bd}\u{6bc}\x03\
	\x02\x02\x02\u{6be}\u{6c1}\x03\x02\x02\x02\u{6bf}\u{6bd}\x03\x02\x02\x02\
	\u{6bf}\u{6c0}\x03\x02\x02\x02\u{6c0}\u{6c3}\x03\x02\x02\x02\u{6c1}\u{6bf}\
	\x03\x02\x02\x02\u{6c2}\u{6c4}\x05\x6a\x36\x02\u{6c3}\u{6c2}\x03\x02\x02\
	\x02\u{6c4}\u{6c5}\x03\x02\x02\x02\u{6c5}\u{6c3}\x03\x02\x02\x02\u{6c5}\
	\u{6c6}\x03\x02\x02\x02\u{6c6}\x69\x03\x02\x02\x02\u{6c7}\u{6c8}\x09\x05\
	\x02\x02\u{6c8}\x6b\x03\x02\x02\x02\u{6c9}\u{6da}\x05\x6e\x38\x02\u{6ca}\
	\u{6cc}\x07\x07\x02\x02\u{6cb}\u{6ca}\x03\x02\x02\x02\u{6cc}\u{6cf}\x03\
	\x02\x02\x02\u{6cd}\u{6cb}\x03\x02\x02\x02\u{6cd}\u{6ce}\x03\x02\x02\x02\
	\u{6ce}\u{6d0}\x03\x02\x02\x02\u{6cf}\u{6cd}\x03\x02\x02\x02\u{6d0}\u{6d4}\
	\x07\x09\x02\x02\u{6d1}\u{6d3}\x07\x07\x02\x02\u{6d2}\u{6d1}\x03\x02\x02\
	\x02\u{6d3}\u{6d6}\x03\x02\x02\x02\u{6d4}\u{6d2}\x03\x02\x02\x02\u{6d4}\
	\u{6d5}\x03\x02\x02\x02\u{6d5}\u{6d7}\x03\x02\x02\x02\u{6d6}\u{6d4}\x03\
	\x02\x02\x02\u{6d7}\u{6d9}\x05\x6e\x38\x02\u{6d8}\u{6cd}\x03\x02\x02\x02\
	\u{6d9}\u{6dc}\x03\x02\x02\x02\u{6da}\u{6d8}\x03\x02\x02\x02\u{6da}\u{6db}\
	\x03\x02\x02\x02\u{6db}\x6d\x03\x02\x02\x02\u{6dc}\u{6da}\x03\x02\x02\x02\
	\u{6dd}\u{6e5}\x05\u{15a}\u{ae}\x02\u{6de}\u{6e0}\x07\x07\x02\x02\u{6df}\
	\u{6de}\x03\x02\x02\x02\u{6e0}\u{6e3}\x03\x02\x02\x02\u{6e1}\u{6df}\x03\
	\x02\x02\x02\u{6e1}\u{6e2}\x03\x02\x02\x02\u{6e2}\u{6e4}\x03\x02\x02\x02\
	\u{6e3}\u{6e1}\x03\x02\x02\x02\u{6e4}\u{6e6}\x05\u{d0}\x69\x02\u{6e5}\u{6e1}\
	\x03\x02\x02\x02\u{6e5}\u{6e6}\x03\x02\x02\x02\u{6e6}\x6f\x03\x02\x02\x02\
	\u{6e7}\u{6e9}\x05\x72\x3a\x02\u{6e8}\u{6e7}\x03\x02\x02\x02\u{6e8}\u{6e9}\
	\x03\x02\x02\x02\u{6e9}\u{6ea}\x03\x02\x02\x02\u{6ea}\u{6ed}\x05\x64\x33\
	\x02\u{6eb}\u{6ed}\x07\x11\x02\x02\u{6ec}\u{6e8}\x03\x02\x02\x02\u{6ec}\
	\u{6eb}\x03\x02\x02\x02\u{6ed}\x71\x03\x02\x02\x02\u{6ee}\u{6f0}\x05\x74\
	\x3b\x02\u{6ef}\u{6ee}\x03\x02\x02\x02\u{6f0}\u{6f1}\x03\x02\x02\x02\u{6f1}\
	\u{6ef}\x03\x02\x02\x02\u{6f1}\u{6f2}\x03\x02\x02\x02\u{6f2}\x73\x03\x02\
	\x02\x02\u{6f3}\u{6f7}\x05\u{13e}\u{a0}\x02\u{6f4}\u{6f6}\x07\x07\x02\x02\
	\u{6f5}\u{6f4}\x03\x02\x02\x02\u{6f6}\u{6f9}\x03\x02\x02\x02\u{6f7}\u{6f5}\
	\x03\x02\x02\x02\u{6f7}\u{6f8}\x03\x02\x02\x02\u{6f8}\u{6fc}\x03\x02\x02\
	\x02\u{6f9}\u{6f7}\x03\x02\x02\x02\u{6fa}\u{6fc}\x05\u{150}\u{a9}\x02\u{6fb}\
	\u{6f3}\x03\x02\x02\x02\u{6fb}\u{6fa}\x03\x02\x02\x02\u{6fc}\x75\x03\x02\
	\x02\x02\u{6fd}\u{701}\x05\x7c\x3f\x02\u{6fe}\u{700}\x07\x07\x02\x02\u{6ff}\
	\u{6fe}\x03\x02\x02\x02\u{700}\u{703}\x03\x02\x02\x02\u{701}\u{6ff}\x03\
	\x02\x02\x02\u{701}\u{702}\x03\x02\x02\x02\u{702}\u{704}\x03\x02\x02\x02\
	\u{703}\u{701}\x03\x02\x02\x02\u{704}\u{708}\x07\x09\x02\x02\u{705}\u{707}\
	\x07\x07\x02\x02\u{706}\u{705}\x03\x02\x02\x02\u{707}\u{70a}\x03\x02\x02\
	\x02\u{708}\u{706}\x03\x02\x02\x02\u{708}\u{709}\x03\x02\x02\x02\u{709}\
	\u{70c}\x03\x02\x02\x02\u{70a}\u{708}\x03\x02\x02\x02\u{70b}\u{6fd}\x03\
	\x02\x02\x02\u{70b}\u{70c}\x03\x02\x02\x02\u{70c}\u{70d}\x03\x02\x02\x02\
	\u{70d}\u{711}\x05\x78\x3d\x02\u{70e}\u{710}\x07\x07\x02\x02\u{70f}\u{70e}\
	\x03\x02\x02\x02\u{710}\u{713}\x03\x02\x02\x02\u{711}\u{70f}\x03\x02\x02\
	\x02\u{711}\u{712}\x03\x02\x02\x02\u{712}\u{714}\x03\x02\x02\x02\u{713}\
	\u{711}\x03\x02\x02\x02\u{714}\u{718}\x07\x24\x02\x02\u{715}\u{717}\x07\
	\x07\x02\x02\u{716}\u{715}\x03\x02\x02\x02\u{717}\u{71a}\x03\x02\x02\x02\
	\u{718}\u{716}\x03\x02\x02\x02\u{718}\u{719}\x03\x02\x02\x02\u{719}\u{71b}\
	\x03\x02\x02\x02\u{71a}\u{718}\x03\x02\x02\x02\u{71b}\u{71c}\x05\x64\x33\
	\x02\u{71c}\x77\x03\x02\x02\x02\u{71d}\u{721}\x07\x0b\x02\x02\u{71e}\u{720}\
	\x07\x07\x02\x02\u{71f}\u{71e}\x03\x02\x02\x02\u{720}\u{723}\x03\x02\x02\
	\x02\u{721}\u{71f}\x03\x02\x02\x02\u{721}\u{722}\x03\x02\x02\x02\u{722}\
	\u{726}\x03\x02\x02\x02\u{723}\u{721}\x03\x02\x02\x02\u{724}\u{727}\x05\
	\x56\x2c\x02\u{725}\u{727}\x05\x64\x33\x02\u{726}\u{724}\x03\x02\x02\x02\
	\u{726}\u{725}\x03\x02\x02\x02\u{726}\u{727}\x03\x02\x02\x02\u{727}\u{73b}\
	\x03\x02\x02\x02\u{728}\u{72a}\x07\x07\x02\x02\u{729}\u{728}\x03\x02\x02\
	\x02\u{72a}\u{72d}\x03\x02\x02\x02\u{72b}\u{729}\x03\x02\x02\x02\u{72b}\
	\u{72c}\x03\x02\x02\x02\u{72c}\u{72e}\x03\x02\x02\x02\u{72d}\u{72b}\x03\
	\x02\x02\x02\u{72e}\u{732}\x07\x0a\x02\x02\u{72f}\u{731}\x07\x07\x02\x02\
	\u{730}\u{72f}\x03\x02\x02\x02\u{731}\u{734}\x03\x02\x02\x02\u{732}\u{730}\
	\x03\x02\x02\x02\u{732}\u{733}\x03\x02\x02\x02\u{733}\u{737}\x03\x02\x02\
	\x02\u{734}\u{732}\x03\x02\x02\x02\u{735}\u{738}\x05\x56\x2c\x02\u{736}\
	\u{738}\x05\x64\x33\x02\u{737}\u{735}\x03\x02\x02\x02\u{737}\u{736}\x03\
	\x02\x02\x02\u{738}\u{73a}\x03\x02\x02\x02\u{739}\u{72b}\x03\x02\x02\x02\
	\u{73a}\u{73d}\x03\x02\x02\x02\u{73b}\u{739}\x03\x02\x02\x02\u{73b}\u{73c}\
	\x03\x02\x02\x02\u{73c}\u{745}\x03\x02\x02\x02\u{73d}\u{73b}\x03\x02\x02\
	\x02\u{73e}\u{740}\x07\x07\x02\x02\u{73f}\u{73e}\x03\x02\x02\x02\u{740}\
	\u{743}\x03\x02\x02\x02\u{741}\u{73f}\x03\x02\x02\x02\u{741}\u{742}\x03\
	\x02\x02\x02\u{742}\u{744}\x03\x02\x02\x02\u{743}\u{741}\x03\x02\x02\x02\
	\u{744}\u{746}\x07\x0a\x02\x02\u{745}\u{741}\x03\x02\x02\x02\u{745}\u{746}\
	\x03\x02\x02\x02\u{746}\u{74a}\x03\x02\x02\x02\u{747}\u{749}\x07\x07\x02\
	\x02\u{748}\u{747}\x03\x02\x02\x02\u{749}\u{74c}\x03\x02\x02\x02\u{74a}\
	\u{748}\x03\x02\x02\x02\u{74a}\u{74b}\x03\x02\x02\x02\u{74b}\u{74d}\x03\
	\x02\x02\x02\u{74c}\u{74a}\x03\x02\x02\x02\u{74d}\u{74e}\x07\x0c\x02\x02\
	\u{74e}\x79\x03\x02\x02\x02\u{74f}\u{753}\x07\x0b\x02\x02\u{750}\u{752}\
	\x07\x07\x02\x02\u{751}\u{750}\x03\x02\x02\x02\u{752}\u{755}\x03\x02\x02\
	\x02\u{753}\u{751}\x03\x02\x02\x02\u{753}\u{754}\x03\x02\x02\x02\u{754}\
	\u{756}\x03\x02\x02\x02\u{755}\u{753}\x03\x02\x02\x02\u{756}\u{75a}\x05\
	\x64\x33\x02\u{757}\u{759}\x07\x07\x02\x02\u{758}\u{757}\x03\x02\x02\x02\
	\u{759}\u{75c}\x03\x02\x02\x02\u{75a}\u{758}\x03\x02\x02\x02\u{75a}\u{75b}\
	\x03\x02\x02\x02\u{75b}\u{75d}\x03\x02\x02\x02\u{75c}\u{75a}\x03\x02\x02\
	\x02\u{75d}\u{75e}\x07\x0c\x02\x02\u{75e}\x7b\x03\x02\x02\x02\u{75f}\u{761}\
	\x05\u{134}\u{9b}\x02\u{760}\u{75f}\x03\x02\x02\x02\u{760}\u{761}\x03\x02\
	\x02\x02\u{761}\u{765}\x03\x02\x02\x02\u{762}\u{766}\x05\x7a\x3e\x02\u{763}\
	\u{766}\x05\x68\x35\x02\u{764}\u{766}\x05\x66\x34\x02\u{765}\u{762}\x03\
	\x02\x02\x02\u{765}\u{763}\x03\x02\x02\x02\u{765}\u{764}\x03\x02\x02\x02\
	\u{766}\x7d\x03\x02\x02\x02\u{767}\u{76b}\x07\x0b\x02\x02\u{768}\u{76a}\
	\x07\x07\x02\x02\u{769}\u{768}\x03\x02\x02\x02\u{76a}\u{76d}\x03\x02\x02\
	\x02\u{76b}\u{769}\x03\x02\x02\x02\u{76b}\u{76c}\x03\x02\x02\x02\u{76c}\
	\u{770}\x03\x02\x02\x02\u{76d}\u{76b}\x03\x02\x02\x02\u{76e}\u{771}\x05\
	\x6c\x37\x02\u{76f}\u{771}\x05\x7e\x40\x02\u{770}\u{76e}\x03\x02\x02\x02\
	\u{770}\u{76f}\x03\x02\x02\x02\u{771}\u{775}\x03\x02\x02\x02\u{772}\u{774}\
	\x07\x07\x02\x02\u{773}\u{772}\x03\x02\x02\x02\u{774}\u{777}\x03\x02\x02\
	\x02\u{775}\u{773}\x03\x02\x02\x02\u{775}\u{776}\x03\x02\x02\x02\u{776}\
	\u{778}\x03\x02\x02\x02\u{777}\u{775}\x03\x02\x02\x02\u{778}\u{779}\x07\
	\x0c\x02\x02\u{779}\x7f\x03\x02\x02\x02\u{77a}\u{77c}\x05\u{134}\u{9b}\x02\
	\u{77b}\u{77a}\x03\x02\x02\x02\u{77b}\u{77c}\x03\x02\x02\x02\u{77c}\u{77f}\
	\x03\x02\x02\x02\u{77d}\u{780}\x05\x6c\x37\x02\u{77e}\u{780}\x05\x7e\x40\
	\x02\u{77f}\u{77d}\x03\x02\x02\x02\u{77f}\u{77e}\x03\x02\x02\x02\u{780}\
	\u{784}\x03\x02\x02\x02\u{781}\u{783}\x07\x07\x02\x02\u{782}\u{781}\x03\
	\x02\x02\x02\u{783}\u{786}\x03\x02\x02\x02\u{784}\u{782}\x03\x02\x02\x02\
	\u{784}\u{785}\x03\x02\x02\x02\u{785}\u{787}\x03\x02\x02\x02\u{786}\u{784}\
	\x03\x02\x02\x02\u{787}\u{78b}\x07\x3b\x02\x02\u{788}\u{78a}\x07\x07\x02\
	\x02\u{789}\u{788}\x03\x02\x02\x02\u{78a}\u{78d}\x03\x02\x02\x02\u{78b}\
	\u{789}\x03\x02\x02\x02\u{78b}\u{78c}\x03\x02\x02\x02\u{78c}\u{78f}\x03\
	\x02\x02\x02\u{78d}\u{78b}\x03\x02\x02\x02\u{78e}\u{790}\x05\u{134}\u{9b}\
	\x02\u{78f}\u{78e}\x03\x02\x02\x02\u{78f}\u{790}\x03\x02\x02\x02\u{790}\
	\u{793}\x03\x02\x02\x02\u{791}\u{794}\x05\x6c\x37\x02\u{792}\u{794}\x05\
	\x7e\x40\x02\u{793}\u{791}\x03\x02\x02\x02\u{793}\u{792}\x03\x02\x02\x02\
	\u{794}\u{81}\x03\x02\x02\x02\u{795}\u{79b}\x05\u{84}\x43\x02\u{796}\u{797}\
	\x05\u{98}\x4d\x02\u{797}\u{798}\x05\u{84}\x43\x02\u{798}\u{79a}\x03\x02\
	\x02\x02\u{799}\u{796}\x03\x02\x02\x02\u{79a}\u{79d}\x03\x02\x02\x02\u{79b}\
	\u{799}\x03\x02\x02\x02\u{79b}\u{79c}\x03\x02\x02\x02\u{79c}\u{79f}\x03\
	\x02\x02\x02\u{79d}\u{79b}\x03\x02\x02\x02\u{79e}\u{795}\x03\x02\x02\x02\
	\u{79e}\u{79f}\x03\x02\x02\x02\u{79f}\u{7a1}\x03\x02\x02\x02\u{7a0}\u{7a2}\
	\x05\u{98}\x4d\x02\u{7a1}\u{7a0}\x03\x02\x02\x02\u{7a1}\u{7a2}\x03\x02\x02\
	\x02\u{7a2}\u{83}\x03\x02\x02\x02\u{7a3}\u{7a6}\x05\u{86}\x44\x02\u{7a4}\
	\u{7a6}\x05\u{150}\u{a9}\x02\u{7a5}\u{7a3}\x03\x02\x02\x02\u{7a5}\u{7a4}\
	\x03\x02\x02\x02\u{7a6}\u{7a9}\x03\x02\x02\x02\u{7a7}\u{7a5}\x03\x02\x02\
	\x02\u{7a7}\u{7a8}\x03\x02\x02\x02\u{7a8}\u{7ae}\x03\x02\x02\x02\u{7a9}\
	\u{7a7}\x03\x02\x02\x02\u{7aa}\u{7af}\x05\x16\x0c\x02\u{7ab}\u{7af}\x05\
	\u{94}\x4b\x02\u{7ac}\u{7af}\x05\u{8c}\x47\x02\u{7ad}\u{7af}\x05\u{9a}\x4e\
	\x02\u{7ae}\u{7aa}\x03\x02\x02\x02\u{7ae}\u{7ab}\x03\x02\x02\x02\u{7ae}\
	\u{7ac}\x03\x02\x02\x02\u{7ae}\u{7ad}\x03\x02\x02\x02\u{7af}\u{85}\x03\x02\
	\x02\x02\u{7b0}\u{7b1}\x05\u{15a}\u{ae}\x02\u{7b1}\u{7b5}\x09\x06\x02\x02\
	\u{7b2}\u{7b4}\x07\x07\x02\x02\u{7b3}\u{7b2}\x03\x02\x02\x02\u{7b4}\u{7b7}\
	\x03\x02\x02\x02\u{7b5}\u{7b3}\x03\x02\x02\x02\u{7b5}\u{7b6}\x03\x02\x02\
	\x02\u{7b6}\u{87}\x03\x02\x02\x02\u{7b7}\u{7b5}\x03\x02\x02\x02\u{7b8}\u{7bb}\
	\x05\u{8a}\x46\x02\u{7b9}\u{7bb}\x05\u{84}\x43\x02\u{7ba}\u{7b8}\x03\x02\
	\x02\x02\u{7ba}\u{7b9}\x03\x02\x02\x02\u{7bb}\u{89}\x03\x02\x02\x02\u{7bc}\
	\u{7c0}\x07\x0f\x02\x02\u{7bd}\u{7bf}\x07\x07\x02\x02\u{7be}\u{7bd}\x03\
	\x02\x02\x02\u{7bf}\u{7c2}\x03\x02\x02\x02\u{7c0}\u{7be}\x03\x02\x02\x02\
	\u{7c0}\u{7c1}\x03\x02\x02\x02\u{7c1}\u{7c3}\x03\x02\x02\x02\u{7c2}\u{7c0}\
	\x03\x02\x02\x02\u{7c3}\u{7c7}\x05\u{82}\x42\x02\u{7c4}\u{7c6}\x07\x07\x02\
	\x02\u{7c5}\u{7c4}\x03\x02\x02\x02\u{7c6}\u{7c9}\x03\x02\x02\x02\u{7c7}\
	\u{7c5}\x03\x02\x02\x02\u{7c7}\u{7c8}\x03\x02\x02\x02\u{7c8}\u{7ca}\x03\
	\x02\x02\x02\u{7c9}\u{7c7}\x03\x02\x02\x02\u{7ca}\u{7cb}\x07\x10\x02\x02\
	\u{7cb}\u{8b}\x03\x02\x02\x02\u{7cc}\u{7d0}\x05\u{8e}\x48\x02\u{7cd}\u{7d0}\
	\x05\u{90}\x49\x02\u{7ce}\u{7d0}\x05\u{92}\x4a\x02\u{7cf}\u{7cc}\x03\x02\
	\x02\x02\u{7cf}\u{7cd}\x03\x02\x02\x02\u{7cf}\u{7ce}\x03\x02\x02\x02\u{7d0}\
	\u{8d}\x03\x02\x02\x02\u{7d1}\u{7d5}\x07\x61\x02\x02\u{7d2}\u{7d4}\x07\x07\
	\x02\x02\u{7d3}\u{7d2}\x03\x02\x02\x02\u{7d4}\u{7d7}\x03\x02\x02\x02\u{7d5}\
	\u{7d3}\x03\x02\x02\x02\u{7d5}\u{7d6}\x03\x02\x02\x02\u{7d6}\u{7d8}\x03\
	\x02\x02\x02\u{7d7}\u{7d5}\x03\x02\x02\x02\u{7d8}\u{7dc}\x07\x0b\x02\x02\
	\u{7d9}\u{7db}\x05\u{150}\u{a9}\x02\u{7da}\u{7d9}\x03\x02\x02\x02\u{7db}\
	\u{7de}\x03\x02\x02\x02\u{7dc}\u{7da}\x03\x02\x02\x02\u{7dc}\u{7dd}\x03\
	\x02\x02\x02\u{7dd}\u{7e1}\x03\x02\x02\x02\u{7de}\u{7dc}\x03\x02\x02\x02\
	\u{7df}\u{7e2}\x05\x44\x23\x02\u{7e0}\u{7e2}\x05\x46\x24\x02\u{7e1}\u{7df}\
	\x03\x02\x02\x02\u{7e1}\u{7e0}\x03\x02\x02\x02\u{7e2}\u{7e3}\x03\x02\x02\
	\x02\u{7e3}\u{7e4}\x07\x6a\x02\x02\u{7e4}\u{7e5}\x05\u{9a}\x4e\x02\u{7e5}\
	\u{7e9}\x07\x0c\x02\x02\u{7e6}\u{7e8}\x07\x07\x02\x02\u{7e7}\u{7e6}\x03\
	\x02\x02\x02\u{7e8}\u{7eb}\x03\x02\x02\x02\u{7e9}\u{7e7}\x03\x02\x02\x02\
	\u{7e9}\u{7ea}\x03\x02\x02\x02\u{7ea}\u{7ed}\x03\x02\x02\x02\u{7eb}\u{7e9}\
	\x03\x02\x02\x02\u{7ec}\u{7ee}\x05\u{88}\x45\x02\u{7ed}\u{7ec}\x03\x02\x02\
	\x02\u{7ed}\u{7ee}\x03\x02\x02\x02\u{7ee}\u{8f}\x03\x02\x02\x02\u{7ef}\u{7f3}\
	\x07\x63\x02\x02\u{7f0}\u{7f2}\x07\x07\x02\x02\u{7f1}\u{7f0}\x03\x02\x02\
	\x02\u{7f2}\u{7f5}\x03\x02\x02\x02\u{7f3}\u{7f1}\x03\x02\x02\x02\u{7f3}\
	\u{7f4}\x03\x02\x02\x02\u{7f4}\u{7f6}\x03\x02\x02\x02\u{7f5}\u{7f3}\x03\
	\x02\x02\x02\u{7f6}\u{7f7}\x07\x0b\x02\x02\u{7f7}\u{7f8}\x05\u{9a}\x4e\x02\
	\u{7f8}\u{7fc}\x07\x0c\x02\x02\u{7f9}\u{7fb}\x07\x07\x02\x02\u{7fa}\u{7f9}\
	\x03\x02\x02\x02\u{7fb}\u{7fe}\x03\x02\x02\x02\u{7fc}\u{7fa}\x03\x02\x02\
	\x02\u{7fc}\u{7fd}\x03\x02\x02\x02\u{7fd}\u{801}\x03\x02\x02\x02\u{7fe}\
	\u{7fc}\x03\x02\x02\x02\u{7ff}\u{802}\x05\u{88}\x45\x02\u{800}\u{802}\x07\
	\x1d\x02\x02\u{801}\u{7ff}\x03\x02\x02\x02\u{801}\u{800}\x03\x02\x02\x02\
	\u{802}\u{91}\x03\x02\x02\x02\u{803}\u{807}\x07\x62\x02\x02\u{804}\u{806}\
	\x07\x07\x02\x02\u{805}\u{804}\x03\x02\x02\x02\u{806}\u{809}\x03\x02\x02\
	\x02\u{807}\u{805}\x03\x02\x02\x02\u{807}\u{808}\x03\x02\x02\x02\u{808}\
	\u{80b}\x03\x02\x02\x02\u{809}\u{807}\x03\x02\x02\x02\u{80a}\u{80c}\x05\
	\u{88}\x45\x02\u{80b}\u{80a}\x03\x02\x02\x02\u{80b}\u{80c}\x03\x02\x02\x02\
	\u{80c}\u{810}\x03\x02\x02\x02\u{80d}\u{80f}\x07\x07\x02\x02\u{80e}\u{80d}\
	\x03\x02\x02\x02\u{80f}\u{812}\x03\x02\x02\x02\u{810}\u{80e}\x03\x02\x02\
	\x02\u{810}\u{811}\x03\x02\x02\x02\u{811}\u{813}\x03\x02\x02\x02\u{812}\
	\u{810}\x03\x02\x02\x02\u{813}\u{817}\x07\x63\x02\x02\u{814}\u{816}\x07\
	\x07\x02\x02\u{815}\u{814}\x03\x02\x02\x02\u{816}\u{819}\x03\x02\x02\x02\
	\u{817}\u{815}\x03\x02\x02\x02\u{817}\u{818}\x03\x02\x02\x02\u{818}\u{81a}\
	\x03\x02\x02\x02\u{819}\u{817}\x03\x02\x02\x02\u{81a}\u{81b}\x07\x0b\x02\
	\x02\u{81b}\u{81c}\x05\u{9a}\x4e\x02\u{81c}\u{81d}\x07\x0c\x02\x02\u{81d}\
	\u{93}\x03\x02\x02\x02\u{81e}\u{81f}\x05\u{be}\x60\x02\u{81f}\u{820}\x07\
	\x1e\x02\x02\u{820}\u{825}\x03\x02\x02\x02\u{821}\u{822}\x05\u{c2}\x62\x02\
	\u{822}\u{823}\x05\u{114}\u{8b}\x02\u{823}\u{825}\x03\x02\x02\x02\u{824}\
	\u{81e}\x03\x02\x02\x02\u{824}\u{821}\x03\x02\x02\x02\u{825}\u{829}\x03\
	\x02\x02\x02\u{826}\u{828}\x07\x07\x02\x02\u{827}\u{826}\x03\x02\x02\x02\
	\u{828}\u{82b}\x03\x02\x02\x02\u{829}\u{827}\x03\x02\x02\x02\u{829}\u{82a}\
	\x03\x02\x02\x02\u{82a}\u{82c}\x03\x02\x02\x02\u{82b}\u{829}\x03\x02\x02\
	\x02\u{82c}\u{82d}\x05\u{9a}\x4e\x02\u{82d}\u{95}\x03\x02\x02\x02\u{82e}\
	\u{832}\x09\x07\x02\x02\u{82f}\u{831}\x07\x07\x02\x02\u{830}\u{82f}\x03\
	\x02\x02\x02\u{831}\u{834}\x03\x02\x02\x02\u{832}\u{830}\x03\x02\x02\x02\
	\u{832}\u{833}\x03\x02\x02\x02\u{833}\u{97}\x03\x02\x02\x02\u{834}\u{832}\
	\x03\x02\x02\x02\u{835}\u{837}\x09\x07\x02\x02\u{836}\u{835}\x03\x02\x02\
	\x02\u{837}\u{838}\x03\x02\x02\x02\u{838}\u{836}\x03\x02\x02\x02\u{838}\
	\u{839}\x03\x02\x02\x02\u{839}\u{99}\x03\x02\x02\x02\u{83a}\u{83b}\x05\u{9c}\
	\x4f\x02\u{83b}\u{9b}\x03\x02\x02\x02\u{83c}\u{84d}\x05\u{9e}\x50\x02\u{83d}\
	\u{83f}\x07\x07\x02\x02\u{83e}\u{83d}\x03\x02\x02\x02\u{83f}\u{842}\x03\
	\x02\x02\x02\u{840}\u{83e}\x03\x02\x02\x02\u{840}\u{841}\x03\x02\x02\x02\
	\u{841}\u{843}\x03\x02\x02\x02\u{842}\u{840}\x03\x02\x02\x02\u{843}\u{847}\
	\x07\x19\x02\x02\u{844}\u{846}\x07\x07\x02\x02\u{845}\u{844}\x03\x02\x02\
	\x02\u{846}\u{849}\x03\x02\x02\x02\u{847}\u{845}\x03\x02\x02\x02\u{847}\
	\u{848}\x03\x02\x02\x02\u{848}\u{84a}\x03\x02\x02\x02\u{849}\u{847}\x03\
	\x02\x02\x02\u{84a}\u{84c}\x05\u{9e}\x50\x02\u{84b}\u{840}\x03\x02\x02\x02\
	\u{84c}\u{84f}\x03\x02\x02\x02\u{84d}\u{84b}\x03\x02\x02\x02\u{84d}\u{84e}\
	\x03\x02\x02\x02\u{84e}\u{9d}\x03\x02\x02\x02\u{84f}\u{84d}\x03\x02\x02\
	\x02\u{850}\u{861}\x05\u{a0}\x51\x02\u{851}\u{853}\x07\x07\x02\x02\u{852}\
	\u{851}\x03\x02\x02\x02\u{853}\u{856}\x03\x02\x02\x02\u{854}\u{852}\x03\
	\x02\x02\x02\u{854}\u{855}\x03\x02\x02\x02\u{855}\u{857}\x03\x02\x02\x02\
	\u{856}\u{854}\x03\x02\x02\x02\u{857}\u{85b}\x07\x18\x02\x02\u{858}\u{85a}\
	\x07\x07\x02\x02\u{859}\u{858}\x03\x02\x02\x02\u{85a}\u{85d}\x03\x02\x02\
	\x02\u{85b}\u{859}\x03\x02\x02\x02\u{85b}\u{85c}\x03\x02\x02\x02\u{85c}\
	\u{85e}\x03\x02\x02\x02\u{85d}\u{85b}\x03\x02\x02\x02\u{85e}\u{860}\x05\
	\u{a0}\x51\x02\u{85f}\u{854}\x03\x02\x02\x02\u{860}\u{863}\x03\x02\x02\x02\
	\u{861}\u{85f}\x03\x02\x02\x02\u{861}\u{862}\x03\x02\x02\x02\u{862}\u{9f}\
	\x03\x02\x02\x02\u{863}\u{861}\x03\x02\x02\x02\u{864}\u{870}\x05\u{a2}\x52\
	\x02\u{865}\u{869}\x05\u{116}\u{8c}\x02\u{866}\u{868}\x07\x07\x02\x02\u{867}\
	\u{866}\x03\x02\x02\x02\u{868}\u{86b}\x03\x02\x02\x02\u{869}\u{867}\x03\
	\x02\x02\x02\u{869}\u{86a}\x03\x02\x02\x02\u{86a}\u{86c}\x03\x02\x02\x02\
	\u{86b}\u{869}\x03\x02\x02\x02\u{86c}\u{86d}\x05\u{a2}\x52\x02\u{86d}\u{86f}\
	\x03\x02\x02\x02\u{86e}\u{865}\x03\x02\x02\x02\u{86f}\u{872}\x03\x02\x02\
	\x02\u{870}\u{86e}\x03\x02\x02\x02\u{870}\u{871}\x03\x02\x02\x02\u{871}\
	\u{a1}\x03\x02\x02\x02\u{872}\u{870}\x03\x02\x02\x02\u{873}\u{87f}\x05\u{a4}\
	\x53\x02\u{874}\u{878}\x05\u{118}\u{8d}\x02\u{875}\u{877}\x07\x07\x02\x02\
	\u{876}\u{875}\x03\x02\x02\x02\u{877}\u{87a}\x03\x02\x02\x02\u{878}\u{876}\
	\x03\x02\x02\x02\u{878}\u{879}\x03\x02\x02\x02\u{879}\u{87b}\x03\x02\x02\
	\x02\u{87a}\u{878}\x03\x02\x02\x02\u{87b}\u{87c}\x05\u{a4}\x53\x02\u{87c}\
	\u{87e}\x03\x02\x02\x02\u{87d}\u{874}\x03\x02\x02\x02\u{87e}\u{881}\x03\
	\x02\x02\x02\u{87f}\u{87d}\x03\x02\x02\x02\u{87f}\u{880}\x03\x02\x02\x02\
	\u{880}\u{a3}\x03\x02\x02\x02\u{881}\u{87f}\x03\x02\x02\x02\u{882}\u{886}\
	\x05\u{a6}\x54\x02\u{883}\u{885}\x05\u{cc}\x67\x02\u{884}\u{883}\x03\x02\
	\x02\x02\u{885}\u{888}\x03\x02\x02\x02\u{886}\u{884}\x03\x02\x02\x02\u{886}\
	\u{887}\x03\x02\x02\x02\u{887}\u{a5}\x03\x02\x02\x02\u{888}\u{886}\x03\x02\
	\x02\x02\u{889}\u{89e}\x05\u{a8}\x55\x02\u{88a}\u{88e}\x05\u{11a}\u{8e}\
	\x02\u{88b}\u{88d}\x07\x07\x02\x02\u{88c}\u{88b}\x03\x02\x02\x02\u{88d}\
	\u{890}\x03\x02\x02\x02\u{88e}\u{88c}\x03\x02\x02\x02\u{88e}\u{88f}\x03\
	\x02\x02\x02\u{88f}\u{891}\x03\x02\x02\x02\u{890}\u{88e}\x03\x02\x02\x02\
	\u{891}\u{892}\x05\u{a8}\x55\x02\u{892}\u{89d}\x03\x02\x02\x02\u{893}\u{897}\
	\x05\u{11c}\u{8f}\x02\u{894}\u{896}\x07\x07\x02\x02\u{895}\u{894}\x03\x02\
	\x02\x02\u{896}\u{899}\x03\x02\x02\x02\u{897}\u{895}\x03\x02\x02\x02\u{897}\
	\u{898}\x03\x02\x02\x02\u{898}\u{89a}\x03\x02\x02\x02\u{899}\u{897}\x03\
	\x02\x02\x02\u{89a}\u{89b}\x05\x64\x33\x02\u{89b}\u{89d}\x03\x02\x02\x02\
	\u{89c}\u{88a}\x03\x02\x02\x02\u{89c}\u{893}\x03\x02\x02\x02\u{89d}\u{8a0}\
	\x03\x02\x02\x02\u{89e}\u{89c}\x03\x02\x02\x02\u{89e}\u{89f}\x03\x02\x02\
	\x02\u{89f}\u{a7}\x03\x02\x02\x02\u{8a0}\u{89e}\x03\x02\x02\x02\u{8a1}\u{8b3}\
	\x05\u{ac}\x57\x02\u{8a2}\u{8a4}\x07\x07\x02\x02\u{8a3}\u{8a2}\x03\x02\x02\
	\x02\u{8a4}\u{8a7}\x03\x02\x02\x02\u{8a5}\u{8a3}\x03\x02\x02\x02\u{8a5}\
	\u{8a6}\x03\x02\x02\x02\u{8a6}\u{8a8}\x03\x02\x02\x02\u{8a7}\u{8a5}\x03\
	\x02\x02\x02\u{8a8}\u{8ac}\x05\u{aa}\x56\x02\u{8a9}\u{8ab}\x07\x07\x02\x02\
	\u{8aa}\u{8a9}\x03\x02\x02\x02\u{8ab}\u{8ae}\x03\x02\x02\x02\u{8ac}\u{8aa}\
	\x03\x02\x02\x02\u{8ac}\u{8ad}\x03\x02\x02\x02\u{8ad}\u{8af}\x03\x02\x02\
	\x02\u{8ae}\u{8ac}\x03\x02\x02\x02\u{8af}\u{8b0}\x05\u{ac}\x57\x02\u{8b0}\
	\u{8b2}\x03\x02\x02\x02\u{8b1}\u{8a5}\x03\x02\x02\x02\u{8b2}\u{8b5}\x03\
	\x02\x02\x02\u{8b3}\u{8b1}\x03\x02\x02\x02\u{8b3}\u{8b4}\x03\x02\x02\x02\
	\u{8b4}\u{a9}\x03\x02\x02\x02\u{8b5}\u{8b3}\x03\x02\x02\x02\u{8b6}\u{8b7}\
	\x07\x30\x02\x02\u{8b7}\u{8b8}\x07\x1c\x02\x02\u{8b8}\u{ab}\x03\x02\x02\
	\x02\u{8b9}\u{8c5}\x05\u{ae}\x58\x02\u{8ba}\u{8be}\x05\u{15a}\u{ae}\x02\
	\u{8bb}\u{8bd}\x07\x07\x02\x02\u{8bc}\u{8bb}\x03\x02\x02\x02\u{8bd}\u{8c0}\
	\x03\x02\x02\x02\u{8be}\u{8bc}\x03\x02\x02\x02\u{8be}\u{8bf}\x03\x02\x02\
	\x02\u{8bf}\u{8c1}\x03\x02\x02\x02\u{8c0}\u{8be}\x03\x02\x02\x02\u{8c1}\
	\u{8c2}\x05\u{ae}\x58\x02\u{8c2}\u{8c4}\x03\x02\x02\x02\u{8c3}\u{8ba}\x03\
	\x02\x02\x02\u{8c4}\u{8c7}\x03\x02\x02\x02\u{8c5}\u{8c3}\x03\x02\x02\x02\
	\u{8c5}\u{8c6}\x03\x02\x02\x02\u{8c6}\u{ad}\x03\x02\x02\x02\u{8c7}\u{8c5}\
	\x03\x02\x02\x02\u{8c8}\u{8d3}\x05\u{b0}\x59\x02\u{8c9}\u{8cd}\x09\x08\x02\
	\x02\u{8ca}\u{8cc}\x07\x07\x02\x02\u{8cb}\u{8ca}\x03\x02\x02\x02\u{8cc}\
	\u{8cf}\x03\x02\x02\x02\u{8cd}\u{8cb}\x03\x02\x02\x02\u{8cd}\u{8ce}\x03\
	\x02\x02\x02\u{8ce}\u{8d0}\x03\x02\x02\x02\u{8cf}\u{8cd}\x03\x02\x02\x02\
	\u{8d0}\u{8d2}\x05\u{b0}\x59\x02\u{8d1}\u{8c9}\x03\x02\x02\x02\u{8d2}\u{8d5}\
	\x03\x02\x02\x02\u{8d3}\u{8d1}\x03\x02\x02\x02\u{8d3}\u{8d4}\x03\x02\x02\
	\x02\u{8d4}\u{af}\x03\x02\x02\x02\u{8d5}\u{8d3}\x03\x02\x02\x02\u{8d6}\u{8e2}\
	\x05\u{b2}\x5a\x02\u{8d7}\u{8db}\x05\u{11e}\u{90}\x02\u{8d8}\u{8da}\x07\
	\x07\x02\x02\u{8d9}\u{8d8}\x03\x02\x02\x02\u{8da}\u{8dd}\x03\x02\x02\x02\
	\u{8db}\u{8d9}\x03\x02\x02\x02\u{8db}\u{8dc}\x03\x02\x02\x02\u{8dc}\u{8de}\
	\x03\x02\x02\x02\u{8dd}\u{8db}\x03\x02\x02\x02\u{8de}\u{8df}\x05\u{b2}\x5a\
	\x02\u{8df}\u{8e1}\x03\x02\x02\x02\u{8e0}\u{8d7}\x03\x02\x02\x02\u{8e1}\
	\u{8e4}\x03\x02\x02\x02\u{8e2}\u{8e0}\x03\x02\x02\x02\u{8e2}\u{8e3}\x03\
	\x02\x02\x02\u{8e3}\u{b1}\x03\x02\x02\x02\u{8e4}\u{8e2}\x03\x02\x02\x02\
	\u{8e5}\u{8f1}\x05\u{b4}\x5b\x02\u{8e6}\u{8ea}\x05\u{120}\u{91}\x02\u{8e7}\
	\u{8e9}\x07\x07\x02\x02\u{8e8}\u{8e7}\x03\x02\x02\x02\u{8e9}\u{8ec}\x03\
	\x02\x02\x02\u{8ea}\u{8e8}\x03\x02\x02\x02\u{8ea}\u{8eb}\x03\x02\x02\x02\
	\u{8eb}\u{8ed}\x03\x02\x02\x02\u{8ec}\u{8ea}\x03\x02\x02\x02\u{8ed}\u{8ee}\
	\x05\u{b4}\x5b\x02\u{8ee}\u{8f0}\x03\x02\x02\x02\u{8ef}\u{8e6}\x03\x02\x02\
	\x02\u{8f0}\u{8f3}\x03\x02\x02\x02\u{8f1}\u{8ef}\x03\x02\x02\x02\u{8f1}\
	\u{8f2}\x03\x02\x02\x02\u{8f2}\u{b3}\x03\x02\x02\x02\u{8f3}\u{8f1}\x03\x02\
	\x02\x02\u{8f4}\u{906}\x05\u{b6}\x5c\x02\u{8f5}\u{8f7}\x07\x07\x02\x02\u{8f6}\
	\u{8f5}\x03\x02\x02\x02\u{8f7}\u{8fa}\x03\x02\x02\x02\u{8f8}\u{8f6}\x03\
	\x02\x02\x02\u{8f8}\u{8f9}\x03\x02\x02\x02\u{8f9}\u{8fb}\x03\x02\x02\x02\
	\u{8fa}\u{8f8}\x03\x02\x02\x02\u{8fb}\u{8ff}\x05\u{122}\u{92}\x02\u{8fc}\
	\u{8fe}\x07\x07\x02\x02\u{8fd}\u{8fc}\x03\x02\x02\x02\u{8fe}\u{901}\x03\
	\x02\x02\x02\u{8ff}\u{8fd}\x03\x02\x02\x02\u{8ff}\u{900}\x03\x02\x02\x02\
	\u{900}\u{902}\x03\x02\x02\x02\u{901}\u{8ff}\x03\x02\x02\x02\u{902}\u{903}\
	\x05\x64\x33\x02\u{903}\u{905}\x03\x02\x02\x02\u{904}\u{8f8}\x03\x02\x02\
	\x02\u{905}\u{908}\x03\x02\x02\x02\u{906}\u{904}\x03\x02\x02\x02\u{906}\
	\u{907}\x03\x02\x02\x02\u{907}\u{b5}\x03\x02\x02\x02\u{908}\u{906}\x03\x02\
	\x02\x02\u{909}\u{90b}\x05\u{b8}\x5d\x02\u{90a}\u{909}\x03\x02\x02\x02\u{90b}\
	\u{90e}\x03\x02\x02\x02\u{90c}\u{90a}\x03\x02\x02\x02\u{90c}\u{90d}\x03\
	\x02\x02\x02\u{90d}\u{90f}\x03\x02\x02\x02\u{90e}\u{90c}\x03\x02\x02\x02\
	\u{90f}\u{910}\x05\u{ba}\x5e\x02\u{910}\u{b7}\x03\x02\x02\x02\u{911}\u{91b}\
	\x05\u{150}\u{a9}\x02\u{912}\u{91b}\x05\u{86}\x44\x02\u{913}\u{917}\x05\
	\u{124}\u{93}\x02\u{914}\u{916}\x07\x07\x02\x02\u{915}\u{914}\x03\x02\x02\
	\x02\u{916}\u{919}\x03\x02\x02\x02\u{917}\u{915}\x03\x02\x02\x02\u{917}\
	\u{918}\x03\x02\x02\x02\u{918}\u{91b}\x03\x02\x02\x02\u{919}\u{917}\x03\
	\x02\x02\x02\u{91a}\u{911}\x03\x02\x02\x02\u{91a}\u{912}\x03\x02\x02\x02\
	\u{91a}\u{913}\x03\x02\x02\x02\u{91b}\u{b9}\x03\x02\x02\x02\u{91c}\u{920}\
	\x05\u{d6}\x6c\x02\u{91d}\u{91f}\x05\u{bc}\x5f\x02\u{91e}\u{91d}\x03\x02\
	\x02\x02\u{91f}\u{922}\x03\x02\x02\x02\u{920}\u{91e}\x03\x02\x02\x02\u{920}\
	\u{921}\x03\x02\x02\x02\u{921}\u{bb}\x03\x02\x02\x02\u{922}\u{920}\x03\x02\
	\x02\x02\u{923}\u{929}\x05\u{126}\u{94}\x02\u{924}\u{929}\x05\u{d0}\x69\
	\x02\u{925}\u{929}\x05\u{cc}\x67\x02\u{926}\u{929}\x05\u{c8}\x65\x02\u{927}\
	\u{929}\x05\u{ca}\x66\x02\u{928}\u{923}\x03\x02\x02\x02\u{928}\u{924}\x03\
	\x02\x02\x02\u{928}\u{925}\x03\x02\x02\x02\u{928}\u{926}\x03\x02\x02\x02\
	\u{928}\u{927}\x03\x02\x02\x02\u{929}\u{bd}\x03\x02\x02\x02\u{92a}\u{92b}\
	\x05\u{ba}\x5e\x02\u{92b}\u{92c}\x05\u{c6}\x64\x02\u{92c}\u{930}\x03\x02\
	\x02\x02\u{92d}\u{930}\x05\u{15a}\u{ae}\x02\u{92e}\u{930}\x05\u{c0}\x61\
	\x02\u{92f}\u{92a}\x03\x02\x02\x02\u{92f}\u{92d}\x03\x02\x02\x02\u{92f}\
	\u{92e}\x03\x02\x02\x02\u{930}\u{bf}\x03\x02\x02\x02\u{931}\u{935}\x07\x0b\
	\x02\x02\u{932}\u{934}\x07\x07\x02\x02\u{933}\u{932}\x03\x02\x02\x02\u{934}\
	\u{937}\x03\x02\x02\x02\u{935}\u{933}\x03\x02\x02\x02\u{935}\u{936}\x03\
	\x02\x02\x02\u{936}\u{938}\x03\x02\x02\x02\u{937}\u{935}\x03\x02\x02\x02\
	\u{938}\u{93c}\x05\u{be}\x60\x02\u{939}\u{93b}\x07\x07\x02\x02\u{93a}\u{939}\
	\x03\x02\x02\x02\u{93b}\u{93e}\x03\x02\x02\x02\u{93c}\u{93a}\x03\x02\x02\
	\x02\u{93c}\u{93d}\x03\x02\x02\x02\u{93d}\u{93f}\x03\x02\x02\x02\u{93e}\
	\u{93c}\x03\x02\x02\x02\u{93f}\u{940}\x07\x0c\x02\x02\u{940}\u{c1}\x03\x02\
	\x02\x02\u{941}\u{944}\x05\u{b6}\x5c\x02\u{942}\u{944}\x05\u{c4}\x63\x02\
	\u{943}\u{941}\x03\x02\x02\x02\u{943}\u{942}\x03\x02\x02\x02\u{944}\u{c3}\
	\x03\x02\x02\x02\u{945}\u{949}\x07\x0b\x02\x02\u{946}\u{948}\x07\x07\x02\
	\x02\u{947}\u{946}\x03\x02\x02\x02\u{948}\u{94b}\x03\x02\x02\x02\u{949}\
	\u{947}\x03\x02\x02\x02\u{949}\u{94a}\x03\x02\x02\x02\u{94a}\u{94c}\x03\
	\x02\x02\x02\u{94b}\u{949}\x03\x02\x02\x02\u{94c}\u{950}\x05\u{c2}\x62\x02\
	\u{94d}\u{94f}\x07\x07\x02\x02\u{94e}\u{94d}\x03\x02\x02\x02\u{94f}\u{952}\
	\x03\x02\x02\x02\u{950}\u{94e}\x03\x02\x02\x02\u{950}\u{951}\x03\x02\x02\
	\x02\u{951}\u{953}\x03\x02\x02\x02\u{952}\u{950}\x03\x02\x02\x02\u{953}\
	\u{954}\x07\x0c\x02\x02\u{954}\u{c5}\x03\x02\x02\x02\u{955}\u{959}\x05\u{d0}\
	\x69\x02\u{956}\u{959}\x05\u{c8}\x65\x02\u{957}\u{959}\x05\u{ca}\x66\x02\
	\u{958}\u{955}\x03\x02\x02\x02\u{958}\u{956}\x03\x02\x02\x02\u{958}\u{957}\
	\x03\x02\x02\x02\u{959}\u{c7}\x03\x02\x02\x02\u{95a}\u{95e}\x07\x0d\x02\
	\x02\u{95b}\u{95d}\x07\x07\x02\x02\u{95c}\u{95b}\x03\x02\x02\x02\u{95d}\
	\u{960}\x03\x02\x02\x02\u{95e}\u{95c}\x03\x02\x02\x02\u{95e}\u{95f}\x03\
	\x02\x02\x02\u{95f}\u{961}\x03\x02\x02\x02\u{960}\u{95e}\x03\x02\x02\x02\
	\u{961}\u{972}\x05\u{9a}\x4e\x02\u{962}\u{964}\x07\x07\x02\x02\u{963}\u{962}\
	\x03\x02\x02\x02\u{964}\u{967}\x03\x02\x02\x02\u{965}\u{963}\x03\x02\x02\
	\x02\u{965}\u{966}\x03\x02\x02\x02\u{966}\u{968}\x03\x02\x02\x02\u{967}\
	\u{965}\x03\x02\x02\x02\u{968}\u{96c}\x07\x0a\x02\x02\u{969}\u{96b}\x07\
	\x07\x02\x02\u{96a}\u{969}\x03\x02\x02\x02\u{96b}\u{96e}\x03\x02\x02\x02\
	\u{96c}\u{96a}\x03\x02\x02\x02\u{96c}\u{96d}\x03\x02\x02\x02\u{96d}\u{96f}\
	\x03\x02\x02\x02\u{96e}\u{96c}\x03\x02\x02\x02\u{96f}\u{971}\x05\u{9a}\x4e\
	\x02\u{970}\u{965}\x03\x02\x02\x02\u{971}\u{974}\x03\x02\x02\x02\u{972}\
	\u{970}\x03\x02\x02\x02\u{972}\u{973}\x03\x02\x02\x02\u{973}\u{97c}\x03\
	\x02\x02\x02\u{974}\u{972}\x03\x02\x02\x02\u{975}\u{977}\x07\x07\x02\x02\
	\u{976}\u{975}\x03\x02\x02\x02\u{977}\u{97a}\x03\x02\x02\x02\u{978}\u{976}\
	\x03\x02\x02\x02\u{978}\u{979}\x03\x02\x02\x02\u{979}\u{97b}\x03\x02\x02\
	\x02\u{97a}\u{978}\x03\x02\x02\x02\u{97b}\u{97d}\x07\x0a\x02\x02\u{97c}\
	\u{978}\x03\x02\x02\x02\u{97c}\u{97d}\x03\x02\x02\x02\u{97d}\u{981}\x03\
	\x02\x02\x02\u{97e}\u{980}\x07\x07\x02\x02\u{97f}\u{97e}\x03\x02\x02\x02\
	\u{980}\u{983}\x03\x02\x02\x02\u{981}\u{97f}\x03\x02\x02\x02\u{981}\u{982}\
	\x03\x02\x02\x02\u{982}\u{984}\x03\x02\x02\x02\u{983}\u{981}\x03\x02\x02\
	\x02\u{984}\u{985}\x07\x0e\x02\x02\u{985}\u{c9}\x03\x02\x02\x02\u{986}\u{98a}\
	\x05\u{12a}\u{96}\x02\u{987}\u{989}\x07\x07\x02\x02\u{988}\u{987}\x03\x02\
	\x02\x02\u{989}\u{98c}\x03\x02\x02\x02\u{98a}\u{988}\x03\x02\x02\x02\u{98a}\
	\u{98b}\x03\x02\x02\x02\u{98b}\u{990}\x03\x02\x02\x02\u{98c}\u{98a}\x03\
	\x02\x02\x02\u{98d}\u{991}\x05\u{15a}\u{ae}\x02\u{98e}\u{991}\x05\u{d8}\
	\x6d\x02\u{98f}\u{991}\x07\x4c\x02\x02\u{990}\u{98d}\x03\x02\x02\x02\u{990}\
	\u{98e}\x03\x02\x02\x02\u{990}\u{98f}\x03\x02\x02\x02\u{991}\u{cb}\x03\x02\
	\x02\x02\u{992}\u{994}\x05\u{d0}\x69\x02\u{993}\u{992}\x03\x02\x02\x02\u{993}\
	\u{994}\x03\x02\x02\x02\u{994}\u{99a}\x03\x02\x02\x02\u{995}\u{997}\x05\
	\u{d2}\x6a\x02\u{996}\u{995}\x03\x02\x02\x02\u{996}\u{997}\x03\x02\x02\x02\
	\u{997}\u{998}\x03\x02\x02\x02\u{998}\u{99b}\x05\u{ce}\x68\x02\u{999}\u{99b}\
	\x05\u{d2}\x6a\x02\u{99a}\u{996}\x03\x02\x02\x02\u{99a}\u{999}\x03\x02\x02\
	\x02\u{99b}\u{cd}\x03\x02\x02\x02\u{99c}\u{99e}\x05\u{150}\u{a9}\x02\u{99d}\
	\u{99c}\x03\x02\x02\x02\u{99e}\u{9a1}\x03\x02\x02\x02\u{99f}\u{99d}\x03\
	\x02\x02\x02\u{99f}\u{9a0}\x03\x02\x02\x02\u{9a0}\u{9a3}\x03\x02\x02\x02\
	\u{9a1}\u{99f}\x03\x02\x02\x02\u{9a2}\u{9a4}\x05\u{86}\x44\x02\u{9a3}\u{9a2}\
	\x03\x02\x02\x02\u{9a3}\u{9a4}\x03\x02\x02\x02\u{9a4}\u{9a8}\x03\x02\x02\
	\x02\u{9a5}\u{9a7}\x07\x07\x02\x02\u{9a6}\u{9a5}\x03\x02\x02\x02\u{9a7}\
	\u{9aa}\x03\x02\x02\x02\u{9a8}\u{9a6}\x03\x02\x02\x02\u{9a8}\u{9a9}\x03\
	\x02\x02\x02\u{9a9}\u{9ab}\x03\x02\x02\x02\u{9aa}\u{9a8}\x03\x02\x02\x02\
	\u{9ab}\u{9ac}\x05\u{ec}\x77\x02\u{9ac}\u{cf}\x03\x02\x02\x02\u{9ad}\u{9b1}\
	\x07\x31\x02\x02\u{9ae}\u{9b0}\x07\x07\x02\x02\u{9af}\u{9ae}\x03\x02\x02\
	\x02\u{9b0}\u{9b3}\x03\x02\x02\x02\u{9b1}\u{9af}\x03\x02\x02\x02\u{9b1}\
	\u{9b2}\x03\x02\x02\x02\u{9b2}\u{9b4}\x03\x02\x02\x02\u{9b3}\u{9b1}\x03\
	\x02\x02\x02\u{9b4}\u{9c5}\x05\x70\x39\x02\u{9b5}\u{9b7}\x07\x07\x02\x02\
	\u{9b6}\u{9b5}\x03\x02\x02\x02\u{9b7}\u{9ba}\x03\x02\x02\x02\u{9b8}\u{9b6}\
	\x03\x02\x02\x02\u{9b8}\u{9b9}\x03\x02\x02\x02\u{9b9}\u{9bb}\x03\x02\x02\
	\x02\u{9ba}\u{9b8}\x03\x02\x02\x02\u{9bb}\u{9bf}\x07\x0a\x02\x02\u{9bc}\
	\u{9be}\x07\x07\x02\x02\u{9bd}\u{9bc}\x03\x02\x02\x02\u{9be}\u{9c1}\x03\
	\x02\x02\x02\u{9bf}\u{9bd}\x03\x02\x02\x02\u{9bf}\u{9c0}\x03\x02\x02\x02\
	\u{9c0}\u{9c2}\x03\x02\x02\x02\u{9c1}\u{9bf}\x03\x02\x02\x02\u{9c2}\u{9c4}\
	\x05\x70\x39\x02\u{9c3}\u{9b8}\x03\x02\x02\x02\u{9c4}\u{9c7}\x03\x02\x02\
	\x02\u{9c5}\u{9c3}\x03\x02\x02\x02\u{9c5}\u{9c6}\x03\x02\x02\x02\u{9c6}\
	\u{9cf}\x03\x02\x02\x02\u{9c7}\u{9c5}\x03\x02\x02\x02\u{9c8}\u{9ca}\x07\
	\x07\x02\x02\u{9c9}\u{9c8}\x03\x02\x02\x02\u{9ca}\u{9cd}\x03\x02\x02\x02\
	\u{9cb}\u{9c9}\x03\x02\x02\x02\u{9cb}\u{9cc}\x03\x02\x02\x02\u{9cc}\u{9ce}\
	\x03\x02\x02\x02\u{9cd}\u{9cb}\x03\x02\x02\x02\u{9ce}\u{9d0}\x07\x0a\x02\
	\x02\u{9cf}\u{9cb}\x03\x02\x02\x02\u{9cf}\u{9d0}\x03\x02\x02\x02\u{9d0}\
	\u{9d4}\x03\x02\x02\x02\u{9d1}\u{9d3}\x07\x07\x02\x02\u{9d2}\u{9d1}\x03\
	\x02\x02\x02\u{9d3}\u{9d6}\x03\x02\x02\x02\u{9d4}\u{9d2}\x03\x02\x02\x02\
	\u{9d4}\u{9d5}\x03\x02\x02\x02\u{9d5}\u{9d7}\x03\x02\x02\x02\u{9d6}\u{9d4}\
	\x03\x02\x02\x02\u{9d7}\u{9d8}\x07\x32\x02\x02\u{9d8}\u{d1}\x03\x02\x02\
	\x02\u{9d9}\u{9dd}\x07\x0b\x02\x02\u{9da}\u{9dc}\x07\x07\x02\x02\u{9db}\
	\u{9da}\x03\x02\x02\x02\u{9dc}\u{9df}\x03\x02\x02\x02\u{9dd}\u{9db}\x03\
	\x02\x02\x02\u{9dd}\u{9de}\x03\x02\x02\x02\u{9de}\u{a03}\x03\x02\x02\x02\
	\u{9df}\u{9dd}\x03\x02\x02\x02\u{9e0}\u{9f1}\x05\u{d4}\x6b\x02\u{9e1}\u{9e3}\
	\x07\x07\x02\x02\u{9e2}\u{9e1}\x03\x02\x02\x02\u{9e3}\u{9e6}\x03\x02\x02\
	\x02\u{9e4}\u{9e2}\x03\x02\x02\x02\u{9e4}\u{9e5}\x03\x02\x02\x02\u{9e5}\
	\u{9e7}\x03\x02\x02\x02\u{9e6}\u{9e4}\x03\x02\x02\x02\u{9e7}\u{9eb}\x07\
	\x0a\x02\x02\u{9e8}\u{9ea}\x07\x07\x02\x02\u{9e9}\u{9e8}\x03\x02\x02\x02\
	\u{9ea}\u{9ed}\x03\x02\x02\x02\u{9eb}\u{9e9}\x03\x02\x02\x02\u{9eb}\u{9ec}\
	\x03\x02\x02\x02\u{9ec}\u{9ee}\x03\x02\x02\x02\u{9ed}\u{9eb}\x03\x02\x02\
	\x02\u{9ee}\u{9f0}\x05\u{d4}\x6b\x02\u{9ef}\u{9e4}\x03\x02\x02\x02\u{9f0}\
	\u{9f3}\x03\x02\x02\x02\u{9f1}\u{9ef}\x03\x02\x02\x02\u{9f1}\u{9f2}\x03\
	\x02\x02\x02\u{9f2}\u{9fb}\x03\x02\x02\x02\u{9f3}\u{9f1}\x03\x02\x02\x02\
	\u{9f4}\u{9f6}\x07\x07\x02\x02\u{9f5}\u{9f4}\x03\x02\x02\x02\u{9f6}\u{9f9}\
	\x03\x02\x02\x02\u{9f7}\u{9f5}\x03\x02\x02\x02\u{9f7}\u{9f8}\x03\x02\x02\
	\x02\u{9f8}\u{9fa}\x03\x02\x02\x02\u{9f9}\u{9f7}\x03\x02\x02\x02\u{9fa}\
	\u{9fc}\x07\x0a\x02\x02\u{9fb}\u{9f7}\x03\x02\x02\x02\u{9fb}\u{9fc}\x03\
	\x02\x02\x02\u{9fc}\u{a00}\x03\x02\x02\x02\u{9fd}\u{9ff}\x07\x07\x02\x02\
	\u{9fe}\u{9fd}\x03\x02\x02\x02\u{9ff}\u{a02}\x03\x02\x02\x02\u{a00}\u{9fe}\
	\x03\x02\x02\x02\u{a00}\u{a01}\x03\x02\x02\x02\u{a01}\u{a04}\x03\x02\x02\
	\x02\u{a02}\u{a00}\x03\x02\x02\x02\u{a03}\u{9e0}\x03\x02\x02\x02\u{a03}\
	\u{a04}\x03\x02\x02\x02\u{a04}\u{a05}\x03\x02\x02\x02\u{a05}\u{a06}\x07\
	\x0c\x02\x02\u{a06}\u{d3}\x03\x02\x02\x02\u{a07}\u{a09}\x05\u{150}\u{a9}\
	\x02\u{a08}\u{a07}\x03\x02\x02\x02\u{a08}\u{a09}\x03\x02\x02\x02\u{a09}\
	\u{a0d}\x03\x02\x02\x02\u{a0a}\u{a0c}\x07\x07\x02\x02\u{a0b}\u{a0a}\x03\
	\x02\x02\x02\u{a0c}\u{a0f}\x03\x02\x02\x02\u{a0d}\u{a0b}\x03\x02\x02\x02\
	\u{a0d}\u{a0e}\x03\x02\x02\x02\u{a0e}\u{a1e}\x03\x02\x02\x02\u{a0f}\u{a0d}\
	\x03\x02\x02\x02\u{a10}\u{a14}\x05\u{15a}\u{ae}\x02\u{a11}\u{a13}\x07\x07\
	\x02\x02\u{a12}\u{a11}\x03\x02\x02\x02\u{a13}\u{a16}\x03\x02\x02\x02\u{a14}\
	\u{a12}\x03\x02\x02\x02\u{a14}\u{a15}\x03\x02\x02\x02\u{a15}\u{a17}\x03\
	\x02\x02\x02\u{a16}\u{a14}\x03\x02\x02\x02\u{a17}\u{a1b}\x07\x1e\x02\x02\
	\u{a18}\u{a1a}\x07\x07\x02\x02\u{a19}\u{a18}\x03\x02\x02\x02\u{a1a}\u{a1d}\
	\x03\x02\x02\x02\u{a1b}\u{a19}\x03\x02\x02\x02\u{a1b}\u{a1c}\x03\x02\x02\
	\x02\u{a1c}\u{a1f}\x03\x02\x02\x02\u{a1d}\u{a1b}\x03\x02\x02\x02\u{a1e}\
	\u{a10}\x03\x02\x02\x02\u{a1e}\u{a1f}\x03\x02\x02\x02\u{a1f}\u{a21}\x03\
	\x02\x02\x02\u{a20}\u{a22}\x07\x11\x02\x02\u{a21}\u{a20}\x03\x02\x02\x02\
	\u{a21}\u{a22}\x03\x02\x02\x02\u{a22}\u{a26}\x03\x02\x02\x02\u{a23}\u{a25}\
	\x07\x07\x02\x02\u{a24}\u{a23}\x03\x02\x02\x02\u{a25}\u{a28}\x03\x02\x02\
	\x02\u{a26}\u{a24}\x03\x02\x02\x02\u{a26}\u{a27}\x03\x02\x02\x02\u{a27}\
	\u{a29}\x03\x02\x02\x02\u{a28}\u{a26}\x03\x02\x02\x02\u{a29}\u{a2a}\x05\
	\u{9a}\x4e\x02\u{a2a}\u{d5}\x03\x02\x02\x02\u{a2b}\u{a3a}\x05\u{d8}\x6d\
	\x02\u{a2c}\u{a3a}\x05\u{15a}\u{ae}\x02\u{a2d}\u{a3a}\x05\u{dc}\x6f\x02\
	\u{a2e}\u{a3a}\x05\u{de}\x70\x02\u{a2f}\u{a3a}\x05\u{112}\u{8a}\x02\u{a30}\
	\u{a3a}\x05\u{f4}\x7b\x02\u{a31}\u{a3a}\x05\u{f6}\x7c\x02\u{a32}\u{a3a}\
	\x05\u{da}\x6e\x02\u{a33}\u{a3a}\x05\u{f8}\x7d\x02\u{a34}\u{a3a}\x05\u{fa}\
	\x7e\x02\u{a35}\u{a3a}\x05\u{fc}\x7f\x02\u{a36}\u{a3a}\x05\u{100}\u{81}\
	\x02\u{a37}\u{a3a}\x05\u{10a}\u{86}\x02\u{a38}\u{a3a}\x05\u{110}\u{89}\x02\
	\u{a39}\u{a2b}\x03\x02\x02\x02\u{a39}\u{a2c}\x03\x02\x02\x02\u{a39}\u{a2d}\
	\x03\x02\x02\x02\u{a39}\u{a2e}\x03\x02\x02\x02\u{a39}\u{a2f}\x03\x02\x02\
	\x02\u{a39}\u{a30}\x03\x02\x02\x02\u{a39}\u{a31}\x03\x02\x02\x02\u{a39}\
	\u{a32}\x03\x02\x02\x02\u{a39}\u{a33}\x03\x02\x02\x02\u{a39}\u{a34}\x03\
	\x02\x02\x02\u{a39}\u{a35}\x03\x02\x02\x02\u{a39}\u{a36}\x03\x02\x02\x02\
	\u{a39}\u{a37}\x03\x02\x02\x02\u{a39}\u{a38}\x03\x02\x02\x02\u{a3a}\u{d7}\
	\x03\x02\x02\x02\u{a3b}\u{a3f}\x07\x0b\x02\x02\u{a3c}\u{a3e}\x07\x07\x02\
	\x02\u{a3d}\u{a3c}\x03\x02\x02\x02\u{a3e}\u{a41}\x03\x02\x02\x02\u{a3f}\
	\u{a3d}\x03\x02\x02\x02\u{a3f}\u{a40}\x03\x02\x02\x02\u{a40}\u{a42}\x03\
	\x02\x02\x02\u{a41}\u{a3f}\x03\x02\x02\x02\u{a42}\u{a46}\x05\u{9a}\x4e\x02\
	\u{a43}\u{a45}\x07\x07\x02\x02\u{a44}\u{a43}\x03\x02\x02\x02\u{a45}\u{a48}\
	\x03\x02\x02\x02\u{a46}\u{a44}\x03\x02\x02\x02\u{a46}\u{a47}\x03\x02\x02\
	\x02\u{a47}\u{a49}\x03\x02\x02\x02\u{a48}\u{a46}\x03\x02\x02\x02\u{a49}\
	\u{a4a}\x07\x0c\x02\x02\u{a4a}\u{d9}\x03\x02\x02\x02\u{a4b}\u{a4f}\x07\x0d\
	\x02\x02\u{a4c}\u{a4e}\x07\x07\x02\x02\u{a4d}\u{a4c}\x03\x02\x02\x02\u{a4e}\
	\u{a51}\x03\x02\x02\x02\u{a4f}\u{a4d}\x03\x02\x02\x02\u{a4f}\u{a50}\x03\
	\x02\x02\x02\u{a50}\u{a75}\x03\x02\x02\x02\u{a51}\u{a4f}\x03\x02\x02\x02\
	\u{a52}\u{a63}\x05\u{9a}\x4e\x02\u{a53}\u{a55}\x07\x07\x02\x02\u{a54}\u{a53}\
	\x03\x02\x02\x02\u{a55}\u{a58}\x03\x02\x02\x02\u{a56}\u{a54}\x03\x02\x02\
	\x02\u{a56}\u{a57}\x03\x02\x02\x02\u{a57}\u{a59}\x03\x02\x02\x02\u{a58}\
	\u{a56}\x03\x02\x02\x02\u{a59}\u{a5d}\x07\x0a\x02\x02\u{a5a}\u{a5c}\x07\
	\x07\x02\x02\u{a5b}\u{a5a}\x03\x02\x02\x02\u{a5c}\u{a5f}\x03\x02\x02\x02\
	\u{a5d}\u{a5b}\x03\x02\x02\x02\u{a5d}\u{a5e}\x03\x02\x02\x02\u{a5e}\u{a60}\
	\x03\x02\x02\x02\u{a5f}\u{a5d}\x03\x02\x02\x02\u{a60}\u{a62}\x05\u{9a}\x4e\
	\x02\u{a61}\u{a56}\x03\x02\x02\x02\u{a62}\u{a65}\x03\x02\x02\x02\u{a63}\
	\u{a61}\x03\x02\x02\x02\u{a63}\u{a64}\x03\x02\x02\x02\u{a64}\u{a6d}\x03\
	\x02\x02\x02\u{a65}\u{a63}\x03\x02\x02\x02\u{a66}\u{a68}\x07\x07\x02\x02\
	\u{a67}\u{a66}\x03\x02\x02\x02\u{a68}\u{a6b}\x03\x02\x02\x02\u{a69}\u{a67}\
	\x03\x02\x02\x02\u{a69}\u{a6a}\x03\x02\x02\x02\u{a6a}\u{a6c}\x03\x02\x02\
	\x02\u{a6b}\u{a69}\x03\x02\x02\x02\u{a6c}\u{a6e}\x07\x0a\x02\x02\u{a6d}\
	\u{a69}\x03\x02\x02\x02\u{a6d}\u{a6e}\x03\x02\x02\x02\u{a6e}\u{a72}\x03\
	\x02\x02\x02\u{a6f}\u{a71}\x07\x07\x02\x02\u{a70}\u{a6f}\x03\x02\x02\x02\
	\u{a71}\u{a74}\x03\x02\x02\x02\u{a72}\u{a70}\x03\x02\x02\x02\u{a72}\u{a73}\
	\x03\x02\x02\x02\u{a73}\u{a76}\x03\x02\x02\x02\u{a74}\u{a72}\x03\x02\x02\
	\x02\u{a75}\u{a52}\x03\x02\x02\x02\u{a75}\u{a76}\x03\x02\x02\x02\u{a76}\
	\u{a77}\x03\x02\x02\x02\u{a77}\u{a78}\x07\x0e\x02\x02\u{a78}\u{db}\x03\x02\
	\x02\x02\u{a79}\u{a7a}\x09\x09\x02\x02\u{a7a}\u{dd}\x03\x02\x02\x02\u{a7b}\
	\u{a7e}\x05\u{e0}\x71\x02\u{a7c}\u{a7e}\x05\u{e2}\x72\x02\u{a7d}\u{a7b}\
	\x03\x02\x02\x02\u{a7d}\u{a7c}\x03\x02\x02\x02\u{a7e}\u{df}\x03\x02\x02\
	\x02\u{a7f}\u{a84}\x07\u{99}\x02\x02\u{a80}\u{a83}\x05\u{e4}\x73\x02\u{a81}\
	\u{a83}\x05\u{e6}\x74\x02\u{a82}\u{a80}\x03\x02\x02\x02\u{a82}\u{a81}\x03\
	\x02\x02\x02\u{a83}\u{a86}\x03\x02\x02\x02\u{a84}\u{a82}\x03\x02\x02\x02\
	\u{a84}\u{a85}\x03\x02\x02\x02\u{a85}\u{a87}\x03\x02\x02\x02\u{a86}\u{a84}\
	\x03\x02\x02\x02\u{a87}\u{a88}\x07\u{a2}\x02\x02\u{a88}\u{e1}\x03\x02\x02\
	\x02\u{a89}\u{a8f}\x07\u{9a}\x02\x02\u{a8a}\u{a8e}\x05\u{e8}\x75\x02\u{a8b}\
	\u{a8e}\x05\u{ea}\x76\x02\u{a8c}\u{a8e}\x07\u{a8}\x02\x02\u{a8d}\u{a8a}\
	\x03\x02\x02\x02\u{a8d}\u{a8b}\x03\x02\x02\x02\u{a8d}\u{a8c}\x03\x02\x02\
	\x02\u{a8e}\u{a91}\x03\x02\x02\x02\u{a8f}\u{a8d}\x03\x02\x02\x02\u{a8f}\
	\u{a90}\x03\x02\x02\x02\u{a90}\u{a92}\x03\x02\x02\x02\u{a91}\u{a8f}\x03\
	\x02\x02\x02\u{a92}\u{a93}\x07\u{a7}\x02\x02\u{a93}\u{e3}\x03\x02\x02\x02\
	\u{a94}\u{a95}\x09\x0a\x02\x02\u{a95}\u{e5}\x03\x02\x02\x02\u{a96}\u{a9a}\
	\x07\u{a6}\x02\x02\u{a97}\u{a99}\x07\x07\x02\x02\u{a98}\u{a97}\x03\x02\x02\
	\x02\u{a99}\u{a9c}\x03\x02\x02\x02\u{a9a}\u{a98}\x03\x02\x02\x02\u{a9a}\
	\u{a9b}\x03\x02\x02\x02\u{a9b}\u{a9d}\x03\x02\x02\x02\u{a9c}\u{a9a}\x03\
	\x02\x02\x02\u{a9d}\u{aa1}\x05\u{9a}\x4e\x02\u{a9e}\u{aa0}\x07\x07\x02\x02\
	\u{a9f}\u{a9e}\x03\x02\x02\x02\u{aa0}\u{aa3}\x03\x02\x02\x02\u{aa1}\u{a9f}\
	\x03\x02\x02\x02\u{aa1}\u{aa2}\x03\x02\x02\x02\u{aa2}\u{aa4}\x03\x02\x02\
	\x02\u{aa3}\u{aa1}\x03\x02\x02\x02\u{aa4}\u{aa5}\x07\x10\x02\x02\u{aa5}\
	\u{e7}\x03\x02\x02\x02\u{aa6}\u{aa7}\x09\x0b\x02\x02\u{aa7}\u{e9}\x03\x02\
	\x02\x02\u{aa8}\u{aac}\x07\u{ab}\x02\x02\u{aa9}\u{aab}\x07\x07\x02\x02\u{aaa}\
	\u{aa9}\x03\x02\x02\x02\u{aab}\u{aae}\x03\x02\x02\x02\u{aac}\u{aaa}\x03\
	\x02\x02\x02\u{aac}\u{aad}\x03\x02\x02\x02\u{aad}\u{aaf}\x03\x02\x02\x02\
	\u{aae}\u{aac}\x03\x02\x02\x02\u{aaf}\u{ab3}\x05\u{9a}\x4e\x02\u{ab0}\u{ab2}\
	\x07\x07\x02\x02\u{ab1}\u{ab0}\x03\x02\x02\x02\u{ab2}\u{ab5}\x03\x02\x02\
	\x02\u{ab3}\u{ab1}\x03\x02\x02\x02\u{ab3}\u{ab4}\x03\x02\x02\x02\u{ab4}\
	\u{ab6}\x03\x02\x02\x02\u{ab5}\u{ab3}\x03\x02\x02\x02\u{ab6}\u{ab7}\x07\
	\x10\x02\x02\u{ab7}\u{eb}\x03\x02\x02\x02\u{ab8}\u{abc}\x07\x0f\x02\x02\
	\u{ab9}\u{abb}\x07\x07\x02\x02\u{aba}\u{ab9}\x03\x02\x02\x02\u{abb}\u{abe}\
	\x03\x02\x02\x02\u{abc}\u{aba}\x03\x02\x02\x02\u{abc}\u{abd}\x03\x02\x02\
	\x02\u{abd}\u{acf}\x03\x02\x02\x02\u{abe}\u{abc}\x03\x02\x02\x02\u{abf}\
	\u{ac1}\x05\u{ee}\x78\x02\u{ac0}\u{abf}\x03\x02\x02\x02\u{ac0}\u{ac1}\x03\
	\x02\x02\x02\u{ac1}\u{ac5}\x03\x02\x02\x02\u{ac2}\u{ac4}\x07\x07\x02\x02\
	\u{ac3}\u{ac2}\x03\x02\x02\x02\u{ac4}\u{ac7}\x03\x02\x02\x02\u{ac5}\u{ac3}\
	\x03\x02\x02\x02\u{ac5}\u{ac6}\x03\x02\x02\x02\u{ac6}\u{ac8}\x03\x02\x02\
	\x02\u{ac7}\u{ac5}\x03\x02\x02\x02\u{ac8}\u{acc}\x07\x24\x02\x02\u{ac9}\
	\u{acb}\x07\x07\x02\x02\u{aca}\u{ac9}\x03\x02\x02\x02\u{acb}\u{ace}\x03\
	\x02\x02\x02\u{acc}\u{aca}\x03\x02\x02\x02\u{acc}\u{acd}\x03\x02\x02\x02\
	\u{acd}\u{ad0}\x03\x02\x02\x02\u{ace}\u{acc}\x03\x02\x02\x02\u{acf}\u{ac0}\
	\x03\x02\x02\x02\u{acf}\u{ad0}\x03\x02\x02\x02\u{ad0}\u{ad1}\x03\x02\x02\
	\x02\u{ad1}\u{ad5}\x05\u{82}\x42\x02\u{ad2}\u{ad4}\x07\x07\x02\x02\u{ad3}\
	\u{ad2}\x03\x02\x02\x02\u{ad4}\u{ad7}\x03\x02\x02\x02\u{ad5}\u{ad3}\x03\
	\x02\x02\x02\u{ad5}\u{ad6}\x03\x02\x02\x02\u{ad6}\u{ad8}\x03\x02\x02\x02\
	\u{ad7}\u{ad5}\x03\x02\x02\x02\u{ad8}\u{ad9}\x07\x10\x02\x02\u{ad9}\u{ed}\
	\x03\x02\x02\x02\u{ada}\u{aeb}\x05\u{f0}\x79\x02\u{adb}\u{add}\x07\x07\x02\
	\x02\u{adc}\u{adb}\x03\x02\x02\x02\u{add}\u{ae0}\x03\x02\x02\x02\u{ade}\
	\u{adc}\x03\x02\x02\x02\u{ade}\u{adf}\x03\x02\x02\x02\u{adf}\u{ae1}\x03\
	\x02\x02\x02\u{ae0}\u{ade}\x03\x02\x02\x02\u{ae1}\u{ae5}\x07\x0a\x02\x02\
	\u{ae2}\u{ae4}\x07\x07\x02\x02\u{ae3}\u{ae2}\x03\x02\x02\x02\u{ae4}\u{ae7}\
	\x03\x02\x02\x02\u{ae5}\u{ae3}\x03\x02\x02\x02\u{ae5}\u{ae6}\x03\x02\x02\
	\x02\u{ae6}\u{ae8}\x03\x02\x02\x02\u{ae7}\u{ae5}\x03\x02\x02\x02\u{ae8}\
	\u{aea}\x05\u{f0}\x79\x02\u{ae9}\u{ade}\x03\x02\x02\x02\u{aea}\u{aed}\x03\
	\x02\x02\x02\u{aeb}\u{ae9}\x03\x02\x02\x02\u{aeb}\u{aec}\x03\x02\x02\x02\
	\u{aec}\u{af5}\x03\x02\x02\x02\u{aed}\u{aeb}\x03\x02\x02\x02\u{aee}\u{af0}\
	\x07\x07\x02\x02\u{aef}\u{aee}\x03\x02\x02\x02\u{af0}\u{af3}\x03\x02\x02\
	\x02\u{af1}\u{aef}\x03\x02\x02\x02\u{af1}\u{af2}\x03\x02\x02\x02\u{af2}\
	\u{af4}\x03\x02\x02\x02\u{af3}\u{af1}\x03\x02\x02\x02\u{af4}\u{af6}\x07\
	\x0a\x02\x02\u{af5}\u{af1}\x03\x02\x02\x02\u{af5}\u{af6}\x03\x02\x02\x02\
	\u{af6}\u{ef}\x03\x02\x02\x02\u{af7}\u{b0a}\x05\x44\x23\x02\u{af8}\u{b07}\
	\x05\x46\x24\x02\u{af9}\u{afb}\x07\x07\x02\x02\u{afa}\u{af9}\x03\x02\x02\
	\x02\u{afb}\u{afe}\x03\x02\x02\x02\u{afc}\u{afa}\x03\x02\x02\x02\u{afc}\
	\u{afd}\x03\x02\x02\x02\u{afd}\u{aff}\x03\x02\x02\x02\u{afe}\u{afc}\x03\
	\x02\x02\x02\u{aff}\u{b03}\x07\x1c\x02\x02\u{b00}\u{b02}\x07\x07\x02\x02\
	\u{b01}\u{b00}\x03\x02\x02\x02\u{b02}\u{b05}\x03\x02\x02\x02\u{b03}\u{b01}\
	\x03\x02\x02\x02\u{b03}\u{b04}\x03\x02\x02\x02\u{b04}\u{b06}\x03\x02\x02\
	\x02\u{b05}\u{b03}\x03\x02\x02\x02\u{b06}\u{b08}\x05\x64\x33\x02\u{b07}\
	\u{afc}\x03\x02\x02\x02\u{b07}\u{b08}\x03\x02\x02\x02\u{b08}\u{b0a}\x03\
	\x02\x02\x02\u{b09}\u{af7}\x03\x02\x02\x02\u{b09}\u{af8}\x03\x02\x02\x02\
	\u{b0a}\u{f1}\x03\x02\x02\x02\u{b0b}\u{b0d}\x07\x7e\x02\x02\u{b0c}\u{b0b}\
	\x03\x02\x02\x02\u{b0c}\u{b0d}\x03\x02\x02\x02\u{b0d}\u{b11}\x03\x02\x02\
	\x02\u{b0e}\u{b10}\x07\x07\x02\x02\u{b0f}\u{b0e}\x03\x02\x02\x02\u{b10}\
	\u{b13}\x03\x02\x02\x02\u{b11}\u{b0f}\x03\x02\x02\x02\u{b11}\u{b12}\x03\
	\x02\x02\x02\u{b12}\u{b14}\x03\x02\x02\x02\u{b13}\u{b11}\x03\x02\x02\x02\
	\u{b14}\u{b24}\x07\x4e\x02\x02\u{b15}\u{b17}\x07\x07\x02\x02\u{b16}\u{b15}\
	\x03\x02\x02\x02\u{b17}\u{b1a}\x03\x02\x02\x02\u{b18}\u{b16}\x03\x02\x02\
	\x02\u{b18}\u{b19}\x03\x02\x02\x02\u{b19}\u{b1b}\x03\x02\x02\x02\u{b1a}\
	\u{b18}\x03\x02\x02\x02\u{b1b}\u{b1f}\x05\x64\x33\x02\u{b1c}\u{b1e}\x07\
	\x07\x02\x02\u{b1d}\u{b1c}\x03\x02\x02\x02\u{b1e}\u{b21}\x03\x02\x02\x02\
	\u{b1f}\u{b1d}\x03\x02\x02\x02\u{b1f}\u{b20}\x03\x02\x02\x02\u{b20}\u{b22}\
	\x03\x02\x02\x02\u{b21}\u{b1f}\x03\x02\x02\x02\u{b22}\u{b23}\x07\x09\x02\
	\x02\u{b23}\u{b25}\x03\x02\x02\x02\u{b24}\u{b18}\x03\x02\x02\x02\u{b24}\
	\u{b25}\x03\x02\x02\x02\u{b25}\u{b29}\x03\x02\x02\x02\u{b26}\u{b28}\x07\
	\x07\x02\x02\u{b27}\u{b26}\x03\x02\x02\x02\u{b28}\u{b2b}\x03\x02\x02\x02\
	\u{b29}\u{b27}\x03\x02\x02\x02\u{b29}\u{b2a}\x03\x02\x02\x02\u{b2a}\u{b2c}\
	\x03\x02\x02\x02\u{b2b}\u{b29}\x03\x02\x02\x02\u{b2c}\u{b3b}\x05\x50\x29\
	\x02\u{b2d}\u{b2f}\x07\x07\x02\x02\u{b2e}\u{b2d}\x03\x02\x02\x02\u{b2f}\
	\u{b32}\x03\x02\x02\x02\u{b30}\u{b2e}\x03\x02\x02\x02\u{b30}\u{b31}\x03\
	\x02\x02\x02\u{b31}\u{b33}\x03\x02\x02\x02\u{b32}\u{b30}\x03\x02\x02\x02\
	\u{b33}\u{b37}\x07\x1c\x02\x02\u{b34}\u{b36}\x07\x07\x02\x02\u{b35}\u{b34}\
	\x03\x02\x02\x02\u{b36}\u{b39}\x03\x02\x02\x02\u{b37}\u{b35}\x03\x02\x02\
	\x02\u{b37}\u{b38}\x03\x02\x02\x02\u{b38}\u{b3a}\x03\x02\x02\x02\u{b39}\
	\u{b37}\x03\x02\x02\x02\u{b3a}\u{b3c}\x05\x64\x33\x02\u{b3b}\u{b30}\x03\
	\x02\x02\x02\u{b3b}\u{b3c}\x03\x02\x02\x02\u{b3c}\u{b44}\x03\x02\x02\x02\
	\u{b3d}\u{b3f}\x07\x07\x02\x02\u{b3e}\u{b3d}\x03\x02\x02\x02\u{b3f}\u{b42}\
	\x03\x02\x02\x02\u{b40}\u{b3e}\x03\x02\x02\x02\u{b40}\u{b41}\x03\x02\x02\
	\x02\u{b41}\u{b43}\x03\x02\x02\x02\u{b42}\u{b40}\x03\x02\x02\x02\u{b43}\
	\u{b45}\x05\x30\x19\x02\u{b44}\u{b40}\x03\x02\x02\x02\u{b44}\u{b45}\x03\
	\x02\x02\x02\u{b45}\u{b4d}\x03\x02\x02\x02\u{b46}\u{b48}\x07\x07\x02\x02\
	\u{b47}\u{b46}\x03\x02\x02\x02\u{b48}\u{b4b}\x03\x02\x02\x02\u{b49}\u{b47}\
	\x03\x02\x02\x02\u{b49}\u{b4a}\x03\x02\x02\x02\u{b4a}\u{b4c}\x03\x02\x02\
	\x02\u{b4b}\u{b49}\x03\x02\x02\x02\u{b4c}\u{b4e}\x05\x42\x22\x02\u{b4d}\
	\u{b49}\x03\x02\x02\x02\u{b4d}\u{b4e}\x03\x02\x02\x02\u{b4e}\u{f3}\x03\x02\
	\x02\x02\u{b4f}\u{b52}\x05\u{ec}\x77\x02\u{b50}\u{b52}\x05\u{f2}\x7a\x02\
	\u{b51}\u{b4f}\x03\x02\x02\x02\u{b51}\u{b50}\x03\x02\x02\x02\u{b52}\u{f5}\
	\x03\x02\x02\x02\u{b53}\u{b55}\x07\x76\x02\x02\u{b54}\u{b53}\x03\x02\x02\
	\x02\u{b54}\u{b55}\x03\x02\x02\x02\u{b55}\u{b59}\x03\x02\x02\x02\u{b56}\
	\u{b58}\x07\x07\x02\x02\u{b57}\u{b56}\x03\x02\x02\x02\u{b58}\u{b5b}\x03\
	\x02\x02\x02\u{b59}\u{b57}\x03\x02\x02\x02\u{b59}\u{b5a}\x03\x02\x02\x02\
	\u{b5a}\u{b5c}\x03\x02\x02\x02\u{b5b}\u{b59}\x03\x02\x02\x02\u{b5c}\u{b71}\
	\x07\x4f\x02\x02\u{b5d}\u{b5f}\x07\x07\x02\x02\u{b5e}\u{b5d}\x03\x02\x02\
	\x02\u{b5f}\u{b62}\x03\x02\x02\x02\u{b60}\u{b5e}\x03\x02\x02\x02\u{b60}\
	\u{b61}\x03\x02\x02\x02\u{b61}\u{b63}\x03\x02\x02\x02\u{b62}\u{b60}\x03\
	\x02\x02\x02\u{b63}\u{b67}\x07\x1c\x02\x02\u{b64}\u{b66}\x07\x07\x02\x02\
	\u{b65}\u{b64}\x03\x02\x02\x02\u{b66}\u{b69}\x03\x02\x02\x02\u{b67}\u{b65}\
	\x03\x02\x02\x02\u{b67}\u{b68}\x03\x02\x02\x02\u{b68}\u{b6a}\x03\x02\x02\
	\x02\u{b69}\u{b67}\x03\x02\x02\x02\u{b6a}\u{b6e}\x05\x22\x12\x02\u{b6b}\
	\u{b6d}\x07\x07\x02\x02\u{b6c}\u{b6b}\x03\x02\x02\x02\u{b6d}\u{b70}\x03\
	\x02\x02\x02\u{b6e}\u{b6c}\x03\x02\x02\x02\u{b6e}\u{b6f}\x03\x02\x02\x02\
	\u{b6f}\u{b72}\x03\x02\x02\x02\u{b70}\u{b6e}\x03\x02\x02\x02\u{b71}\u{b60}\
	\x03\x02\x02\x02\u{b71}\u{b72}\x03\x02\x02\x02\u{b72}\u{b7a}\x03\x02\x02\
	\x02\u{b73}\u{b75}\x07\x07\x02\x02\u{b74}\u{b73}\x03\x02\x02\x02\u{b75}\
	\u{b78}\x03\x02\x02\x02\u{b76}\u{b74}\x03\x02\x02\x02\u{b76}\u{b77}\x03\
	\x02\x02\x02\u{b77}\u{b79}\x03\x02\x02\x02\u{b78}\u{b76}\x03\x02\x02\x02\
	\u{b79}\u{b7b}\x05\x1c\x0f\x02\u{b7a}\u{b76}\x03\x02\x02\x02\u{b7a}\u{b7b}\
	\x03\x02\x02\x02\u{b7b}\u{f7}\x03\x02\x02\x02\u{b7c}\u{b7d}\x09\x0c\x02\
	\x02\u{b7d}\u{f9}\x03\x02\x02\x02\u{b7e}\u{b8f}\x07\x58\x02\x02\u{b7f}\u{b83}\
	\x07\x31\x02\x02\u{b80}\u{b82}\x07\x07\x02\x02\u{b81}\u{b80}\x03\x02\x02\
	\x02\u{b82}\u{b85}\x03\x02\x02\x02\u{b83}\u{b81}\x03\x02\x02\x02\u{b83}\
	\u{b84}\x03\x02\x02\x02\u{b84}\u{b86}\x03\x02\x02\x02\u{b85}\u{b83}\x03\
	\x02\x02\x02\u{b86}\u{b8a}\x05\x64\x33\x02\u{b87}\u{b89}\x07\x07\x02\x02\
	\u{b88}\u{b87}\x03\x02\x02\x02\u{b89}\u{b8c}\x03\x02\x02\x02\u{b8a}\u{b88}\
	\x03\x02\x02\x02\u{b8a}\u{b8b}\x03\x02\x02\x02\u{b8b}\u{b8d}\x03\x02\x02\
	\x02\u{b8c}\u{b8a}\x03\x02\x02\x02\u{b8d}\u{b8e}\x07\x32\x02\x02\u{b8e}\
	\u{b90}\x03\x02\x02\x02\u{b8f}\u{b7f}\x03\x02\x02\x02\u{b8f}\u{b90}\x03\
	\x02\x02\x02\u{b90}\u{b93}\x03\x02\x02\x02\u{b91}\u{b92}\x07\x2b\x02\x02\
	\u{b92}\u{b94}\x05\u{15a}\u{ae}\x02\u{b93}\u{b91}\x03\x02\x02\x02\u{b93}\
	\u{b94}\x03\x02\x02\x02\u{b94}\u{b97}\x03\x02\x02\x02\u{b95}\u{b97}\x07\
	\x40\x02\x02\u{b96}\u{b7e}\x03\x02\x02\x02\u{b96}\u{b95}\x03\x02\x02\x02\
	\u{b97}\u{fb}\x03\x02\x02\x02\u{b98}\u{b9c}\x07\x5b\x02\x02\u{b99}\u{b9b}\
	\x07\x07\x02\x02\u{b9a}\u{b99}\x03\x02\x02\x02\u{b9b}\u{b9e}\x03\x02\x02\
	\x02\u{b9c}\u{b9a}\x03\x02\x02\x02\u{b9c}\u{b9d}\x03\x02\x02\x02\u{b9d}\
	\u{b9f}\x03\x02\x02\x02\u{b9e}\u{b9c}\x03\x02\x02\x02\u{b9f}\u{ba3}\x07\
	\x0b\x02\x02\u{ba0}\u{ba2}\x07\x07\x02\x02\u{ba1}\u{ba0}\x03\x02\x02\x02\
	\u{ba2}\u{ba5}\x03\x02\x02\x02\u{ba3}\u{ba1}\x03\x02\x02\x02\u{ba3}\u{ba4}\
	\x03\x02\x02\x02\u{ba4}\u{ba6}\x03\x02\x02\x02\u{ba5}\u{ba3}\x03\x02\x02\
	\x02\u{ba6}\u{baa}\x05\u{9a}\x4e\x02\u{ba7}\u{ba9}\x07\x07\x02\x02\u{ba8}\
	\u{ba7}\x03\x02\x02\x02\u{ba9}\u{bac}\x03\x02\x02\x02\u{baa}\u{ba8}\x03\
	\x02\x02\x02\u{baa}\u{bab}\x03\x02\x02\x02\u{bab}\u{bad}\x03\x02\x02\x02\
	\u{bac}\u{baa}\x03\x02\x02\x02\u{bad}\u{bb1}\x07\x0c\x02\x02\u{bae}\u{bb0}\
	\x07\x07\x02\x02\u{baf}\u{bae}\x03\x02\x02\x02\u{bb0}\u{bb3}\x03\x02\x02\
	\x02\u{bb1}\u{baf}\x03\x02\x02\x02\u{bb1}\u{bb2}\x03\x02\x02\x02\u{bb2}\
	\u{bd3}\x03\x02\x02\x02\u{bb3}\u{bb1}\x03\x02\x02\x02\u{bb4}\u{bd4}\x05\
	\u{88}\x45\x02\u{bb5}\u{bb7}\x05\u{88}\x45\x02\u{bb6}\u{bb5}\x03\x02\x02\
	\x02\u{bb6}\u{bb7}\x03\x02\x02\x02\u{bb7}\u{bbb}\x03\x02\x02\x02\u{bb8}\
	\u{bba}\x07\x07\x02\x02\u{bb9}\u{bb8}\x03\x02\x02\x02\u{bba}\u{bbd}\x03\
	\x02\x02\x02\u{bbb}\u{bb9}\x03\x02\x02\x02\u{bbb}\u{bbc}\x03\x02\x02\x02\
	\u{bbc}\u{bbf}\x03\x02\x02\x02\u{bbd}\u{bbb}\x03\x02\x02\x02\u{bbe}\u{bc0}\
	\x07\x1d\x02\x02\u{bbf}\u{bbe}\x03\x02\x02\x02\u{bbf}\u{bc0}\x03\x02\x02\
	\x02\u{bc0}\u{bc4}\x03\x02\x02\x02\u{bc1}\u{bc3}\x07\x07\x02\x02\u{bc2}\
	\u{bc1}\x03\x02\x02\x02\u{bc3}\u{bc6}\x03\x02\x02\x02\u{bc4}\u{bc2}\x03\
	\x02\x02\x02\u{bc4}\u{bc5}\x03\x02\x02\x02\u{bc5}\u{bc7}\x03\x02\x02\x02\
	\u{bc6}\u{bc4}\x03\x02\x02\x02\u{bc7}\u{bcb}\x07\x5c\x02\x02\u{bc8}\u{bca}\
	\x07\x07\x02\x02\u{bc9}\u{bc8}\x03\x02\x02\x02\u{bca}\u{bcd}\x03\x02\x02\
	\x02\u{bcb}\u{bc9}\x03\x02\x02\x02\u{bcb}\u{bcc}\x03\x02\x02\x02\u{bcc}\
	\u{bd0}\x03\x02\x02\x02\u{bcd}\u{bcb}\x03\x02\x02\x02\u{bce}\u{bd1}\x05\
	\u{88}\x45\x02\u{bcf}\u{bd1}\x07\x1d\x02\x02\u{bd0}\u{bce}\x03\x02\x02\x02\
	\u{bd0}\u{bcf}\x03\x02\x02\x02\u{bd1}\u{bd4}\x03\x02\x02\x02\u{bd2}\u{bd4}\
	\x07\x1d\x02\x02\u{bd3}\u{bb4}\x03\x02\x02\x02\u{bd3}\u{bb6}\x03\x02\x02\
	\x02\u{bd3}\u{bd2}\x03\x02\x02\x02\u{bd4}\u{fd}\x03\x02\x02\x02\u{bd5}\u{bf7}\
	\x07\x0b\x02\x02\u{bd6}\u{bd8}\x05\u{150}\u{a9}\x02\u{bd7}\u{bd6}\x03\x02\
	\x02\x02\u{bd8}\u{bdb}\x03\x02\x02\x02\u{bd9}\u{bd7}\x03\x02\x02\x02\u{bd9}\
	\u{bda}\x03\x02\x02\x02\u{bda}\u{bdf}\x03\x02\x02\x02\u{bdb}\u{bd9}\x03\
	\x02\x02\x02\u{bdc}\u{bde}\x07\x07\x02\x02\u{bdd}\u{bdc}\x03\x02\x02\x02\
	\u{bde}\u{be1}\x03\x02\x02\x02\u{bdf}\u{bdd}\x03\x02\x02\x02\u{bdf}\u{be0}\
	\x03\x02\x02\x02\u{be0}\u{be2}\x03\x02\x02\x02\u{be1}\u{bdf}\x03\x02\x02\
	\x02\u{be2}\u{be6}\x07\x50\x02\x02\u{be3}\u{be5}\x07\x07\x02\x02\u{be4}\
	\u{be3}\x03\x02\x02\x02\u{be5}\u{be8}\x03\x02\x02\x02\u{be6}\u{be4}\x03\
	\x02\x02\x02\u{be6}\u{be7}\x03\x02\x02\x02\u{be7}\u{be9}\x03\x02\x02\x02\
	\u{be8}\u{be6}\x03\x02\x02\x02\u{be9}\u{bed}\x05\x44\x23\x02\u{bea}\u{bec}\
	\x07\x07\x02\x02\u{beb}\u{bea}\x03\x02\x02\x02\u{bec}\u{bef}\x03\x02\x02\
	\x02\u{bed}\u{beb}\x03\x02\x02\x02\u{bed}\u{bee}\x03\x02\x02\x02\u{bee}\
	\u{bf0}\x03\x02\x02\x02\u{bef}\u{bed}\x03\x02\x02\x02\u{bf0}\u{bf4}\x07\
	\x1e\x02\x02\u{bf1}\u{bf3}\x07\x07\x02\x02\u{bf2}\u{bf1}\x03\x02\x02\x02\
	\u{bf3}\u{bf6}\x03\x02\x02\x02\u{bf4}\u{bf2}\x03\x02\x02\x02\u{bf4}\u{bf5}\
	\x03\x02\x02\x02\u{bf5}\u{bf8}\x03\x02\x02\x02\u{bf6}\u{bf4}\x03\x02\x02\
	\x02\u{bf7}\u{bd9}\x03\x02\x02\x02\u{bf7}\u{bf8}\x03\x02\x02\x02\u{bf8}\
	\u{bf9}\x03\x02\x02\x02\u{bf9}\u{bfa}\x05\u{9a}\x4e\x02\u{bfa}\u{bfb}\x07\
	\x0c\x02\x02\u{bfb}\u{ff}\x03\x02\x02\x02\u{bfc}\u{c00}\x07\x5d\x02\x02\
	\u{bfd}\u{bff}\x07\x07\x02\x02\u{bfe}\u{bfd}\x03\x02\x02\x02\u{bff}\u{c02}\
	\x03\x02\x02\x02\u{c00}\u{bfe}\x03\x02\x02\x02\u{c00}\u{c01}\x03\x02\x02\
	\x02\u{c01}\u{c04}\x03\x02\x02\x02\u{c02}\u{c00}\x03\x02\x02\x02\u{c03}\
	\u{c05}\x05\u{fe}\u{80}\x02\u{c04}\u{c03}\x03\x02\x02\x02\u{c04}\u{c05}\
	\x03\x02\x02\x02\u{c05}\u{c09}\x03\x02\x02\x02\u{c06}\u{c08}\x07\x07\x02\
	\x02\u{c07}\u{c06}\x03\x02\x02\x02\u{c08}\u{c0b}\x03\x02\x02\x02\u{c09}\
	\u{c07}\x03\x02\x02\x02\u{c09}\u{c0a}\x03\x02\x02\x02\u{c0a}\u{c0c}\x03\
	\x02\x02\x02\u{c0b}\u{c09}\x03\x02\x02\x02\u{c0c}\u{c10}\x07\x0f\x02\x02\
	\u{c0d}\u{c0f}\x07\x07\x02\x02\u{c0e}\u{c0d}\x03\x02\x02\x02\u{c0f}\u{c12}\
	\x03\x02\x02\x02\u{c10}\u{c0e}\x03\x02\x02\x02\u{c10}\u{c11}\x03\x02\x02\
	\x02\u{c11}\u{c1c}\x03\x02\x02\x02\u{c12}\u{c10}\x03\x02\x02\x02\u{c13}\
	\u{c17}\x05\u{102}\u{82}\x02\u{c14}\u{c16}\x07\x07\x02\x02\u{c15}\u{c14}\
	\x03\x02\x02\x02\u{c16}\u{c19}\x03\x02\x02\x02\u{c17}\u{c15}\x03\x02\x02\
	\x02\u{c17}\u{c18}\x03\x02\x02\x02\u{c18}\u{c1b}\x03\x02\x02\x02\u{c19}\
	\u{c17}\x03\x02\x02\x02\u{c1a}\u{c13}\x03\x02\x02\x02\u{c1b}\u{c1e}\x03\
	\x02\x02\x02\u{c1c}\u{c1a}\x03\x02\x02\x02\u{c1c}\u{c1d}\x03\x02\x02\x02\
	\u{c1d}\u{c22}\x03\x02\x02\x02\u{c1e}\u{c1c}\x03\x02\x02\x02\u{c1f}\u{c21}\
	\x07\x07\x02\x02\u{c20}\u{c1f}\x03\x02\x02\x02\u{c21}\u{c24}\x03\x02\x02\
	\x02\u{c22}\u{c20}\x03\x02\x02\x02\u{c22}\u{c23}\x03\x02\x02\x02\u{c23}\
	\u{c25}\x03\x02\x02\x02\u{c24}\u{c22}\x03\x02\x02\x02\u{c25}\u{c26}\x07\
	\x10\x02\x02\u{c26}\u{101}\x03\x02\x02\x02\u{c27}\u{c38}\x05\u{104}\u{83}\
	\x02\u{c28}\u{c2a}\x07\x07\x02\x02\u{c29}\u{c28}\x03\x02\x02\x02\u{c2a}\
	\u{c2d}\x03\x02\x02\x02\u{c2b}\u{c29}\x03\x02\x02\x02\u{c2b}\u{c2c}\x03\
	\x02\x02\x02\u{c2c}\u{c2e}\x03\x02\x02\x02\u{c2d}\u{c2b}\x03\x02\x02\x02\
	\u{c2e}\u{c32}\x07\x0a\x02\x02\u{c2f}\u{c31}\x07\x07\x02\x02\u{c30}\u{c2f}\
	\x03\x02\x02\x02\u{c31}\u{c34}\x03\x02\x02\x02\u{c32}\u{c30}\x03\x02\x02\
	\x02\u{c32}\u{c33}\x03\x02\x02\x02\u{c33}\u{c35}\x03\x02\x02\x02\u{c34}\
	\u{c32}\x03\x02\x02\x02\u{c35}\u{c37}\x05\u{104}\u{83}\x02\u{c36}\u{c2b}\
	\x03\x02\x02\x02\u{c37}\u{c3a}\x03\x02\x02\x02\u{c38}\u{c36}\x03\x02\x02\
	\x02\u{c38}\u{c39}\x03\x02\x02\x02\u{c39}\u{c42}\x03\x02\x02\x02\u{c3a}\
	\u{c38}\x03\x02\x02\x02\u{c3b}\u{c3d}\x07\x07\x02\x02\u{c3c}\u{c3b}\x03\
	\x02\x02\x02\u{c3d}\u{c40}\x03\x02\x02\x02\u{c3e}\u{c3c}\x03\x02\x02\x02\
	\u{c3e}\u{c3f}\x03\x02\x02\x02\u{c3f}\u{c41}\x03\x02\x02\x02\u{c40}\u{c3e}\
	\x03\x02\x02\x02\u{c41}\u{c43}\x07\x0a\x02\x02\u{c42}\u{c3e}\x03\x02\x02\
	\x02\u{c42}\u{c43}\x03\x02\x02\x02\u{c43}\u{c47}\x03\x02\x02\x02\u{c44}\
	\u{c46}\x07\x07\x02\x02\u{c45}\u{c44}\x03\x02\x02\x02\u{c46}\u{c49}\x03\
	\x02\x02\x02\u{c47}\u{c45}\x03\x02\x02\x02\u{c47}\u{c48}\x03\x02\x02\x02\
	\u{c48}\u{c4a}\x03\x02\x02\x02\u{c49}\u{c47}\x03\x02\x02\x02\u{c4a}\u{c4e}\
	\x07\x24\x02\x02\u{c4b}\u{c4d}\x07\x07\x02\x02\u{c4c}\u{c4b}\x03\x02\x02\
	\x02\u{c4d}\u{c50}\x03\x02\x02\x02\u{c4e}\u{c4c}\x03\x02\x02\x02\u{c4e}\
	\u{c4f}\x03\x02\x02\x02\u{c4f}\u{c51}\x03\x02\x02\x02\u{c50}\u{c4e}\x03\
	\x02\x02\x02\u{c51}\u{c53}\x05\u{88}\x45\x02\u{c52}\u{c54}\x05\u{96}\x4c\
	\x02\u{c53}\u{c52}\x03\x02\x02\x02\u{c53}\u{c54}\x03\x02\x02\x02\u{c54}\
	\u{c68}\x03\x02\x02\x02\u{c55}\u{c59}\x07\x5c\x02\x02\u{c56}\u{c58}\x07\
	\x07\x02\x02\u{c57}\u{c56}\x03\x02\x02\x02\u{c58}\u{c5b}\x03\x02\x02\x02\
	\u{c59}\u{c57}\x03\x02\x02\x02\u{c59}\u{c5a}\x03\x02\x02\x02\u{c5a}\u{c5c}\
	\x03\x02\x02\x02\u{c5b}\u{c59}\x03\x02\x02\x02\u{c5c}\u{c60}\x07\x24\x02\
	\x02\u{c5d}\u{c5f}\x07\x07\x02\x02\u{c5e}\u{c5d}\x03\x02\x02\x02\u{c5f}\
	\u{c62}\x03\x02\x02\x02\u{c60}\u{c5e}\x03\x02\x02\x02\u{c60}\u{c61}\x03\
	\x02\x02\x02\u{c61}\u{c63}\x03\x02\x02\x02\u{c62}\u{c60}\x03\x02\x02\x02\
	\u{c63}\u{c65}\x05\u{88}\x45\x02\u{c64}\u{c66}\x05\u{96}\x4c\x02\u{c65}\
	\u{c64}\x03\x02\x02\x02\u{c65}\u{c66}\x03\x02\x02\x02\u{c66}\u{c68}\x03\
	\x02\x02\x02\u{c67}\u{c27}\x03\x02\x02\x02\u{c67}\u{c55}\x03\x02\x02\x02\
	\u{c68}\u{103}\x03\x02\x02\x02\u{c69}\u{c6d}\x05\u{9a}\x4e\x02\u{c6a}\u{c6d}\
	\x05\u{106}\u{84}\x02\u{c6b}\u{c6d}\x05\u{108}\u{85}\x02\u{c6c}\u{c69}\x03\
	\x02\x02\x02\u{c6c}\u{c6a}\x03\x02\x02\x02\u{c6c}\u{c6b}\x03\x02\x02\x02\
	\u{c6d}\u{105}\x03\x02\x02\x02\u{c6e}\u{c72}\x05\u{11a}\u{8e}\x02\u{c6f}\
	\u{c71}\x07\x07\x02\x02\u{c70}\u{c6f}\x03\x02\x02\x02\u{c71}\u{c74}\x03\
	\x02\x02\x02\u{c72}\u{c70}\x03\x02\x02\x02\u{c72}\u{c73}\x03\x02\x02\x02\
	\u{c73}\u{c75}\x03\x02\x02\x02\u{c74}\u{c72}\x03\x02\x02\x02\u{c75}\u{c76}\
	\x05\u{9a}\x4e\x02\u{c76}\u{107}\x03\x02\x02\x02\u{c77}\u{c7b}\x05\u{11c}\
	\u{8f}\x02\u{c78}\u{c7a}\x07\x07\x02\x02\u{c79}\u{c78}\x03\x02\x02\x02\u{c7a}\
	\u{c7d}\x03\x02\x02\x02\u{c7b}\u{c79}\x03\x02\x02\x02\u{c7b}\u{c7c}\x03\
	\x02\x02\x02\u{c7c}\u{c7e}\x03\x02\x02\x02\u{c7d}\u{c7b}\x03\x02\x02\x02\
	\u{c7e}\u{c7f}\x05\x64\x33\x02\u{c7f}\u{109}\x03\x02\x02\x02\u{c80}\u{c84}\
	\x07\x5e\x02\x02\u{c81}\u{c83}\x07\x07\x02\x02\u{c82}\u{c81}\x03\x02\x02\
	\x02\u{c83}\u{c86}\x03\x02\x02\x02\u{c84}\u{c82}\x03\x02\x02\x02\u{c84}\
	\u{c85}\x03\x02\x02\x02\u{c85}\u{c87}\x03\x02\x02\x02\u{c86}\u{c84}\x03\
	\x02\x02\x02\u{c87}\u{ca3}\x05\u{8a}\x46\x02\u{c88}\u{c8a}\x07\x07\x02\x02\
	\u{c89}\u{c88}\x03\x02\x02\x02\u{c8a}\u{c8d}\x03\x02\x02\x02\u{c8b}\u{c89}\
	\x03\x02\x02\x02\u{c8b}\u{c8c}\x03\x02\x02\x02\u{c8c}\u{c8e}\x03\x02\x02\
	\x02\u{c8d}\u{c8b}\x03\x02\x02\x02\u{c8e}\u{c90}\x05\u{10c}\u{87}\x02\u{c8f}\
	\u{c8b}\x03\x02\x02\x02\u{c90}\u{c91}\x03\x02\x02\x02\u{c91}\u{c8f}\x03\
	\x02\x02\x02\u{c91}\u{c92}\x03\x02\x02\x02\u{c92}\u{c9a}\x03\x02\x02\x02\
	\u{c93}\u{c95}\x07\x07\x02\x02\u{c94}\u{c93}\x03\x02\x02\x02\u{c95}\u{c98}\
	\x03\x02\x02\x02\u{c96}\u{c94}\x03\x02\x02\x02\u{c96}\u{c97}\x03\x02\x02\
	\x02\u{c97}\u{c99}\x03\x02\x02\x02\u{c98}\u{c96}\x03\x02\x02\x02\u{c99}\
	\u{c9b}\x05\u{10e}\u{88}\x02\u{c9a}\u{c96}\x03\x02\x02\x02\u{c9a}\u{c9b}\
	\x03\x02\x02\x02\u{c9b}\u{ca4}\x03\x02\x02\x02\u{c9c}\u{c9e}\x07\x07\x02\
	\x02\u{c9d}\u{c9c}\x03\x02\x02\x02\u{c9e}\u{ca1}\x03\x02\x02\x02\u{c9f}\
	\u{c9d}\x03\x02\x02\x02\u{c9f}\u{ca0}\x03\x02\x02\x02\u{ca0}\u{ca2}\x03\
	\x02\x02\x02\u{ca1}\u{c9f}\x03\x02\x02\x02\u{ca2}\u{ca4}\x05\u{10e}\u{88}\
	\x02\u{ca3}\u{c8f}\x03\x02\x02\x02\u{ca3}\u{c9f}\x03\x02\x02\x02\u{ca4}\
	\u{10b}\x03\x02\x02\x02\u{ca5}\u{ca9}\x07\x5f\x02\x02\u{ca6}\u{ca8}\x07\
	\x07\x02\x02\u{ca7}\u{ca6}\x03\x02\x02\x02\u{ca8}\u{cab}\x03\x02\x02\x02\
	\u{ca9}\u{ca7}\x03\x02\x02\x02\u{ca9}\u{caa}\x03\x02\x02\x02\u{caa}\u{cac}\
	\x03\x02\x02\x02\u{cab}\u{ca9}\x03\x02\x02\x02\u{cac}\u{cb0}\x07\x0b\x02\
	\x02\u{cad}\u{caf}\x05\u{150}\u{a9}\x02\u{cae}\u{cad}\x03\x02\x02\x02\u{caf}\
	\u{cb2}\x03\x02\x02\x02\u{cb0}\u{cae}\x03\x02\x02\x02\u{cb0}\u{cb1}\x03\
	\x02\x02\x02\u{cb1}\u{cb3}\x03\x02\x02\x02\u{cb2}\u{cb0}\x03\x02\x02\x02\
	\u{cb3}\u{cb4}\x05\u{15a}\u{ae}\x02\u{cb4}\u{cb5}\x07\x1c\x02\x02\u{cb5}\
	\u{cbd}\x05\x64\x33\x02\u{cb6}\u{cb8}\x07\x07\x02\x02\u{cb7}\u{cb6}\x03\
	\x02\x02\x02\u{cb8}\u{cbb}\x03\x02\x02\x02\u{cb9}\u{cb7}\x03\x02\x02\x02\
	\u{cb9}\u{cba}\x03\x02\x02\x02\u{cba}\u{cbc}\x03\x02\x02\x02\u{cbb}\u{cb9}\
	\x03\x02\x02\x02\u{cbc}\u{cbe}\x07\x0a\x02\x02\u{cbd}\u{cb9}\x03\x02\x02\
	\x02\u{cbd}\u{cbe}\x03\x02\x02\x02\u{cbe}\u{cbf}\x03\x02\x02\x02\u{cbf}\
	\u{cc3}\x07\x0c\x02\x02\u{cc0}\u{cc2}\x07\x07\x02\x02\u{cc1}\u{cc0}\x03\
	\x02\x02\x02\u{cc2}\u{cc5}\x03\x02\x02\x02\u{cc3}\u{cc1}\x03\x02\x02\x02\
	\u{cc3}\u{cc4}\x03\x02\x02\x02\u{cc4}\u{cc6}\x03\x02\x02\x02\u{cc5}\u{cc3}\
	\x03\x02\x02\x02\u{cc6}\u{cc7}\x05\u{8a}\x46\x02\u{cc7}\u{10d}\x03\x02\x02\
	\x02\u{cc8}\u{ccc}\x07\x60\x02\x02\u{cc9}\u{ccb}\x07\x07\x02\x02\u{cca}\
	\u{cc9}\x03\x02\x02\x02\u{ccb}\u{cce}\x03\x02\x02\x02\u{ccc}\u{cca}\x03\
	\x02\x02\x02\u{ccc}\u{ccd}\x03\x02\x02\x02\u{ccd}\u{ccf}\x03\x02\x02\x02\
	\u{cce}\u{ccc}\x03\x02\x02\x02\u{ccf}\u{cd0}\x05\u{8a}\x46\x02\u{cd0}\u{10f}\
	\x03\x02\x02\x02\u{cd1}\u{cd5}\x07\x64\x02\x02\u{cd2}\u{cd4}\x07\x07\x02\
	\x02\u{cd3}\u{cd2}\x03\x02\x02\x02\u{cd4}\u{cd7}\x03\x02\x02\x02\u{cd5}\
	\u{cd3}\x03\x02\x02\x02\u{cd5}\u{cd6}\x03\x02\x02\x02\u{cd6}\u{cd8}\x03\
	\x02\x02\x02\u{cd7}\u{cd5}\x03\x02\x02\x02\u{cd8}\u{ce2}\x05\u{9a}\x4e\x02\
	\u{cd9}\u{cdb}\x09\x0d\x02\x02\u{cda}\u{cdc}\x05\u{9a}\x4e\x02\u{cdb}\u{cda}\
	\x03\x02\x02\x02\u{cdb}\u{cdc}\x03\x02\x02\x02\u{cdc}\u{ce2}\x03\x02\x02\
	\x02\u{cdd}\u{ce2}\x07\x66\x02\x02\u{cde}\u{ce2}\x07\x3d\x02\x02\u{cdf}\
	\u{ce2}\x07\x67\x02\x02\u{ce0}\u{ce2}\x07\x3e\x02\x02\u{ce1}\u{cd1}\x03\
	\x02\x02\x02\u{ce1}\u{cd9}\x03\x02\x02\x02\u{ce1}\u{cdd}\x03\x02\x02\x02\
	\u{ce1}\u{cde}\x03\x02\x02\x02\u{ce1}\u{cdf}\x03\x02\x02\x02\u{ce1}\u{ce0}\
	\x03\x02\x02\x02\u{ce2}\u{111}\x03\x02\x02\x02\u{ce3}\u{ce5}\x05\x7c\x3f\
	\x02\u{ce4}\u{ce3}\x03\x02\x02\x02\u{ce4}\u{ce5}\x03\x02\x02\x02\u{ce5}\
	\u{ce6}\x03\x02\x02\x02\u{ce6}\u{cea}\x07\x28\x02\x02\u{ce7}\u{ce9}\x07\
	\x07\x02\x02\u{ce8}\u{ce7}\x03\x02\x02\x02\u{ce9}\u{cec}\x03\x02\x02\x02\
	\u{cea}\u{ce8}\x03\x02\x02\x02\u{cea}\u{ceb}\x03\x02\x02\x02\u{ceb}\u{cef}\
	\x03\x02\x02\x02\u{cec}\u{cea}\x03\x02\x02\x02\u{ced}\u{cf0}\x05\u{15a}\
	\u{ae}\x02\u{cee}\u{cf0}\x07\x4c\x02\x02\u{cef}\u{ced}\x03\x02\x02\x02\u{cef}\
	\u{cee}\x03\x02\x02\x02\u{cf0}\u{113}\x03\x02\x02\x02\u{cf1}\u{cf2}\x09\
	\x0e\x02\x02\u{cf2}\u{115}\x03\x02\x02\x02\u{cf3}\u{cf4}\x09\x0f\x02\x02\
	\u{cf4}\u{117}\x03\x02\x02\x02\u{cf5}\u{cf6}\x09\x10\x02\x02\u{cf6}\u{119}\
	\x03\x02\x02\x02\u{cf7}\u{cf8}\x09\x11\x02\x02\u{cf8}\u{11b}\x03\x02\x02\
	\x02\u{cf9}\u{cfa}\x09\x12\x02\x02\u{cfa}\u{11d}\x03\x02\x02\x02\u{cfb}\
	\u{cfc}\x09\x13\x02\x02\u{cfc}\u{11f}\x03\x02\x02\x02\u{cfd}\u{cfe}\x09\
	\x14\x02\x02\u{cfe}\u{121}\x03\x02\x02\x02\u{cff}\u{d00}\x09\x15\x02\x02\
	\u{d00}\u{123}\x03\x02\x02\x02\u{d01}\u{d07}\x07\x16\x02\x02\u{d02}\u{d07}\
	\x07\x17\x02\x02\u{d03}\u{d07}\x07\x15\x02\x02\u{d04}\u{d07}\x07\x14\x02\
	\x02\u{d05}\u{d07}\x05\u{128}\u{95}\x02\u{d06}\u{d01}\x03\x02\x02\x02\u{d06}\
	\u{d02}\x03\x02\x02\x02\u{d06}\u{d03}\x03\x02\x02\x02\u{d06}\u{d04}\x03\
	\x02\x02\x02\u{d06}\u{d05}\x03\x02\x02\x02\u{d07}\u{125}\x03\x02\x02\x02\
	\u{d08}\u{d0d}\x07\x16\x02\x02\u{d09}\u{d0d}\x07\x17\x02\x02\u{d0a}\u{d0b}\
	\x07\x1b\x02\x02\u{d0b}\u{d0d}\x05\u{128}\u{95}\x02\u{d0c}\u{d08}\x03\x02\
	\x02\x02\u{d0c}\u{d09}\x03\x02\x02\x02\u{d0c}\u{d0a}\x03\x02\x02\x02\u{d0d}\
	\u{127}\x03\x02\x02\x02\u{d0e}\u{d0f}\x09\x16\x02\x02\u{d0f}\u{129}\x03\
	\x02\x02\x02\u{d10}\u{d12}\x07\x07\x02\x02\u{d11}\u{d10}\x03\x02\x02\x02\
	\u{d12}\u{d15}\x03\x02\x02\x02\u{d13}\u{d11}\x03\x02\x02\x02\u{d13}\u{d14}\
	\x03\x02\x02\x02\u{d14}\u{d16}\x03\x02\x02\x02\u{d15}\u{d13}\x03\x02\x02\
	\x02\u{d16}\u{d20}\x07\x09\x02\x02\u{d17}\u{d19}\x07\x07\x02\x02\u{d18}\
	\u{d17}\x03\x02\x02\x02\u{d19}\u{d1c}\x03\x02\x02\x02\u{d1a}\u{d18}\x03\
	\x02\x02\x02\u{d1a}\u{d1b}\x03\x02\x02\x02\u{d1b}\u{d1d}\x03\x02\x02\x02\
	\u{d1c}\u{d1a}\x03\x02\x02\x02\u{d1d}\u{d20}\x05\u{12c}\u{97}\x02\u{d1e}\
	\u{d20}\x07\x28\x02\x02\u{d1f}\u{d13}\x03\x02\x02\x02\u{d1f}\u{d1a}\x03\
	\x02\x02\x02\u{d1f}\u{d1e}\x03\x02\x02\x02\u{d20}\u{12b}\x03\x02\x02\x02\
	\u{d21}\u{d22}\x07\x30\x02\x02\u{d22}\u{d23}\x07\x09\x02\x02\u{d23}\u{12d}\
	\x03\x02\x02\x02\u{d24}\u{d27}\x05\u{150}\u{a9}\x02\u{d25}\u{d27}\x05\u{132}\
	\u{9a}\x02\u{d26}\u{d24}\x03\x02\x02\x02\u{d26}\u{d25}\x03\x02\x02\x02\u{d27}\
	\u{d28}\x03\x02\x02\x02\u{d28}\u{d26}\x03\x02\x02\x02\u{d28}\u{d29}\x03\
	\x02\x02\x02\u{d29}\u{12f}\x03\x02\x02\x02\u{d2a}\u{d2d}\x05\u{150}\u{a9}\
	\x02\u{d2b}\u{d2d}\x05\u{14a}\u{a6}\x02\u{d2c}\u{d2a}\x03\x02\x02\x02\u{d2c}\
	\u{d2b}\x03\x02\x02\x02\u{d2d}\u{d2e}\x03\x02\x02\x02\u{d2e}\u{d2c}\x03\
	\x02\x02\x02\u{d2e}\u{d2f}\x03\x02\x02\x02\u{d2f}\u{131}\x03\x02\x02\x02\
	\u{d30}\u{d39}\x05\u{138}\u{9d}\x02\u{d31}\u{d39}\x05\u{13a}\u{9e}\x02\u{d32}\
	\u{d39}\x05\u{13c}\u{9f}\x02\u{d33}\u{d39}\x05\u{144}\u{a3}\x02\u{d34}\u{d39}\
	\x05\u{146}\u{a4}\x02\u{d35}\u{d39}\x05\u{148}\u{a5}\x02\u{d36}\u{d39}\x05\
	\u{14a}\u{a6}\x02\u{d37}\u{d39}\x05\u{14e}\u{a8}\x02\u{d38}\u{d30}\x03\x02\
	\x02\x02\u{d38}\u{d31}\x03\x02\x02\x02\u{d38}\u{d32}\x03\x02\x02\x02\u{d38}\
	\u{d33}\x03\x02\x02\x02\u{d38}\u{d34}\x03\x02\x02\x02\u{d38}\u{d35}\x03\
	\x02\x02\x02\u{d38}\u{d36}\x03\x02\x02\x02\u{d38}\u{d37}\x03\x02\x02\x02\
	\u{d39}\u{d3d}\x03\x02\x02\x02\u{d3a}\u{d3c}\x07\x07\x02\x02\u{d3b}\u{d3a}\
	\x03\x02\x02\x02\u{d3c}\u{d3f}\x03\x02\x02\x02\u{d3d}\u{d3b}\x03\x02\x02\
	\x02\u{d3d}\u{d3e}\x03\x02\x02\x02\u{d3e}\u{133}\x03\x02\x02\x02\u{d3f}\
	\u{d3d}\x03\x02\x02\x02\u{d40}\u{d42}\x05\u{136}\u{9c}\x02\u{d41}\u{d40}\
	\x03\x02\x02\x02\u{d42}\u{d43}\x03\x02\x02\x02\u{d43}\u{d41}\x03\x02\x02\
	\x02\u{d43}\u{d44}\x03\x02\x02\x02\u{d44}\u{135}\x03\x02\x02\x02\u{d45}\
	\u{d4e}\x05\u{150}\u{a9}\x02\u{d46}\u{d4a}\x07\x7e\x02\x02\u{d47}\u{d49}\
	\x07\x07\x02\x02\u{d48}\u{d47}\x03\x02\x02\x02\u{d49}\u{d4c}\x03\x02\x02\
	\x02\u{d4a}\u{d48}\x03\x02\x02\x02\u{d4a}\u{d4b}\x03\x02\x02\x02\u{d4b}\
	\u{d4e}\x03\x02\x02\x02\u{d4c}\u{d4a}\x03\x02\x02\x02\u{d4d}\u{d45}\x03\
	\x02\x02\x02\u{d4d}\u{d46}\x03\x02\x02\x02\u{d4e}\u{137}\x03\x02\x02\x02\
	\u{d4f}\u{d50}\x09\x17\x02\x02\u{d50}\u{139}\x03\x02\x02\x02\u{d51}\u{d52}\
	\x09\x18\x02\x02\u{d52}\u{13b}\x03\x02\x02\x02\u{d53}\u{d54}\x09\x19\x02\
	\x02\u{d54}\u{13d}\x03\x02\x02\x02\u{d55}\u{d56}\x09\x1a\x02\x02\u{d56}\
	\u{13f}\x03\x02\x02\x02\u{d57}\u{d59}\x05\u{142}\u{a2}\x02\u{d58}\u{d57}\
	\x03\x02\x02\x02\u{d59}\u{d5a}\x03\x02\x02\x02\u{d5a}\u{d58}\x03\x02\x02\
	\x02\u{d5a}\u{d5b}\x03\x02\x02\x02\u{d5b}\u{141}\x03\x02\x02\x02\u{d5c}\
	\u{d60}\x05\u{14c}\u{a7}\x02\u{d5d}\u{d5f}\x07\x07\x02\x02\u{d5e}\u{d5d}\
	\x03\x02\x02\x02\u{d5f}\u{d62}\x03\x02\x02\x02\u{d60}\u{d5e}\x03\x02\x02\
	\x02\u{d60}\u{d61}\x03\x02\x02\x02\u{d61}\u{d6c}\x03\x02\x02\x02\u{d62}\
	\u{d60}\x03\x02\x02\x02\u{d63}\u{d67}\x05\u{13e}\u{a0}\x02\u{d64}\u{d66}\
	\x07\x07\x02\x02\u{d65}\u{d64}\x03\x02\x02\x02\u{d66}\u{d69}\x03\x02\x02\
	\x02\u{d67}\u{d65}\x03\x02\x02\x02\u{d67}\u{d68}\x03\x02\x02\x02\u{d68}\
	\u{d6c}\x03\x02\x02\x02\u{d69}\u{d67}\x03\x02\x02\x02\u{d6a}\u{d6c}\x05\
	\u{150}\u{a9}\x02\u{d6b}\u{d5c}\x03\x02\x02\x02\u{d6b}\u{d63}\x03\x02\x02\
	\x02\u{d6b}\u{d6a}\x03\x02\x02\x02\u{d6c}\u{143}\x03\x02\x02\x02\u{d6d}\
	\u{d6e}\x09\x1b\x02\x02\u{d6e}\u{145}\x03\x02\x02\x02\u{d6f}\u{d70}\x07\
	\u{83}\x02\x02\u{d70}\u{147}\x03\x02\x02\x02\u{d71}\u{d72}\x09\x1c\x02\x02\
	\u{d72}\u{149}\x03\x02\x02\x02\u{d73}\u{d74}\x09\x1d\x02\x02\u{d74}\u{14b}\
	\x03\x02\x02\x02\u{d75}\u{d76}\x07\u{88}\x02\x02\u{d76}\u{14d}\x03\x02\x02\
	\x02\u{d77}\u{d78}\x09\x1e\x02\x02\u{d78}\u{14f}\x03\x02\x02\x02\u{d79}\
	\u{d7c}\x05\u{152}\u{aa}\x02\u{d7a}\u{d7c}\x05\u{154}\u{ab}\x02\u{d7b}\u{d79}\
	\x03\x02\x02\x02\u{d7b}\u{d7a}\x03\x02\x02\x02\u{d7c}\u{d80}\x03\x02\x02\
	\x02\u{d7d}\u{d7f}\x07\x07\x02\x02\u{d7e}\u{d7d}\x03\x02\x02\x02\u{d7f}\
	\u{d82}\x03\x02\x02\x02\u{d80}\u{d7e}\x03\x02\x02\x02\u{d80}\u{d81}\x03\
	\x02\x02\x02\u{d81}\u{151}\x03\x02\x02\x02\u{d82}\u{d80}\x03\x02\x02\x02\
	\u{d83}\u{d87}\x05\u{156}\u{ac}\x02\u{d84}\u{d86}\x07\x07\x02\x02\u{d85}\
	\u{d84}\x03\x02\x02\x02\u{d86}\u{d89}\x03\x02\x02\x02\u{d87}\u{d85}\x03\
	\x02\x02\x02\u{d87}\u{d88}\x03\x02\x02\x02\u{d88}\u{d8d}\x03\x02\x02\x02\
	\u{d89}\u{d87}\x03\x02\x02\x02\u{d8a}\u{d8d}\x07\x2b\x02\x02\u{d8b}\u{d8d}\
	\x07\x2d\x02\x02\u{d8c}\u{d83}\x03\x02\x02\x02\u{d8c}\u{d8a}\x03\x02\x02\
	\x02\u{d8c}\u{d8b}\x03\x02\x02\x02\u{d8d}\u{d8e}\x03\x02\x02\x02\u{d8e}\
	\u{d8f}\x05\u{158}\u{ad}\x02\u{d8f}\u{153}\x03\x02\x02\x02\u{d90}\u{d94}\
	\x05\u{156}\u{ac}\x02\u{d91}\u{d93}\x07\x07\x02\x02\u{d92}\u{d91}\x03\x02\
	\x02\x02\u{d93}\u{d96}\x03\x02\x02\x02\u{d94}\u{d92}\x03\x02\x02\x02\u{d94}\
	\u{d95}\x03\x02\x02\x02\u{d95}\u{d9a}\x03\x02\x02\x02\u{d96}\u{d94}\x03\
	\x02\x02\x02\u{d97}\u{d9a}\x07\x2b\x02\x02\u{d98}\u{d9a}\x07\x2d\x02\x02\
	\u{d99}\u{d90}\x03\x02\x02\x02\u{d99}\u{d97}\x03\x02\x02\x02\u{d99}\u{d98}\
	\x03\x02\x02\x02\u{d9a}\u{d9b}\x03\x02\x02\x02\u{d9b}\u{d9d}\x07\x0d\x02\
	\x02\u{d9c}\u{d9e}\x05\u{158}\u{ad}\x02\u{d9d}\u{d9c}\x03\x02\x02\x02\u{d9e}\
	\u{d9f}\x03\x02\x02\x02\u{d9f}\u{d9d}\x03\x02\x02\x02\u{d9f}\u{da0}\x03\
	\x02\x02\x02\u{da0}\u{da1}\x03\x02\x02\x02\u{da1}\u{da2}\x07\x0e\x02\x02\
	\u{da2}\u{155}\x03\x02\x02\x02\u{da3}\u{da4}\x09\x02\x02\x02\u{da4}\u{da8}\
	\x09\x1f\x02\x02\u{da5}\u{da7}\x07\x07\x02\x02\u{da6}\u{da5}\x03\x02\x02\
	\x02\u{da7}\u{daa}\x03\x02\x02\x02\u{da8}\u{da6}\x03\x02\x02\x02\u{da8}\
	\u{da9}\x03\x02\x02\x02\u{da9}\u{dab}\x03\x02\x02\x02\u{daa}\u{da8}\x03\
	\x02\x02\x02\u{dab}\u{dac}\x07\x1c\x02\x02\u{dac}\u{157}\x03\x02\x02\x02\
	\u{dad}\u{db0}\x05\x26\x14\x02\u{dae}\u{db0}\x05\x6c\x37\x02\u{daf}\u{dad}\
	\x03\x02\x02\x02\u{daf}\u{dae}\x03\x02\x02\x02\u{db0}\u{159}\x03\x02\x02\
	\x02\u{db1}\u{db2}\x09\x20\x02\x02\u{db2}\u{15b}\x03\x02\x02\x02\u{db3}\
	\u{dbe}\x05\u{15a}\u{ae}\x02\u{db4}\u{db6}\x07\x07\x02\x02\u{db5}\u{db4}\
	\x03\x02\x02\x02\u{db6}\u{db9}\x03\x02\x02\x02\u{db7}\u{db5}\x03\x02\x02\
	\x02\u{db7}\u{db8}\x03\x02\x02\x02\u{db8}\u{dba}\x03\x02\x02\x02\u{db9}\
	\u{db7}\x03\x02\x02\x02\u{dba}\u{dbb}\x07\x09\x02\x02\u{dbb}\u{dbd}\x05\
	\u{15a}\u{ae}\x02\u{dbc}\u{db7}\x03\x02\x02\x02\u{dbd}\u{dc0}\x03\x02\x02\
	\x02\u{dbe}\u{dbc}\x03\x02\x02\x02\u{dbe}\u{dbf}\x03\x02\x02\x02\u{dbf}\
	\u{15d}\x03\x02\x02\x02\u{dc0}\u{dbe}\x03\x02\x02\x02\u{220}\u{15f}\u{164}\
	\u{16a}\u{172}\u{178}\u{17d}\u{183}\u{18d}\u{196}\u{19d}\u{1a4}\u{1ab}\u{1b0}\
	\u{1b5}\u{1bb}\u{1bd}\u{1c2}\u{1ca}\u{1cd}\u{1d4}\u{1d7}\u{1dd}\u{1e4}\u{1e8}\
	\u{1ed}\u{1f4}\u{1fe}\u{201}\u{208}\u{20b}\u{20e}\u{213}\u{21a}\u{21e}\u{223}\
	\u{227}\u{22c}\u{233}\u{237}\u{23c}\u{240}\u{245}\u{24c}\u{250}\u{253}\u{259}\
	\u{25c}\u{264}\u{26b}\u{274}\u{27b}\u{282}\u{288}\u{28e}\u{292}\u{294}\u{299}\
	\u{29f}\u{2a2}\u{2a7}\u{2af}\u{2b6}\u{2bd}\u{2c1}\u{2c7}\u{2ce}\u{2d4}\u{2df}\
	\u{2e3}\u{2e9}\u{2f1}\u{2f7}\u{2fe}\u{303}\u{30a}\u{313}\u{31a}\u{321}\u{327}\
	\u{32d}\u{331}\u{336}\u{33c}\u{341}\u{348}\u{34f}\u{353}\u{359}\u{360}\u{367}\
	\u{36d}\u{373}\u{37a}\u{381}\u{388}\u{38c}\u{393}\u{399}\u{39f}\u{3a5}\u{3a9}\
	\u{3ae}\u{3b5}\u{3b9}\u{3be}\u{3c5}\u{3c9}\u{3ce}\u{3d2}\u{3d8}\u{3df}\u{3e6}\
	\u{3ec}\u{3f2}\u{3f6}\u{3f8}\u{3fd}\u{403}\u{409}\u{410}\u{414}\u{417}\u{41d}\
	\u{421}\u{426}\u{42d}\u{432}\u{437}\u{43e}\u{445}\u{44c}\u{450}\u{455}\u{459}\
	\u{45e}\u{462}\u{469}\u{46d}\u{472}\u{478}\u{47f}\u{486}\u{48a}\u{490}\u{497}\
	\u{49e}\u{4a4}\u{4aa}\u{4ae}\u{4b3}\u{4b9}\u{4bf}\u{4c3}\u{4c8}\u{4cf}\u{4d4}\
	\u{4d9}\u{4de}\u{4e3}\u{4e7}\u{4ec}\u{4f3}\u{4f8}\u{4fa}\u{4ff}\u{503}\u{508}\
	\u{50c}\u{511}\u{515}\u{518}\u{51b}\u{520}\u{524}\u{527}\u{529}\u{52f}\u{535}\
	\u{53b}\u{542}\u{549}\u{550}\u{554}\u{559}\u{55d}\u{560}\u{566}\u{56d}\u{574}\
	\u{578}\u{57d}\u{584}\u{58b}\u{58f}\u{594}\u{599}\u{59f}\u{5a6}\u{5ad}\u{5b3}\
	\u{5b9}\u{5bd}\u{5bf}\u{5c4}\u{5ca}\u{5d0}\u{5d7}\u{5db}\u{5e1}\u{5e8}\u{5ec}\
	\u{5f2}\u{5f9}\u{5ff}\u{605}\u{60c}\u{613}\u{617}\u{61c}\u{620}\u{623}\u{629}\
	\u{630}\u{637}\u{63b}\u{640}\u{644}\u{64a}\u{653}\u{657}\u{65c}\u{663}\u{667}\
	\u{66c}\u{675}\u{67c}\u{682}\u{688}\u{68c}\u{692}\u{695}\u{69b}\u{69f}\u{6a4}\
	\u{6a8}\u{6ab}\u{6b2}\u{6b6}\u{6ba}\u{6bf}\u{6c5}\u{6cd}\u{6d4}\u{6da}\u{6e1}\
	\u{6e5}\u{6e8}\u{6ec}\u{6f1}\u{6f7}\u{6fb}\u{701}\u{708}\u{70b}\u{711}\u{718}\
	\u{721}\u{726}\u{72b}\u{732}\u{737}\u{73b}\u{741}\u{745}\u{74a}\u{753}\u{75a}\
	\u{760}\u{765}\u{76b}\u{770}\u{775}\u{77b}\u{77f}\u{784}\u{78b}\u{78f}\u{793}\
	\u{79b}\u{79e}\u{7a1}\u{7a5}\u{7a7}\u{7ae}\u{7b5}\u{7ba}\u{7c0}\u{7c7}\u{7cf}\
	\u{7d5}\u{7dc}\u{7e1}\u{7e9}\u{7ed}\u{7f3}\u{7fc}\u{801}\u{807}\u{80b}\u{810}\
	\u{817}\u{824}\u{829}\u{832}\u{838}\u{840}\u{847}\u{84d}\u{854}\u{85b}\u{861}\
	\u{869}\u{870}\u{878}\u{87f}\u{886}\u{88e}\u{897}\u{89c}\u{89e}\u{8a5}\u{8ac}\
	\u{8b3}\u{8be}\u{8c5}\u{8cd}\u{8d3}\u{8db}\u{8e2}\u{8ea}\u{8f1}\u{8f8}\u{8ff}\
	\u{906}\u{90c}\u{917}\u{91a}\u{920}\u{928}\u{92f}\u{935}\u{93c}\u{943}\u{949}\
	\u{950}\u{958}\u{95e}\u{965}\u{96c}\u{972}\u{978}\u{97c}\u{981}\u{98a}\u{990}\
	\u{993}\u{996}\u{99a}\u{99f}\u{9a3}\u{9a8}\u{9b1}\u{9b8}\u{9bf}\u{9c5}\u{9cb}\
	\u{9cf}\u{9d4}\u{9dd}\u{9e4}\u{9eb}\u{9f1}\u{9f7}\u{9fb}\u{a00}\u{a03}\u{a08}\
	\u{a0d}\u{a14}\u{a1b}\u{a1e}\u{a21}\u{a26}\u{a39}\u{a3f}\u{a46}\u{a4f}\u{a56}\
	\u{a5d}\u{a63}\u{a69}\u{a6d}\u{a72}\u{a75}\u{a7d}\u{a82}\u{a84}\u{a8d}\u{a8f}\
	\u{a9a}\u{aa1}\u{aac}\u{ab3}\u{abc}\u{ac0}\u{ac5}\u{acc}\u{acf}\u{ad5}\u{ade}\
	\u{ae5}\u{aeb}\u{af1}\u{af5}\u{afc}\u{b03}\u{b07}\u{b09}\u{b0c}\u{b11}\u{b18}\
	\u{b1f}\u{b24}\u{b29}\u{b30}\u{b37}\u{b3b}\u{b40}\u{b44}\u{b49}\u{b4d}\u{b51}\
	\u{b54}\u{b59}\u{b60}\u{b67}\u{b6e}\u{b71}\u{b76}\u{b7a}\u{b83}\u{b8a}\u{b8f}\
	\u{b93}\u{b96}\u{b9c}\u{ba3}\u{baa}\u{bb1}\u{bb6}\u{bbb}\u{bbf}\u{bc4}\u{bcb}\
	\u{bd0}\u{bd3}\u{bd9}\u{bdf}\u{be6}\u{bed}\u{bf4}\u{bf7}\u{c00}\u{c04}\u{c09}\
	\u{c10}\u{c17}\u{c1c}\u{c22}\u{c2b}\u{c32}\u{c38}\u{c3e}\u{c42}\u{c47}\u{c4e}\
	\u{c53}\u{c59}\u{c60}\u{c65}\u{c67}\u{c6c}\u{c72}\u{c7b}\u{c84}\u{c8b}\u{c91}\
	\u{c96}\u{c9a}\u{c9f}\u{ca3}\u{ca9}\u{cb0}\u{cb9}\u{cbd}\u{cc3}\u{ccc}\u{cd5}\
	\u{cdb}\u{ce1}\u{ce4}\u{cea}\u{cef}\u{d06}\u{d0c}\u{d13}\u{d1a}\u{d1f}\u{d26}\
	\u{d28}\u{d2c}\u{d2e}\u{d38}\u{d3d}\u{d43}\u{d4a}\u{d4d}\u{d5a}\u{d60}\u{d67}\
	\u{d6b}\u{d7b}\u{d80}\u{d87}\u{d8c}\u{d94}\u{d99}\u{d9f}\u{da8}\u{daf}\u{db7}\
	\u{dbe}";

